// Edited scripts for Sonic 3: D.A. Garden Edition.
// These are likely inefficient, but they work!

// constant bool CHEAT_ONE_BLUE_SPHERE = true

// Set version number to show at the end of time attacks and marathon runs.
// This variable is not actually called yet, but may be in the future.
global u64 DAGE_version = "D.A. Garden Edition v1.10.2.0"
#define DAGE_running = 0x1a20

// Define variables for in-game settings
global u8 palette_set
global u8 rain_intensity
global bool giant_ring_counter
global u8 hcz_murkiness
// global u8 new_title
global u8 eggrobos_sonictails = 1
global u8 eggrobos_knuckles = 1
global u8 specialstages_knuckles
global u8 roll_maintain
// global u8 green_sphere_palette	// deprecated option
global u8 greenspheres_music
global u8 pause_menu
define u8 theme.hud = u8[0x840273]
global u8 theme.max
global u16 screen_width
global bool challenge_greenspheres
global bool sonic_moves
global bool display_inputs
global bool original_mode
global bool menu_initialized
global bool fast_forward
global bool originsDropDash

// Define variables and number of frames per rev for L button spindash charge
global u8 L_TailsAssist	// settings variable. 0 = Up+A only, 1 = L only, 2 = both
global u8 L_Spindash	// settings variable. 0 = off, 1 = on
global u8 L_Spindash_Charge
global u8 L_Spindash_Charge_P2
constant u8 L_Spindash_ChargeInterval = 5

// Define special stage variables
// global u8 yellow_spheres	// if 0, use green spheres instead
define u8 green_spheres.active	= u8[0x8e1218]			// Set to 0x01 when the Green Spheres mode is active
define u8 specialstages_knuckles.shared	= u8[0x8e121c]	// Holds a copy of the global specialstages_knuckles for access by mods
global u16 BS_displayedTime
global bool BS_fadeFinished
global u8 restartSpecialStage

// Define variables for maintaining roll
global u8 air_time
global u8 air_time_p2
// global u16 last_ground_y_pos

// Define variables for time attack modes
global u16 medalCount
global u8 time_attack	// Use 0 for a normal game. Use 1 for standard time attack and 2 for Time Stone Trial mode. Use 3 for Marathon and 4 for No Emeralds Marathon mode.
define u8 time_attack_hud = u8[0x840270]	// Use 0 for left-aligned and 1 for center-aligned
global u8 time_attack_end	// 1 when a time attack or Time Stone Trial has ended. Resets to 0 when a level loads in either of the two modes via Standalone.onLevelStart().
global u8 restart_timer
global u8 exit_timer
define u8 time_attack_hud.layout = u8[0x840271]
define u8 exit_threshold = u8[0x840272]
global u8 time_attack_instructions
global u32 freeze_time
global u32 freeze_time_bonus
global u32 timer.alldata_copy
// global u32 best_time_address
global u32 best_time
global u8 best_time_minutes
global u8 best_time_seconds
global u8 best_time_frames
global s8 TA_menu_selection			// signed to catch underflow from going under option 0
global s8 pause_menu_selection		// signed to catch underflow from going under option 0
define best_time_address = u32[0x840274]	
define redstarring_address = u32[0x840278]
global bool soz2_initial_ghosts
global u64 marathon_timer
global bool sidekick
global s16 pole.x
global s16 pole.y

// Define memory location to store star count
define u16 total_stars = u16[0x8402fe]

// Dev cheat for gaining stars
global u8 cheatEntry
global u16 cheatStars

global bool exitGame
global bool AIR_menu_run
global bool draw_HUD = 1
global bool letters_marathonhud

// Include other script files
// string_display is Custom Text Display mod by ElspethThePict, allowed for other mods with credit given
include blue_spheres
include eggrobo
include palettes_weather
include time_attack
include ring_object_managers
include movement_changes
include rom_manipulations
include music
include credits
include themes/?
include RtWI/?

// Only include this when getting clean screenshots without the HUD or character
// include screenshots

// Include Custom Menu Framework mod by Airway1
include CustomMenuFramework/?

// Include future Sonic 3 AIR scripts to prepare them for Original Mode or later updates
// include FutureS3AIRScripts/?

// Include pause menu framework by FadeInside
include menu_pause

// Include SHC splash screen activation
// include shc_screen




// Theme constants
constant u8 theme.s3k    = 0
constant u8 theme.flicky = 1
constant u8 theme.saturn = 2
constant u8 theme.south  = 3
constant u8 theme.westside  = 4

// Value for HUD layout
global u8 hud.layout

// Flag for unlockable levels
global u16 unlock_act
global u8 layout.part

// Flag and timer for unlock announcements
global bool unlock.show
global u16 unlock.timer

// Copy of level.giantrings_clear for use with the new on-screen counter during level results
global u32 giantRingsCollected.array

// Number of stars for unlocks constants
constant u16 unlock.theme.south = 25
constant u16 unlock.theme.westside = 50
constant u16 unlock.level.ehz   = 50
constant u16 unlock.level.cpz   = 100

// Memory address constants
constant u32 KosinskiRawdataBuffer = 0x840600
constant u32 s2_angles_address = 0x854000
constant u32 s2_heightmaps_address = 0x854100	// s2_angles_address + 0x100
constant u32 s2_heightmapsrotated_address = 0x855100	// s2_heightmaps_address + 0x1000
constant u32 s2_decompression_buffer = 0x860000
constant u32 s2_levelanimation_address = 0x870800
constant u32 s2_mappings_address = 0x880000
constant u32 s2_decompression_buffer_2 = 0x890000


// This is the first function called in a frame.
/*
function void scriptMainEntryPoint()
{
	if (SHCSplash.shouldShowUpAfterStartup())
		SHCSplash.showSplashScreen()

	System.setupCallFrame("GameModeControlLoop")
}
*/

// This function is called just before the end of a frame.
// Use it to track and show any values on screen with debugLog() and debugWatch().
function void showDebugText()
{
/*
	if (Input.buttonPressed(BUTTON_Y))
	{
		theme.hud += 1
		if (theme.hud == 3)
			theme.hud = 0

	}
	else if (Input.buttonPressed(BUTTON_BACK))
	{
		if (theme.hud == 0)
			theme.hud = 2
		else
			theme.hud -= 1

	}
*/

//	debugLog(stringformat("A0 = %x", A0))
//	debugLog(stringformat("time_attack = %d, setting.time_attack = %d", time_attack, setting.time_attack))
//	debugWatch(0xffffb014, 2)
}

// This function is the final one of any frame.
function void endOfFrame()
{
	if (exitGame)
	{
		exitGame = 0
		global.active_saveslot = 0			// do not allow a save slot to be active
		time_attack = 0
		water.fullscreen = 0
		marathon_timer = 0
		draw_HUD = false					// Do not draw HUD in menus. initializeMainGame() will activate the HUD.
		water.fullscreen = 0				// Set in case we quit the game while totally underwater.
		original_mode = 0					// Remove original mode in main menu
		eggrobos_knuckles = 1				// Default to Hard Mode in case we are in Challenges
		specialstages_knuckles = 1			// Default to Hard Mode in case we are in Challenges
		restartSpecialStage = 0
		fast_forward = false
		unlock_act = 0
		Audio.stopChannel(0)

		menu_initialized = 0
		Game.returnToMainMenu()
	}
	
	// Handle roll leniency.
	// This isn't the ideal place to do this, but every ideal place is already overwritten by many character mods, especially Extra Slot mods.
	if (roll_maintain && !original_mode)
		rollLeniency.CountFrames()

	// Handle unlock announcements.
	if (unlock.show)
		Unlock.showUnlock()

//	if (time_attack >= 3 && draw_HUD)
//		RenderMarathonTimer()

	discordRPC.main()
}

function void discordRPC.main()
{
	Game.setDiscordDetails("D.A. Garden Edition")

	u8 gameMode = (global.game_mode & 0x7f)
	// Comeptition mode is handled by the engine, so don't overwrite it.
	if ((global.zone >= 0x0e && global.zone <= 0x12) || gameMode <= 0x04 || (gameMode >= 0x1c && gameMode <= 0x28) || (gameMode >= 0x38 && gameMode <= 0x44) || gameMode == 0x50)	// competition zone or a game mode A.I.R. handles on its own
		return

	// The A.I.R. menu is handled by the engine, but everything else must be scripted.
	if (gameMode == 0x58)
		discordRPC.mainMenu()
	else if (gameMode == 0x54 || time_attack == 1 || time_attack == 2)
		discordRPC.challenges()
	else if (gameMode == 0x2c || gameMode == 0x30 || (bluespheres.minigame_mode == 1 && gameMode == 0x34))
		discordRPC.greenSphere()
	else if (gameMode == 0x4c)
		discordRPC.dataSelect()
	else
		discordRPC.mainGame()
}

function void discordRPC.greenSphere()
{
	Game.setDiscordState(stringformat("Green Sphere Level %d", u32[0xffffffa6] + 1))
	Game.setDiscordLargeImage("gamemode_bluesphere")
	if ((global.game_mode & 0x7f) == 0x34)
		discordRPC.setCharacterImage()
	else
		Game.setDiscordSmallImage("null")
}

function void discordRPC.mainMenu()
{
	Game.setDiscordState("Main Menu")
	Game.setDiscordSmallImage("null")
	Game.setDiscordLargeImage("menus")
}

function void discordRPC.dataSelect()	// A.I.R. sometimes forces its "In the Menus" RPC here, but not always
{
	Game.setDiscordState("Data Select")
	Game.setDiscordSmallImage("null")
	Game.setDiscordLargeImage("menus")
}

function void discordRPC.challenges()
{
	Game.setDiscordState(stringformat("Challenges (%d/825 Stars)", total_stars))
	if ((global.game_mode & 0x7f) != 0x54)
	{
		discordRPC.setCharacterImage()
		discordRPC.setZoneImage()
	}
	else
	{
		Game.setDiscordSmallImage("null")
		Game.setDiscordLargeImage("menus")
	}
}

function void discordRPC.mainGame()
{
	// Get game type
	u64 gameType = "Revisited Mode"
	if (original_mode)
		gameType = "Classic Mode"
	else if (time_attack == 3)
		gameType = "100% Speedrun"

	if (unlock_act == 1)
		gameType = "Emerald Hill Zone"
	else if (unlock_act == 2)
		gameType = "Chemical Plant Zone"
	// else if (time_attack == 4)	// unused, as it's a special case that won't state emerald count
	//	gameType = "Any% Speedrun"

	// Get character name. Unused for now.
	/*
	u64 character = "Sonic and Tails"
	if (global.characters == 1)
		character = "Sonic"
	else if (global.characters == 2)
		character = "Tails"
	else	// if (global.characters == 3)
		if (useKnucklesAndTails)
			character = "Knuckles and Tails"
		else
			character = "Knuckles"
	*/
	
	if (time_attack == 4)
		Game.setDiscordState("Any% Speedrun")
	else if (global.chaos_emeralds + global.super_emeralds == 1)
	{
		Game.setDiscordState(stringformat("%s, 1 Emerald", gameType))	// remove "s" when only 1 emerald has been collected
	}
	else
		Game.setDiscordState(stringformat("%s, %d Emeralds", gameType, global.chaos_emeralds + global.super_emeralds))
	discordRPC.setCharacterImage()
	discordRPC.setZoneImage()
}

function void discordRPC.setCharacterImage()
{
	if (global.characters == 0)
		Game.setDiscordSmallImage("character_sonic_tails")
	else if (global.characters == 1)
		Game.setDiscordSmallImage("character_sonic")
	else if (global.characters == 2)
		Game.setDiscordSmallImage("character_tails")
	else	// if (global.characters == 3)
		if (useKnucklesAndTails)
			Game.setDiscordSmallImage("character_knuckles_tails")
		else
			Game.setDiscordSmallImage("character_knuckles")
}

function void discordRPC.setZoneImage()
{
	if (global.zone_act == 0x1700)				// DEZ2 boss
	{
		Game.setDiscordLargeImage("zone13_dez")
		return
	}
	else if (global.zone == 0x0d || unlock_act)	// outro or unlockable act
	{
		Game.setDiscordLargeImage("sonic3air")
		return
	}

	u8 checkpoint.zone = u8[0xfffffe2c]		// first byte of u16 checkpoint.zone_act
	u8 level.backup.zone = u8[0xfffffe4a]	// first byte of u16 level.backup.zone_act
	u8 zone = (global.zone >= 0x13 && global.zone <= 0x15) ? checkpoint.zone : global.zone	// if in a bonus stage, use the originating zone
	if ((global.game_mode & 0x7f) == 0x34 || (global.game_mode & 0x7f) == 0x48 || global.zone_act == 0x1701)
		zone = level.backup.zone
	
	if (zone == 0x16 && checkpoint.zone_act == 0x1601)	// HPZ
		Game.setDiscordLargeImage("zone11_hpz")
	else if (zone == 0x16)
		Game.setDiscordLargeImage("zone10_lrz")
	else if (zone == 0x04)			// FBZ
		Game.setDiscordLargeImage("zone08_fbz")
	else if (zone >= 0x0a && zone <= 0x0c)	// SSZ, DEZ, DDZ
		Game.setDiscordLargeImage(stringformat("zone%02d_%s", zone + 2, getZoneInitials(zone)))
	else if (zone >= 0x05 && zone <= 0x07)	// ICZ, LBZ, MHZ
		Game.setDiscordLargeImage(stringformat("zone%02d_%s", zone , getZoneInitials(zone)))
	else							// all other levels
		Game.setDiscordLargeImage(stringformat("zone%02d_%s", zone + 1, getZoneInitials(zone)))
}




// Change A.I.R. menu palette when new palettes are active
// and add version text to the A.I.R. menu in A.I.R. versions that support it
// Function taken from standalone\mainmenu\mainmenu_background.lemon
#if GAMEAPP >= 0x22051500
function void MainMenuBG.Run()
{
	AIR_menu_run = 1
	unlock_act = 0
	time_attack_end = 0

	held_time.up = 0
	held_time.down = 0
	held_time.right = 0
	held_time.left = 0
	
	global.game_mode = 0x0c
	global.zone_act = 0x0d01

	// Load the required level patterns for the outro
	//  -> This is essentially the same as "fn007812", but without the call to "waitForNextFrame", and hard-coded 0x1cfb44 to simplify things
	{
		A4 = MainGame.getLevelDataPointer()
		A1 = 0x1cfb44
		D4.u16 = u16[A1]
		Kosinski.addToDMAQueue(A1, 0x0000)

		while (true)
		{
			global.frame_state = 0x0c
			Kosinski.ProcessDecompressionQueue()

			LoadRequiredSpritePatterns()
			Kosinski.ProcessModules()
			if (kosinski.waiting_modules == 0)
				break
		}
	}

	// Load level chunks and stuff
	fn01c2b0()

	// Load plane contents
	camera.foreground.x.u16 = 0x0280
	camera.foreground.y.u16 = 0
	camera.background.x.u16 = 0
	camera.background.y.u16 = 0x0800
	fillPlane_DefaultUncropped(0xc000, camera.foreground.x.u16, camera.foreground.y.u16, 512, getScreenHeight())
	fillPlane_DefaultUncropped(0xe000, camera.background.x.u16, camera.background.y.u16, 512, getScreenHeight())
	camera.foreground.x.u16 += 22		// Move camera a few pixels to the right by default
	u16 cameraForegroundX = camera.foreground.x.u16
	u16 cameraBackgroundX = camera.background.x.u16

	// Flip the right half of certain lines in plane B, to make the ocean waves look more seamless
	constant array<u16> LINE_VRAM_ADDRESS =
	{
		0xec40, 0xecc0, 0xedc0
	}
	for (u16 lineIndex = 0; lineIndex < 3; ++lineIndex)
	{
		u16 addr = LINE_VRAM_ADDRESS[lineIndex]
		for (u16 i = 0; i < 0x20; i += 2)
		{
			u16 pattern1 = getVRAM(addr + i)
			u16 pattern2 = getVRAM(addr + 0x3e - i)
			setVRAM(addr + i, pattern2 ^ 0x800)
			setVRAM(addr + 0x3e - i, pattern1 ^ 0x800)
		}
	}

	// Write vertical scroll offsets to VSRAM
	VDP.setupVSRAMWrite(0)
	VDP.writeData16(0x4c)								// Foreground vertical scroll offset (Angel Island)
	VDP.writeData16(camera.background.y.u16 & 0xff)		// Background vertical scroll offset (sky & ocean)

	// Setup palette
	copyPaletteDataFromTable(0x03, 0xfc00)
	copyMemory(0xfffffc20, 0x05b16e, 0x20)

	// Choose palette. However, switching in the options menu does not update until menu reload even if this is moved to the while loop,
	// so for now we force the new palette from SSZ2.
//	if (palette_set < 2 && !original_mode)	// S3&K or ROM hack palettes
//	{
//		copyMemory(0xfffffc40, 0x0a97bc, 0x20)
//		copyMemory(0xfffffc60, 0x0a983c, 0x20)
//	}
//	else					// redesigned palettes
//	{
		u32[0xfffffc40] = 0x00000EEE
		u32[0xfffffc44] = 0x0AEE068E
		u32[0xfffffc48] = 0x066A0646
		u32[0xfffffc4c] = 0x06220424
		
		u32[0xfffffc50] = 0x0EE004C2
		u32[0xfffffc54] = 0x04820460
		u32[0xfffffc58] = 0x0408040C
		u32[0xfffffc5c] = 0x004206A0
		
		u32[0xfffffc60] = 0x00000CEE
		u32[0xfffffc64] = 0x0CCE0ACE
		u32[0xfffffc68] = 0x08CE0AAE
		u32[0xfffffc6c] = 0x0CAE0E8E	// changed second color from SSZ2 to fit ocean water (first color is sky as well as water effect)
		
		u32[0xfffffc70] = 0x0EEE0CEE
		u32[0xfffffc74] = 0x0C8C06C6	// changed first color from SSZ2 to fit ocean water
		u32[0xfffffc78] = u32[0xfffffc60] // changed from SSZ2 to fit ocean water
		u32[0xfffffc7c] = u32[0xfffffc64] // changed from SSZ2 to fit ocean water
//	}

	u32[0xffffa800] = 0x00738000		// Basically a timer for the animation; don't start at 0, that doesn't look all that nice

	while (true)
	{
		MainMenuBG.Update(cameraForegroundX, cameraBackgroundX)

		PrintVersionNumber()

		yieldExecution()
		++level.framecounter
	}
}
#endif

function void MainMenuBG.Update(u16 cameraForegroundX, u16 cameraBackgroundX)
{
	Renderer.resetSprites()

	// Ocean palette effect
//		fn05928c()
	VDP.copyToCRAMbyDMA(0xfffffc00, 0x0000, 0x80)

	// Scrolling for water and clouds
	{
		camera.foreground.x.u16 = cameraForegroundX + MainMenuBG.scrollOffset
		u16[0xffffee98] = cameraBackgroundX + MainMenuBG.scrollOffset

		fn05b0a8()
		u32[0xffffa800] -= 0x0200	// Partially undo the scrolling progress, to make it slightly slower

		A4 = 0x05b15a
		A5 = 0xffffa804
		A1 = 0xffffe000		// Location of linewise scroll offsets
		D0.u16 = 0x0300		// camera.background.y.u16 - 0x0500
		D1.u16 = getScreenHeight() - 1
		D3.u16 = camera.foreground.x.u16
		fn04f0de()

		// Manual correction for two lines with broken scrolling (also in outro)
		u16[0xffffe0ee] = u16[0xffffe0f2]
		u16[0xffffe16e] = u16[0xffffe172]
		VDP.copyToVRAMbyDMA(0xffffe000, 0xf000, getScreenHeight() * 4)
	}

	Renderer.drawCustomSprite("sonic3air_logo", MainMenuBG.logoPosition, 11, 0, 0, 0xa000)
	if (palette_set >= 2)
		Renderer.drawCustomSprite("title_screen_air_new", MainMenuBG.logoPosition, 11 + 20, 0, 0, 0xa000)
	else
		Renderer.drawCustomSprite("title_screen_air", MainMenuBG.logoPosition, 11 + 20, 0, 0, 0xa000)
}




// We cut out exceptions to some settings for Extra Character Slot characters, as ECSU overwrites other
// functions DAGE would typically use for initialization.
// Function taken from maingame\hud\titlecard.lemon
//# address-hook(0x02d6a6) end(0x02d768)
function void TitleCard.Init()
{
	if (u8[0xffffe654])		// no Knuckles settings for Extra Character Slot characters
	{
		eggrobos_knuckles = 0
		specialstages_knuckles = 0
	}

	bool hudLoaded = true
	if (!System.loadPersistentData(0x840273, "DAGE_Theme", 1))	// load save theme if it exists,
	{
		theme.hud = theme.saturn								// else use the theme matching the menu
		hud.layout = 3											// with the classic layout
		hudLoaded = false
	}
//	else if (theme.hud > 0x3f)	// classic RINGS HUD digits position
//	{
		if (hudLoaded)
			hud.layout = (theme.hud >> 6)
		theme.hud &= 0x3f		// set HUD to matching theme constant
//	}

	if (System.getGlobalVariableValueByName("DAGE_characterName") || Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") || u8[0xffffe654])	// no HUD themes for Extra Character Slot characters
	{
		theme.hud &= 0xc0	// keep HUD layout but zero out HUD theme (theme.s3k = 0)
	}

	if (time_attack == 1 || time_attack == 2)
	{
		if (time_attack_hud.layout > 2)		// leftover from when this was restart_threshold
			time_attack_hud.layout = 1
		hud.layout = time_attack_hud.layout
	}

	if (unlock_act == 2)
	{
		u32[0xffffb40c] = 0x020fd2	// create CPZ background pillar in a specific object slot	// created alongside water surface in Sonic 2
		CPZ.loadYellowPlatforms()
	}

	base.TitleCard.Init()
}





// In Original Mode, do not implement some AIR fixes for attracted rings.
// Functions taken from objects\basics\ring.lemon
//# address-hook(0x01a938) end(0x01a98c)
function void DynamicRing.UpdateAttraction()
{
	s16 dx = u16[0xffffb000 + 0x10] - objA0.position.x.u16
	if (dx < 0)
	{
		D1.s16 = -0x30
		if (objA0.velocity.x >= 0)
		{
			D1.u16 *= 4
		}
	}
	else
	{
		D1.s16 = 0x30
		if (objA0.velocity.x < 0)
		{
			D1.u16 *= 4
		}
	}
	objA0.velocity.x += D1.s16

	s16 dy = u16[0xffffb000 + 0x14] - objA0.position.y.u16
	#if STANDALONE
		// Consider level wrap for ring collection
		if (level.vertical_wrap == 0xff00 && !original_mode)
		{
			if (dy > s16(level.height.bitmask) / 2)
			{
				objA0.position.y.u16 += level.height.bitmask
			}
			else if (dy < -s16(level.height.bitmask) / 2)
			{
				objA0.position.y.u16 -= level.height.bitmask
			}
			dy = u16[0xffffb000 + 0x14] - objA0.position.y.u16
		}
	#endif
	if (dy < 0)
	{
		D1.s16 = -0x30
		if (objA0.velocity.y >= 0)
		{
			D1.s16 *= 4
		}
	}
	else
	{
		D1.s16 = 0x30
		if (objA0.velocity.y < 0)
		{
			D1.s16 *= 4
		}
	}
	objA0.velocity.y += D1.s16

	UpdateMovementStraightSimple()
}

//# address-hook(0x01a67a) end(0x01a6ac)
function void fn01a67a()
{
	D6 = global.inv_gravity ? 0x01a662 : 0x01a64a
	// Standalone uses a higher limit for number of spilled rings on screen at once
	u16 maxRings = (original_mode) ? 32 : 48

	A1 = A0
	D5 = (u8[A0 + 0x3f] == 0) ? ring_counter : ring_counter.player2
	D5.u16 = min(D5.u16, maxRings) - 1
	D4.u16 = 0x288
	SpillRings()
}


// Have rings check for collision against all manner of terrain every frame
// instead of only against floors every eighth frame.
// Functions taken from objects\basics\ring.lemon
//# address-hook(0x01a75c) end(0x01a7be)
function void fn01a75c()
{
	objA0.animation.sprite = spilled_rings.animframe
	UpdateMovementStraightSimple()
	objA0.velocity.y += 0x18
	if (objA0.velocity.y >= 0)
	{
		D0.u8 = (global.framecounter + D7.u8) & 0x07	// in original mode, only 1/8th of spilled rings check for floor collision each frame
		if (D0.u8 == 0 || !original_mode)
		{
			if (objA0.render_flags & render_flag.VISIBLE)
			{
				if (original_mode || objA0.velocity.y > 0)
				{
					fn00f994()
					if (D1.s16 < 0)
					{
						objA0.position.y.u16 += D1.u16
						objA0.velocity.y = (objA0.velocity.y >> 2) - objA0.velocity.y
					}
				}
			}

			if (original_mode && ((spilled_rings.speed == 0) || (objA0.position.y.u16 > move_area.bottom.current + getScreenHeight())))
			{
				// Time over for this ring, or it fell out of the lower level bounds
				UnloadObject()
				return
			}
		}
	}
	if (!original_mode)
	{
		if (objA0.velocity.y < 0)
		{
			fn00f994()
			if (D1.s16 < 0)
			{
				objA0.position.y.u16 -= D1.s16
				objA0.velocity.y = -objA0.velocity.y
			}
		}
		if (objA0.velocity.x < 0)
		{
			CheckHitboxCollisionLeft()
			if (D1.s16 < 0)
			{
				objA0.position.x.u16 += D1.u16
				objA0.velocity.x = -objA0.velocity.x
			}
		}
		else if (objA0.velocity.x > 0)
		{
			CheckHitboxCollisionRight()
			if (D1.s16 < 0)
			{
				objA0.position.x.u16 -= D1.u16
				objA0.velocity.x = -objA0.velocity.x
			}
		}
		if ((spilled_rings.speed == 0) || objA0.position.y.u16 > move_area.bottom.current + getScreenHeight())
		{
			UnloadObject()
			return
		}
	}

	AddAsDynamicObject()
	objA0.position.x.u16 -= u16[0xffffeebc]
	DrawObject()
}

//# address-hook(0x01a7e8) end(0x01a84a)
function void fn01a7e8()
{
	objA0.animation.sprite = spilled_rings.animframe
	UpdateMovementStraightSimple()
	objA0.velocity.y += 0x18
	if (objA0.velocity.y >= 0)
	{
		D0.u8 = (global.framecounter + D7.u8) & 0x07	// in original mode, only 1/8th of spilled rings check for floor collision each frame
		if (D0.u8 == 0 || !original_mode)
		{
			if (objA0.render_flags & render_flag.VISIBLE)
			{
				if (original_mode || objA0.velocity.y > 0)
				{
					fn00fca0()
					if (D1.s16 < 0)
					{
						objA0.position.y.u16 -= D1.u16
						objA0.velocity.y = (objA0.velocity.y >> 2) - objA0.velocity.y
					}
				}
			}

			if (original_mode && ((spilled_rings.speed == 0) || (objA0.position.y.u16 > move_area.bottom.current + getScreenHeight())))
			{
				// Time over for this ring, or it fell out of the lower level bounds
				UnloadObject()
				return
			}
		}
	}
	if (!original_mode)
	{
		if (objA0.velocity.y < 0)
		{
			fn00fca0()
			if (D1.s16 < 0)
			{
				objA0.position.y.u16 -= D1.s16
				objA0.velocity.y = -objA0.velocity.y
			}
		}
		if (objA0.velocity.x < 0)
		{
			CheckHitboxCollisionLeft()
			if (D1.s16 < 0)
			{
				objA0.position.x.u16 += D1.u16
				objA0.velocity.x = -objA0.velocity.x
			}
		}
		else if (objA0.velocity.x > 0)
		{
			CheckHitboxCollisionRight()
			if (D1.s16 < 0)
			{
				objA0.position.x.u16 -= D1.u16
				objA0.velocity.x = -objA0.velocity.x
			}
		}
		if ((spilled_rings.speed == 0) || objA0.position.y.u16 > move_area.bottom.current + getScreenHeight())
		{
			UnloadObject()
			return
		}
	}

	AddAsDynamicObject()
	objA0.position.x.u16 -= u16[0xffffeebc]
	DrawObject()
}






// Allow passing over ceilings in Original Mode.
// Also support the Sonic 2 angle and height map arrays when needed.
// Functions taken from maingame\collision.lemon
function u16 getTileAndAngle()
{
	// Inputs:
	//  - A4 = address of sensor to write result (angle) to -- e.g. 0xfffff768 or 0xfffff76a
	//  - A5 = algorithm for getting tile address -- usually 0x00eff0
	//  - D2.u16 = input.y
	//  - D3.u16 = input.x
	//  - D5.u8  = layer bit to check -- values between 0x0c and 0x0f
	//  - D6.u16 = xor bitmask for flipping

#if STANDALONE
	// Outside the upper border, use topmost valid level collision
	if (Game.getSetting(SETTING_FIX_GLITCHES) && level.vertical_wrap != 0xff00 && !original_mode)
	{
		D2.s16 = max(D2.s16, 0)
	}
#endif

	// Output:
	//  - u8[A4] = sensor value, angle of tile
	//  - D1.s16 = signed indent of collision inside the hit tile at input position

	// Meanings of layer bits:
	//  - 0x0c = Path 1 solid from above
	//  - 0x0d = Path 1 solid from other sides
	//  - 0x0e = Path 2 solid from above
	//  - 0x0f = Path 2 solid from other sides
	u8 layer_bit = D5.u8

	call A5		// This usually calls "fn00eff0()"

	// Tile:
	//  - Lower bits: tile type
	//  - Bit 0x0400 = flip horizontally
	//  - Bit 0x0800 = flip vertically
	//  - Higher bits: layers
	u16 tile = u16[A1]
	u16 tileType = tile & 0x03ff

	if (tileType != 0 && (tile >> layer_bit) & 1)
	{
		A2 = u32[0xfffff796]
		u8 tileForm = u8[A2 + tileType * 2]
		if (tileForm != 0)
		{
			u32 angleArray = (unlock_act) ? 0x854000 : 0x096000
			u8 angle = u8[angleArray + tileForm]
			if (tile & 0x0400)	// Flip horizontally
			{
				angle = -angle
			}
			if (tile & 0x0800)	// Flip vertically
			{
				angle = 0x80 - angle
			}
			u8[A4] = angle

			return tile
		}
	}
	return 0
}

function s16 getCollisionIndentX()
{
	u16 tile = getTileAndAngle()
	if (tile != 0)
	{
		u16 input.y = D2.u16
		u8 tileForm = u8[A2 + (tile & 0x3ff) * 2]

		u16 iy = input.y & 0x0f
		if (tile & 0x0800)	// Flip vertically
		{
			iy = 15 - iy
		}

		u32 xArray = (unlock_act) ? 0x855100 : 0x097100
		s16 indent = s8[xArray + (tileForm * 0x10) + iy]
		if (indent != 0)
		{
			tile ^= D6.u16
			if (tile & 0x0400)	// Flip horizontally
			{
				indent = -indent
			}
			return indent
		}
	}
	return 0
}

function s16 getCollisionIndentY()
{
	u16 tile = getTileAndAngle()
	if (tile != 0)
	{
		u16 input.x = D3.u16
		u8 tileForm = u8[A2 + (tile & 0x3ff) * 2]

		u16 ix = input.x & 0x0f
		if (tile & 0x0400)	// Flip horizontally
		{
			ix = 15 - ix
		}

		u32 yArray = (unlock_act) ? 0x854100 : 0x096100
		s16 indent = s8[yArray + (tileForm * 0x10) + ix]
		if (indent != 0)
		{
			tile ^= D6.u16
			if (tile & 0x0800)	// Flip vertically
			{
				indent = -indent
			}
			return indent
		}
	}
	return 0
}


// Load collision as rawdata.
// Function taken from maingame\maingame.lemon
//# address-hook(0x0076a6) end(0x0076e4)
function void fn0076a6()
{
	System.loadExternalRawData("s2angles", s2_angles_address)
	System.loadExternalRawData("s2heightmaps", s2_heightmaps_address)
	System.loadExternalRawData("s2heightmapsrotated", s2_heightmapsrotated_address)
	if (unlock_act)
	{
		D0 = 0x0df370	// location of S2&K object position pointers and data
		if (unlock_act == 1)
			System.loadExternalRawData("ehz_collision", D0)
		else if (unlock_act == 2)
			System.loadExternalRawData("cpz_collision", D0)
	}
	else
	{
		A1 = 0x098100 + global.zone * 8 + global.act * 4
		D0 = u32[A1]
	}

	u32[0xfffff7b4] = D0

	D0 += (D0 >= 0x260000) ? 0x600 : 1
	u32[0xfffff7b8] = D0
	u32[0xfffff796] = u32[0xfffff7b4]
}


// Chaos the Impostor completely overwrites DAGE's start position checks with no easy way around it.
// This function will get called before initializeMainGame() finishes, so we use it to make a last-minute correction for unlockable acts.
// Function taken from maingame\maingame.lemon
//# address-hook(0x01cacc) end(0x01cad6)
function void fn01cacc()
{
	base.fn01cacc()

	if (Mods.isModActive("Chaos The Impostor") && unlock_act && (checkpoint.number & 0x7f) == 0)
	{
		D1 = UnlockAct_StartPositionsKnuckles[(unlock_act - 1) * 2]
		D0 = UnlockAct_StartPositionsKnuckles[(unlock_act - 1) * 2 + 1]
		u16[0xffffb010] = D1.u16
		u16[0xffffb014] = D0.u16
		u16[0xffffb01a] = 0
		u8[0xffffb020] = char.state.STANDING
		u8[0xffffb02a] = 0
		level.start_location = 0

		if (unlock_act == 2)
		{
			layout.part = 0
			camera.position.x.u16 = 0x0000
			camera.foreground.x.u16 = 0x0000
			camera.position.y.u16 = 0x018c
			camera.foreground.y.u16 = 0x018c
		}
	}
	if (Mods.isModActive("Chaos The Impostor") && unlock_act)
		call 0x007893		// initialize water
}


// Load tiles as rawdata into shared memory and then decompress instead of using a ROM injection.
// Also ensure Sonic 2 tiles and PLCs are loaded properly.
// Function taken from maingame\maingame.lemon
//# address-hook(0x007812) end(0x007890)
function void fn007812()
{
	A4 = MainGame.getLevelDataPointer()
	A1 = u32[A4] & 0x00ffffff
//	u32 backupA1 = A1
	if (unlock_act)
	{
		if (unlock_act == 1)
			System.loadExternalRawData("ehz_tiles", s2_decompression_buffer)		// copy Primary tiles to shared memory
		else if (unlock_act == 2)
			System.loadExternalRawData("cpz_tiles", s2_decompression_buffer)		// copy Primary tiles to shared memory
		A1 = s2_decompression_buffer
	}
	else if (global.zone == 0x04)
	{
		u64 key  = (original_mode) ? "fbz_tiles_p_orig" : "fbz_tiles_p"
		System.loadExternalRawData(key, s2_decompression_buffer)		// copy Primary tiles to shared memory
		A1 = s2_decompression_buffer
	}
//	A1 = backupA1
	u32 firstSource = A1
	D4.u16 = u16[A1]

	Kosinski.addToDMAQueue(A1, 0x0000)

	A1 = u32[A4+4] & 0x00ffffff
	if (A1 != firstSource && global.zone != 0x04 && !unlock_act)	// FBZ loads all tiles at once in the above setup
	{
		Kosinski.addToDMAQueue(A1, D4.u16)
	}

	while (true)
	{
		global.frame_state = 0x0c
		Kosinski.ProcessDecompressionQueue()
		waitForNextFrame()

		LoadRequiredSpritePatterns()
		Kosinski.ProcessModules()
		if (kosinski.waiting_modules == 0)
			break
	}
}


// Load chunks as rawdata into shared memory and then decompress instead of using a ROM injection.
// This allows for using data bigger than what fits into the usual spots in ROM.
// Function taken from maingame\maingame.lemon
//# address-hook(0x01c2b0) end(0x01c360)
function void fn01c2b0()
{
	if (!global.stage_type)
		S2TitleCard.disappear = true	// once the chunks are loaded, the level is about to start

	// This is not the only location that level data gets loaded!
	// Act 2 chunks, blocks, and tiles are loaded in act transition functions.
	// function void fn04fc46(): main.lemon, AIZ1 to AIZ2 transition behind fire wall
	// function void fn050bce(): main.lemon, HCZ1 to HCZ2 transition at Act 1 end
	// function void fn051160(): main.lemon, MGZ1 to MGZ2 transition at Act 1 end
	// functions void fn0517d6() and fn0517ea(): not in DAGE yet (level_mgz.lemon), loads MGZ Quake chunks
	// Nothing for CNZ (chunks do not differ between acts)
	// function void fn05382c(): main.lemon, ICZ1 to ICZ2 transition within tunnel
	// function void fn054200(): main.lemon, LBZ1 to LBZ2 transition at Act 1 end
	// Nothing for MHZ act transition (chunks do not differ between acts), but...
	// function void fn055250(): main.lemon, MHZ2 boss area chunks (still using rominjection)
	// Nothing for FBZ (chunks do not differ between acts)
	// Nothing for SOZ (chunks do not differ between acts)
	// function void fn056bd2(): main.lemon, LRZ1 to LRZ2 transition at Act 1 end
	// function void fn02df64(): blue_spheres.lemon, Hidden Palace after Super Emerald stage results
	// function void fn05adc0(): main.lemon, outro use of SSZ2 data
	// Nothing for DEZ (chunks do not differ between acts)
	// Nothing for DDZ/DEZ2 boss (no hidden transitions that reload chunks)
	// These other functions MUST be adjusted for any changes to external level data!

	A2 = MainGame.getLevelDataPointer()
	// A2 now points to the level's position in the LevelLoadBlock, and D0 will hold addresses from the block.
	// Address pointers starting from A2:
	// A2+ 0:	Address of Primary tiles (8x8s) plus a byte to first PLC at the start of the address
	// A2+ 4:	Address of Secondary tiles (8x8s) plus a byte to second PLC at the start of the address
	// A2+ 8:	Address of Primary blocks (16x16s) plus a byte to palette at the start of the address
	// A2+12:	Address of Secondary blocks (16x16s) plus a byte to (unused) palette at the start of the address
	// A2+16:	Address of Primary chunks (128x128s)
	// A2+20:	Address of Secondary chunks (128x128s)
	// All addresses point to Kosinski-compressed data. The leading bytes are removed here by AND logic.

	u64 key

	// Load Primary blocks
	D0 = u32[A2+8] & 0x00ffffff
	D7 = D0
	if (unlock_act)
	{
		if (unlock_act == 1)
			System.loadExternalRawData("ehz_blocks", KosinskiRawdataBuffer)		// copy Primary blocks to shared memory
		else if (unlock_act == 2)
			System.loadExternalRawData("cpz_blocks", KosinskiRawdataBuffer)		// copy Primary blocks to shared memory
		Kosinski.decompress(KosinskiRawdataBuffer, 0xffff9000)				// decompress them to their proper RAM
	}
	else
	{
		Kosinski.decompress(D0, 0xffff9000)
	}

	// Load Secondary blocks
	if (!unlock_act)
	{
		D0 = u32[A2+12] & 0x00ffffff
		if (D7 != D0)
		{
			Kosinski.decompress(D0, A1)
		}
	}

	// Load Primary chunks
	D0 = u32[A2+16] & 0x00ffffff
	D7 = D0
	A1 = 0xffff0000
	key = stringformat("%s_chunks_p", getZoneInitials(global.zone))
	if (unlock_act)
	{
		if (unlock_act == 1)
			System.loadExternalRawData("ehz_chunks_p", KosinskiRawdataBuffer)		// copy Primary chunks to shared memory
		else if (unlock_act == 2)
			System.loadExternalRawData("cpz_chunks_p", KosinskiRawdataBuffer)		// copy Primary chunks to shared memory
		Kosinski.decompress(KosinskiRawdataBuffer, A1)							// decompress them to their proper RAM
	}
	else if (global.zone_act == 0x0a00 && System.hasExternalRawData("ssz1_chunks_p"))					// SSZ uses Primary and Secondary in Act 1 and unique Primary only in Act 2
	{
		System.loadExternalRawData("ssz1_chunks_p", KosinskiRawdataBuffer)		// copy Primary chunks to shared memory
		Kosinski.decompress(KosinskiRawdataBuffer, A1)							// decompress them to their proper RAM
//		debugLog(stringformat("Primary chunks: ssz%d_chunks_p", global.act + 1))
	}
	else if (global.zone == 0x13 && System.hasExternalRawData("gumball_chunks_p"))	// get ultrawide chunks for Gumball stage
	{
		System.loadExternalRawData("gumball_chunks_p", KosinskiRawdataBuffer)	// copy Primary chunks to shared memory
		Kosinski.decompress(KosinskiRawdataBuffer, A1)							// decompress them to their proper RAM
	}
	else if (System.hasExternalRawData(key))				// only try to load Primary chunks if they exist for the act
	{
		System.loadExternalRawData(key, KosinskiRawdataBuffer)			// copy Primary chunks to shared memory
		Kosinski.decompress(KosinskiRawdataBuffer, A1)					// decompress them to their proper RAM
//		debugLog(stringformat("Primary chunks: %s", key))
	}
	else if (global.zone_act == 0x0a01 || global.zone >= 0x0c)	// load from ROM for SSZ2 or Doomsday + later zone IDs (LRZ3 and HPZ are already covered above)
	{
		Kosinski.decompress(D0, 0xffff0000)
//		debugLog("Primary chunks: ROM")	
	}

	// Load Secondary chunks
	// A1 = address where the Primary chunk decompression ended (if there were no Primary chunks, then A1 = 0xffff0000)
	// D7 = address where the Primary chunks were stored compressed in ROM
	if (!unlock_act)
	{
		D0 = u32[A2+20] & 0x00ffffff
		key = stringformat("%s_chunks_s", getZoneActInitials(global.zone_act))
		if (global.zone_act == 0x0100 && original_mode && System.hasExternalRawData("hcz1_chunks_s_orig"))	// undo HCZ1 background chunk fixes in Original Mode
		{
			System.loadExternalRawData("hcz1_chunks_s_orig", KosinskiRawdataBuffer)		// copy Primary chunks to shared memory
			Kosinski.decompress(KosinskiRawdataBuffer, A1)								// decompress them to their proper RAM		
		}
		else if (System.hasExternalRawData(key))		// only try to load Secondary chunks if they exist for the act
		{
			System.loadExternalRawData(key, KosinskiRawdataBuffer)			// copy Secondary chunks to shared memory
			Kosinski.decompress(KosinskiRawdataBuffer, A1)					// decompress them to their proper RAM
	//		debugLog(stringformat("Secondary chunks: %s", key))
		}
		else	// load from ROM
		{
			if (D7 != D0)
			{
				Kosinski.decompress(D0, A1)
	//			debugLog("Secondary chunks: ROM")	
			}
		}
	}

	// Load level layout
	fn01c362()

	// Load tiles
	D1.u8 = u8[A2]
	D0 = u8[A2+4]
	if (D0.u8 != 0 && D1.u8 != D0.u8)
	{
		requestLoadingPatterns(D0.u8)
	}

	// Load level palette
	Level.loadNonfadingPaletteData(u8[A2+8])

#if STANDALONE
	//// Copy 16 palette entries from 0x10 to 0x90, primarily for the rings
	//// TODO: Here is not a good place to do this, as
	////  - 1.) the primary palette has to be updated when fully underwater
	////  - 2.) fading effects won't work this way
	//for (u8 i = 0; i < 0x10; ++i)
	//{
	//	Renderer.setPaletteEntryPacked(0x90 + i, u16[0xfffffca0 + i * 2])
	//	Renderer.setSecondaryPaletteEntryPacked(0x90 + i, u16[0xfffff020 + i * 2])
	//}
#endif
}




// Disable A.I.R.'s custom widescreen fix for the gumball machine, as it doesn't cover ultrawide
// NOTE: AIR is implementing its own ultrawide fix in the version after v24.02.02.00 via https://github.com/Eukaryot/sonic3air/commit/69e80315752b3ad24fe8b9824a7d16aed448f460 , so check it again at that time!
// Function taken from level\bonus_gm\level_gumballmachine.lemon
//# address-hook(0x23efa2) end(0x23efb2)
function void UpdateLevelTiles.BonusGM()
{
	camera.foreground.x.u16 = 0x60 - getScreenExtend()

	fn23efb6()

	A4 = 0x23efe6
	A5 = 0xffffa800
	D6 = 0x0f
	D5 = 3
	fn239d1e()
/*
#if STANDALONE
	// Copy some foreground tiles to fill in the outer columns
	// TODO: This is quite hacked in, better do this in the right way
	for (u16 base = 0xc000; base < 0xd000; base += 0x80)
	{
		setVRAM(base + 0x0c, getVRAM(base + 0x5c))
		setVRAM(base + 0x0e, getVRAM(base + 0x5e))
		setVRAM(base + 0x70, getVRAM(base + 0x20))
		setVRAM(base + 0x72, getVRAM(base + 0x22))
	}
#endif
*/
}




// In some levels, do not use the VScrollBuffer and use the standard one with the fallback repeat code.
// Without this, loading SSZ1 and then going to SSZ2 without AIR menu in between causes issues rendering Angel Island.
// The AIZ1 fire wall can also show issues, among other things.
// Function taken from general\update_general.lemon
// //# address-hook(0x04e838) end(0x04e84c)
/*
function void fn04e838()
{
#if STANDALONE

	bool useCustomVScrollBuffer = (u8[0x818080] != 0 && global.zone_act != 0x0a01 && global.zone_act != 0x0600 && global.zone != 0x00 && global.zone_act != 0x1600)
	u32 vscrollBufferAddress = (useCustomVScrollBuffer) ? 0x818000 : 0xffffeeea
	u16 rows = (useCustomVScrollBuffer) ? 32 : 20

	// Write vertical scroll data
	VDP.setupVSRAMWrite(0)
	u8 row = 0
	for (; row < rows; ++row)
	{
		VDP.writeData32(u32[vscrollBufferAddress + row * 4])
	}

	if (row * 0x10 < getScreenWidth())
	{
		// This is just a fallback in case there is no explicit definition of more than the first 20 vertical scrolling rows

		// Just repeat the last scroll offset for additional rows
		//  - AIZ 1 fire wall: Looks okay, but not optimal as the rightmost flames are all at the same y-position
		//  - LBZ 1 building collapse: Right part is fixed this way
		//  - LRZ 2 boss: No shift for the right part of the lava

		u32 value = (verticalScrollOffsetBias == 0) ? u32[0xffffeeea + 19 * 4] : u32[0xffffeeea]
		for (; row < 0x20; ++row)
		{
			VDP.writeData32(value)
		}
	}
	Renderer.setVerticalScrollOffsetBias(verticalScrollOffsetBias)

#else

	// Write vertical scroll data
	//  Note: 0xffffeeea is the start address of vertical scroll offsets
	VDP.setupVSRAMWrite(0)
	for (u8 row = 0; row < 20; ++row)
	{
		VDP.writeData32(u32[0xffffeeea + row * 4])
	}

#endif
}
*/



// Do not allow cutscene fast forwarding in Original Mode
// Functions taken from main_oxygen.lemon
function void Game.startSkippableCutscene()
{
	if (!original_mode)
	{
		fast_forward = true
		base.Game.startSkippableCutscene()
	}
}

function void Game.endSkippableCutscene()
{
	fast_forward = false
	base.Game.endSkippableCutscene()
}






// Support a second set of custom level layouts for Original Mode
// Function taken from maingame\maingame.lemon
//# address-hook(0x01c362) end(0x01c388)
function void fn01c362()
{
	// Load content of level chunks
	//  -> This includes both foreground and background chunks
	u8 offset = global.zone * 8 + global.act * 4
	A0 = u32[0x09d5c0 + offset]
	copyMemory(0xffff8000, A0, 0x1000)

	if (unlock_act)
	{
		if (unlock_act == 1)
			Standalone.loadRawLevelData("ehz_layout", global.zone_act, 0xffff8000)
		else if (unlock_act == 2)
		{
			bool KnuxHard = (layout.part == 2)
			if (layout.part == 0)
				Standalone.loadRawLevelData("cpz_layout_1", global.zone_act, 0xffff8000)
			else if (KnuxHard)
				Standalone.loadRawLevelData("cpz_layout_2_knux", global.zone_act, 0xffff8000)				
			else 
				Standalone.loadRawLevelData("cpz_layout_2", global.zone_act, 0xffff8000)
		}
	}
	else if (!original_mode)
		Standalone.loadRawLevelData("%s_layout", global.zone_act, 0xffff8000)
	else
	{
//		if (global.zone_act == 0x1701)	// HPZ emerald cave, which (like normal HPZ) is loading the base S3&K layout
//		{
//			u8[0xffff821d] = 0x7c		// make a correction to match the original ROM hack when seeing results after winning the far-left Super Emerald
//		}
		Standalone.loadRawLevelData("%s_origlayout", global.zone_act, 0xffff8000)
	}
}



// Support a second set of custom object positions for Original Mode
// Function taken from standalone\resources\level_objects\level_objects.lemon
function void LevelObjectTableBuilder.buildObjects()
{
	u32 originalA0 = A0
	A0 = 0x810000

	// Load objects from a custom binary file
	u32 bytes
	if (unlock_act)
	{
		if (unlock_act == 1)
			bytes = Standalone.loadRawLevelData("ehz_objects", global.zone_act, A0)
		else if (unlock_act == 2)
		{
			bool KnuxHard = (layout.part == 2)
			if (layout.part == 0)
				bytes = Standalone.loadRawLevelData("cpz_objects_1", global.zone_act, A0)
			else if (KnuxHard)
				bytes = Standalone.loadRawLevelData("cpz_objects_2_knux", global.zone_act, A0)
			else
				bytes = Standalone.loadRawLevelData("cpz_objects_2", global.zone_act, A0)
		}
	}
	else if (!original_mode)
		bytes = Standalone.loadRawLevelData("%s_objects", global.zone_act, A0)
	else
		bytes = Standalone.loadRawLevelData("%s_origobjects", global.zone_act, A0)
	bool loadedCustomData = (bytes != 0)

	if (!loadedCustomData)
	{
		// Load objects from hard-coded scripts
		if (global.zone_act == 0x0000)
		{
			LevelObjectTableBuilder.buildObjects_AIZ1()
		}
		else if (global.zone_act == 0x0001)
		{
			LevelObjectTableBuilder.buildObjects_AIZ2()
		}
		else if (global.zone_act == 0x0100)
		{
			LevelObjectTableBuilder.buildObjects_HCZ1()
		}
		else if (global.zone_act == 0x0101)
		{
			LevelObjectTableBuilder.buildObjects_HCZ2()
		}
		else if (global.zone_act == 0x0200)
		{
			LevelObjectTableBuilder.buildObjects_MGZ1()
		}
		else if (global.zone_act == 0x0201)
		{
			LevelObjectTableBuilder.buildObjects_MGZ2()
		}
		else if (global.zone_act == 0x0300)
		{
			LevelObjectTableBuilder.buildObjects_CNZ1()
		}
		else if (global.zone_act == 0x0301)
		{
			LevelObjectTableBuilder.buildObjects_CNZ2()
		}
		else if (global.zone_act == 0x0400)
		{
			LevelObjectTableBuilder.buildObjects_FBZ1()
		}
		else if (global.zone_act == 0x0401)
		{
			LevelObjectTableBuilder.buildObjects_FBZ2()
		}
		else if (global.zone_act == 0x0500)
		{
			LevelObjectTableBuilder.buildObjects_ICZ1()
		}
		else if (global.zone_act == 0x0501)
		{
			LevelObjectTableBuilder.buildObjects_ICZ2()
		}
		else if (global.zone_act == 0x0600)
		{
			LevelObjectTableBuilder.buildObjects_LBZ1()
		}
		else if (global.zone_act == 0x0601)
		{
			LevelObjectTableBuilder.buildObjects_LBZ2()
		}
		else if (global.zone_act == 0x0700)
		{
			LevelObjectTableBuilder.buildObjects_MHZ1()
		}
		else if (global.zone_act == 0x0701)
		{
			LevelObjectTableBuilder.buildObjects_MHZ2()
		}
		else if (global.zone_act == 0x0800)
		{
			LevelObjectTableBuilder.buildObjects_SOZ1()
		}
		else if (global.zone_act == 0x0801)
		{
			LevelObjectTableBuilder.buildObjects_SOZ2()
		}
		else if (global.zone_act == 0x0900)
		{
			LevelObjectTableBuilder.buildObjects_LRZ1()
		}
		else if (global.zone_act == 0x0901)
		{
			LevelObjectTableBuilder.buildObjects_LRZ2()
		}
		else if (global.zone_act == 0x0a00)
		{
			LevelObjectTableBuilder.buildObjects_SSZ1()
		}
		else if (global.zone_act == 0x0a01)
		{
			LevelObjectTableBuilder.buildObjects_SSZ2()
		}
		else if (global.zone_act == 0x0b00)
		{
			LevelObjectTableBuilder.buildObjects_DEZ1()
		}
		else if (global.zone_act == 0x0b01)
		{
			LevelObjectTableBuilder.buildObjects_DEZ2()
		}
		else if (global.zone_act == 0x0c01)
		{
			LevelObjectTableBuilder.buildObjects_DDZ()
		}
		else if (global.zone_act == 0x1600)
		{
			LevelObjectTableBuilder.buildObjects_LRZ3()
		}
		else if (global.zone_act == 0x1601)
		{
			LevelObjectTableBuilder.buildObjects_HPZ1()
		}

	#if 0
		// Debug output
		if (A0 != 0x810000 && Game.getSetting(SETTING_LEVELLAYOUTS) == 2)
		{
			u32[A0] = 0
			A0 += 4
			debugDumpToFile(stringformat("level_objects_%04x.bin", global.zone_act), 0x810000, A0 - 0x810000)
		}
	#endif

		loadedCustomData = (A0 != 0x810000)
		A0 = 0x810000
	}

	if (!loadedCustomData)
	{
		// Use original objects in ROM
		A0 = originalA0
	}
}



// Support a second set of custom ring positions for Original Mode
// Function taken from standalone\resources\level_rings\level_rings.lemon
function void LevelRingsTableBuilder.buildRings()
{
	u32 originalA1 = A1
	A1 = 0x814000

	// Load rings from a custom binary file
	u32 bytes
	if (unlock_act)
	{
		if (unlock_act == 1)
			bytes = Standalone.loadRawLevelData("ehz_rings", global.zone_act, A1)
		else if (unlock_act == 2)
		{
			bool KnuxHard = (layout.part == 2)
			if (layout.part == 0)
				bytes = Standalone.loadRawLevelData("cpz_rings_1", global.zone_act, A1)
			else if (KnuxHard)
				bytes = Standalone.loadRawLevelData("cpz_rings_2_knux", global.zone_act, A1)
			else
				bytes = Standalone.loadRawLevelData("cpz_rings_2", global.zone_act, A1)
		}
	}
	else if (!original_mode)
		bytes = Standalone.loadRawLevelData("%s_rings", global.zone_act, A1)
	else
		bytes = Standalone.loadRawLevelData("%s_origrings", global.zone_act, A1)
	bool loadedCustomData = (bytes != 0)

	if (!loadedCustomData)
	{
		// Load rings from hard-coded scripts
		if (global.zone_act == 0x0000)
		{
			LevelRingsTableBuilder.buildRings_AIZ1()
		}
		else if (global.zone_act == 0x0001)
		{
			LevelRingsTableBuilder.buildRings_AIZ2()
		}
		else if (global.zone_act == 0x0100)
		{
			LevelRingsTableBuilder.buildRings_HCZ1()
		}
		else if (global.zone_act == 0x0101)
		{
			LevelRingsTableBuilder.buildRings_HCZ2()
		}
		else if (global.zone_act == 0x0200)
		{
			LevelRingsTableBuilder.buildRings_MGZ1()
		}
		else if (global.zone_act == 0x0201)
		{
			LevelRingsTableBuilder.buildRings_MGZ2()
		}
		else if (global.zone_act == 0x0300)
		{
			LevelRingsTableBuilder.buildRings_CNZ1()
		}
		else if (global.zone_act == 0x0301)
		{
			LevelRingsTableBuilder.buildRings_CNZ2()
		}
		else if (global.zone_act == 0x0400)
		{
			LevelRingsTableBuilder.buildRings_FBZ1()
		}
		else if (global.zone_act == 0x0401)
		{
			LevelRingsTableBuilder.buildRings_FBZ2()
		}
		else if (global.zone_act == 0x0500)
		{
			LevelRingsTableBuilder.buildRings_ICZ1()
		}
		else if (global.zone_act == 0x0501)
		{
			LevelRingsTableBuilder.buildRings_ICZ2()
		}
		else if (global.zone_act == 0x0600)
		{
			LevelRingsTableBuilder.buildRings_LBZ1()
		}
		else if (global.zone_act == 0x0601)
		{
			LevelRingsTableBuilder.buildRings_LBZ2()
		}
		else if (global.zone_act == 0x0700)
		{
			LevelRingsTableBuilder.buildRings_MHZ1()
		}
		else if (global.zone_act == 0x0701)
		{
			LevelRingsTableBuilder.buildRings_MHZ2()
		}
		else if (global.zone_act == 0x0800)
		{
			LevelRingsTableBuilder.buildRings_SOZ1()
		}
		else if (global.zone_act == 0x0801)
		{
			LevelRingsTableBuilder.buildRings_SOZ2()
		}
		else if (global.zone_act == 0x0900)
		{
			LevelRingsTableBuilder.buildRings_LRZ1()
		}
		else if (global.zone_act == 0x0901)
		{
			LevelRingsTableBuilder.buildRings_LRZ2()
		}
		else if (global.zone_act == 0x0a00)
		{
			LevelRingsTableBuilder.buildRings_SSZ1()
		}
		else if (global.zone_act == 0x0a01)
		{
			LevelRingsTableBuilder.buildRings_SSZ2()
		}
		else if (global.zone_act == 0x0b00)
		{
			LevelRingsTableBuilder.buildRings_DEZ1()
		}
		else if (global.zone_act == 0x0b01)
		{
			LevelRingsTableBuilder.buildRings_DEZ2()
		}
		else if (global.zone_act == 0x1600)
		{
			LevelRingsTableBuilder.buildRings_LRZ3()
		}
		else if (global.zone_act == 0x1601)
		{
			LevelRingsTableBuilder.buildRings_HPZ1()
		}

		loadedCustomData = (A1 != 0x814000)
		A1 = 0x814000
	}

	if (!loadedCustomData)
	{
		// Use original rings in ROM
		A1 = originalA1
	}
}




// In Original Mode, do not implement a collision fix for running on the ceiling and getting crushed by objects.
// Function taken from objects\shared.lemon
function void fn01e006()
{
	if (u8[A1 + 0x05] >= 0x06 || debug_mode.state != 0)
	{
		D4 = 0
		return
	}

	// D0.u16 is the character's x-offset relative to the object's collision box (left border)
	// D1.u16 is the object collision box half width
	D5.u16 = D0.u16
	if (D0.u16 > D1.u16)
	{
		D0.u16 -= D1.u16 * 2
		D5.s16 = -D0.s16
	}

	// D3.u16 is the character's y-offset relative to the object's collision box (top border)
	// D2.u16 is the object collision box half height, I guess... but it seems to change whether the character is rolled or not
	D1.u16 = D3.u16
	if (D3.u16 > D2.u16)
	{
		D3.u16 -= D4.u16 + 4
		D1.s16 = -D3.s16
	}

	if (D1.u16 >= D5.u16 && D1.u16 > 4)
	{
		// Blocked by the object
		fn01e042()
	}
	else if (D3.s16 >= 0)
	{
		if (D3.u16 < 0x10)
		{
		// 0x01e154:
			D3.u16 -= 4
			D2.u16 = objA0.box_size.x * 2
			D1.s16 = objA1.position.x.u16 - objA0.position.x.u16 + objA0.box_size.x
			if (D1.s16 >= 0 && D1.u16 < D2.u16)
			{
				if (global.inv_gravity)
				{
					D3.s16 = -D3.s16
					++objA1.position.y.u16
				}
				else
				{
					--objA1.position.y.u16
				}

				objA1.position.y.u16 -= D3.u16
				if (objA1.velocity.y >= 0)
				{
					LetSonicClimbOnObject()
					D6 |= (u32(1) << (D6.u16 + 17))
					D4 = 0xffffffff
					return
				}
			}
			D4 = 0
		}
		else
		{
			fn01e0a2()
		}
	}
	else
	{
		if ((objA1.flags2a & char.flag.IN_AIR) == 0)
		{
			if (objA1.velocity.y == 0)
			{
				if (abs(D0.s16) < 0x10)
				{
					// Blocked by the object
					fn01e042()
				}
				else
				{
				#if STANDALONE
					// Fix ceiling run crush, e.g. occasional crush death by HCZ 2's first rotating pillar, fix #contributed by Elsie The Pict
					if (objA1.value26 != 0x80 || original_mode)
				#endif
					{
						// Getting crushed
						u32 backupA0 = A0
						A0 = A1
						Character.Die()
						A0 = backupA0

						D6 |= (u32(1) << (D6.u16 + 15))
						D4 = 0xfffffffe
					}
				}
				return
			}
			else
			{
				if (objA1.velocity.y > 0 || D3.s16 >= 0)
				{
					fn01e10e()
					return
				}
			}
		}
		else
		{
			u16[A1 + 0x1c] = 0
		}

		if (global.inv_gravity)
			D3.s16 = -D3.s16

		objA1.position.y.u16 -= D3.u16
		objA1.velocity.y = 0

		fn01e10e()
	}
}




// Disable AIR's new giant ring behaviors in Original Mode
// Functions taken from objects\basics\giantring.lemon
function bool GiantRing.isSuperEmeraldStage()
{
	if (!original_mode)
	{
		if (!isSonicAndKnucklesZone())
		{
			// Sonic 3 zones: It's a super emerald stage after Chaos Emeralds got traded in (this can only happen after completing the game)
			return (global.chaos_emeralds == 7 && global.traded_emeralds)
		}
		else
		{
			// Sonic & Knuckles zones: All 7 Chaos Emeralds needed, then all giant rings lead to HPZ -- also see "fn0616e6()"
			return (global.chaos_emeralds == 7)
		}
	}
	else
		return (global.lock_on_state == 0 && isSonicAndKnucklesZone() && global.chaos_emeralds == 7)
}

//# address-hook(0x06185c) end(0x06188c)
function void fn06185c()
{
	// Start fading to white
	if (!original_mode)
		playSound(0xaf)		//

	fn01bb7e()
	fn02d1cc()

	D0 = 0		// This is needed, don't ask why
	bool isSuperEmeraldStage = (objA0.subtype2c & 0x80) || GiantRing.isSuperEmeraldStage()
	if (isSuperEmeraldStage)
	{
		// Enter Hidden Palace, and then a Super Emeralds special stage
		fn0618ac()
	}
	else
	{
		// Enter a Chaos Emerald special stage
		fn061892()
	}
}






// In Original Mode, Tails can use up wall bouncepads in the Gumball Machine stage.
// Function taken from objects\bonus_gm\gm_bouncepad.lemon
//# address-hook(0x060f3e) end(0x060f8e)
function void fn060f3e()
{
	if (s16[0xffff2020] < 0)
	{
		D1 = 0x0d
		D2 = 0x08
		D3 = 0x11
		D4.u16 = objA0.position.x.u16
		fn01dc56()

		if ((D6 & 0x00010000) || (objA0.flags2a & object.flag.P1_ON_OBJECT))
		{
			A1 = 0xffffb000
			fn060f94()
			UnloadObject()
			return
		}

		if ((D6 & 0x00020000) || (objA0.flags2a & object.flag.P2_ON_OBJECT))
		{
			A1 = 0xffffb04a
			fn060f94()
		#if STANDALONE
			// AI controlled Tails shouldn't remove the bouncepad
			if (tails.control_counter == 0 || original_mode)
		#endif
			{
				UnloadObject()
				return
			}
		}
	}
	DrawObject()
}



// Run the original after images code in Original Mode.
// Functions taken from objects\effects\afterimages.lemon
//# address-hook(0x01a494) end(0x01a4ca)
function void AfterImages.Init()
{
	if (!original_mode)
	{
		// Effect is not used, we have our own after-images affect
		UnloadObject()
		return
	}

	objA0.mapping_offset = isMainCharacter(CHARACTER_KNUCKLES) ? 0x14a8d6 : 0x146816
	objA0.sprite_attributes = (Char.Player1.targetInVRAM >> 5)
	objA0.sprite_priority = 0x0100
	objA0.box_size.x = 0x18
	objA0.box_size.y = 0x18
	objA0.render_flags = render_flag.WORLD

	objA0.update_address = 0x01a4d0
	AfterImages.Update()
}

//# address-hook(0x01a4d0) end(0x01a516)
function void AfterImages.Update()
{
	if (super.active == 0)
	{
		UnloadObject()
		return
	}

	D0.u16 = posbackup.offset.player1
	D0.u8 -= (level.framecounter.low & 0x01) ? 0x14 : 0x0c
	A1 = 0xffffe500 + D0.s16
	objA0.position.x.u16 = u16[(A1+=2)-2]
	objA0.position.y.u16 = u16[(A1+=2)-2]
	A1 = 0xffffe400
	u8[A0 + 0x0a] = 6	// u8[A1 + D0.s16 + 0x03]	// original method seems to point to the wrong VRAM when hyper dashing
	objA0.animation.sprite = u8[0xffffb000 + 0x22]
	objA0.render_flags = u8[0xffffb000 + 0x04]
	objA0.sprite_priority = u16[0xffffb000 + 0x08]
	DrawObject()
}


// Use original palette rotation code in Classic Mode
// Function taken from maingame\character\character_palette.lemon
//# address-hook(0x003750) end(0x00398c)
function void UpdatePaletteEffects.SuperForm()
{
	// This function gets entered even if not in a Super or Hyper form
	//  -> If so, leave now again
	if (super.palettefx.state == 0)
		return

	// Palette effects depend on the character, and for Sonic on Hyper vs. Super form:
	//  - 0x00 = Hyper Sonic
	//  - 0x01 = Super Sonic
	//  - 0x02 = Super/Hyper Tails
	//  - 0x03 = Super/Hyper Knuckles
	//  - 0xff = Super Flickies (uses Super Sonic's effects)
	u8 characterVersion = isMainCharacter(CHARACTER_SONIC) ? ((super.active & 0x80) ? 0 : 1) : (getMainCharacter() + 1)

	// There's three variants of this function:
	//  - The original code -- with differentiation between standalone incl. extended palettes and real original
	//  - Smoothed palette effects when an anti-flicker setting is active
	//  - Variant for modded palettes

#if STANDALONE
	string characterKey = getCharacterPaletteKey(getMainCharacter())
	bool isNormalPaletteModded = System.hasExternalPaletteData(characterKey, 0)		// Check line index 0, for the normal form palette
	bool isSuperPaletteModded = System.hasExternalPaletteData(characterKey, 5)		// Check line index 5, for Super/Hyper form palette
	if (isSuperPaletteModded)
	{
		// Modded super palettes (possible using different super colors) need a special handling
		UpdatePaletteEffects.SuperForm.moddingVersion(characterVersion)
	}
	else if ((Game.getSetting(SETTING_GFX_ANTIFLICKER) != 0 || isNormalPaletteModded) && !original_mode)
	{
		// Smoothed version of effects -- also used when normal character palette is modded, but super palette is not
		UpdatePaletteEffects.SuperForm.smoothedVersion(characterVersion)
	}
	else
#endif
	{
		// Original version of effects -- does not support modded palettes
		UpdatePaletteEffects.SuperForm.originalVersion(characterVersion)
	}
}



// Do not allow certain AIR exceptions to Super Flicky aiming in Original Mode.
// Function taken from objects\effects\superflickies.lemon
//# address-hook(0x01a434) end(0x01a462)
function void fn01a434()
{
	if ((objA1.render_flags & render_flag.VISIBLE) && u8[A1 + 0x2d] == 0)
	{
	#if STANDALONE
		if (!original_mode)
		{
			// Exclude SOZ 1 boss
			if (objA1.update_address == 0x076f46)
				return

			// Exclude DEZ 2 boss and its robots
			if (objA1.update_address == 0x07f344 || objA1.update_address == 0x07f4fa)
				return

			// Exclude SOZ 2 sand cork
			if (objA1.update_address == 0x041d32)
				return

			// Exclude CNZ balloons
			if (objA1.update_address == 0x031754)
				return

			// Exclude CNZ bumpers
			if (objA1.update_address == 0x032e7e || objA1.update_address == 0x032eaa)
				return

			// Exclude checkpoint and its stars
			if (objA1.update_address == 0x02cfa8)
				return
		}
	#endif

		D0.u8 &= collision_attributes.flags
		if (D0.u8 == 0 || D0.u8 == collision.flag.SPECIAL)
		{
			u8[A1 + 0x2d] = 0xff		// Could this be a flag like "attacked by a flicky"?
			objA0.value42 = A1.u16
			u8[A0 + 0x30] = 1
			D1 = 1
			D6 = 2
		}
	}
}




function void releaseSpindash()
{
	// Release spindash!
	char.hitbox_extends.x = 7
	char.hitbox_extends.y = 14
	char.state = char.state.ROLLING
	char.flags |= char.flag.ROLLING
	char.spindash = 0

	u32 baseAddress
	s8 dy = 5
	if (char.character != CHARACTER_TAILS)
	{
		baseAddress = (super.active) ? 0x011d04 : 0x011cf2
	}
	else
	{
		baseAddress = (super.active.tails) ? 0x015320 : 0x01530e
		dy = 1
	}
	D0 = u16(char.spindash_charge >> 8) * 2
	char.groundspeed = s16[baseAddress + D0]

	char.position.y.u16 += (global.inv_gravity) ? -dy : dy

	D0.u16 = (char.groundspeed - 0x800) * 2
	D0.u16 = 0x2000 - (D0.u16 & 0x1f00)

	// Camera delay
	if (A0 == 0xffffb000)
	{
		if (!original_mode)
			ClearPositionBackup()	// Added for AIR's after images, but causes a one-frame graphics issue in Classic Mode after image rendering.
									// There is still a minor issue in that frame in which the after image is a few pixels too high, but this is a vanilla bug and fine here.

		camera.locktime.player1 = D0.u16
	}
	else
	{
		camera.locktime.player2 = D0.u16
	}

	if (char.flags & char.flag.FACING_LEFT)
	{
		char.groundspeed = -char.groundspeed
	}

	// Tell dust cloud object to disappear again
	u8[A6 + 0x20] = 0

	playSound(SFX_SPINDASH_RELEASE)
#if STANDALONE
	Input.setControllerRumbleByAddress(A0, 0.0f, 1.0f, 150)
#endif
}



function u32 UpdatePaletteEffects.SuperForm.getSuperSonicUnderwaterPalette()
{
	return ((original_mode && (global.zone == 0 || global.zone == 5)) || (!original_mode && (global.zone == 0 || global.zone == 1)))  ? 0x0039ca : 0x003a06
}


function void UpdatePaletteEffects.SuperForm.applyGeneral(u8 characterVersion, u32 source)
{
	base.UpdatePaletteEffects.SuperForm.applyGeneral(characterVersion, source)

	if (original_mode)
	{
		if (!isMainCharacter(CHARACTER_TAILS))
		{
			u8 character = clamp(characterVersion, 1, 3) - 1
			u32 primaryPalAddr = 0x802000 + character * 0x40
			copyMemory(0xfffffc00, primaryPalAddr, 0x20)
			if (level.water_present)
			{
				u32 secondaryPalAddr = 0x802300 + character * 0x40
				copyMemory(0xfffff080, secondaryPalAddr, 0x20)
			}
		}
		else
		{
			copyMemory(0xfffffc10, 0x802050, 0x08)
			if (level.water_present)
			{
				copyMemory(0xfffff090, 0x802350, 0x08)
			}
		}

	}
}



function void UpdatePaletteEffects.SuperForm.smoothedVersion(u8 characterVersion)
{
	if (original_mode)
		UpdatePaletteEffects.SuperForm.originalVersion(characterVersion)
	else
		base.UpdatePaletteEffects.SuperForm.smoothedVersion(characterVersion)
}

function void UpdatePaletteEffects.SuperForm.originalVersion(u8 characterVersion)
{
	if (!original_mode)
	{
		base.UpdatePaletteEffects.SuperForm.originalVersion(characterVersion)
		return
	}

	if (super.palettefx.state & 0x80)
	{
		// Update ongoing palette effect
		if (characterVersion == 0)
		{
			// Hyper Sonic
			--super.palettefx.timer
			if (super.palettefx.timer >= 0)
				return

			UpdatePaletteEffects.SuperForm.applyGeneral(characterVersion, 0x003a42)

			super.palettefx.timer = 4
			super.palettefx.frame += 6
			if (super.palettefx.frame >= 72)
				super.palettefx.frame = 0
		}
		else if (characterVersion == 1)
		{
			// Super Sonic
			UpdatePaletteEffects.UpdateSuperSonic.Original(characterVersion)
		}
		else if (characterVersion == 2)
		{
			// Super/Hyper Tails
			--super.palettefx.timer.tails
			if (super.palettefx.timer.tails < 0)
			{
				UpdatePaletteEffects.SuperForm.applyGeneral(characterVersion, 0x003a8a)

				super.palettefx.timer.tails = 0x0b
				super.palettefx.frame.tails = (super.palettefx.frame.tails + 6) % 36
			}

			// Also update Sonic's colors, for the flickies
//		#if STANDALONE
//			if (super.active.tails == 0xff)
//		#endif
				UpdatePaletteEffects.UpdateSuperSonic.Original(0xff)
		}
		else
		{
			// Super/Hyper Knuckles
			--super.palettefx.timer
			if (super.palettefx.timer >= 0)
				return

			UpdatePaletteEffects.SuperForm.applyGeneral(characterVersion, 0x003aae)

			super.palettefx.timer = 2
			super.palettefx.frame += 6
			if (super.palettefx.frame >= 60)
			{
				super.palettefx.frame = 0
				super.palettefx.timer = 0x0e
			}
		}
	}
	else if (super.palettefx.state == 1)
	{
		// Fade in effect
		--super.palettefx.timer
		if (super.palettefx.timer >= 0)
			return

		super.palettefx.timer = 1
		if (characterVersion <= 1)
		{
			// Sonic
			UpdatePaletteEffects.SuperForm.applyGeneral(1, 0x00398e)

			super.palettefx.frame += 6
			if (super.palettefx.frame < 36)
				return
		}
		else
		{
			// Tails / Knuckles
			//  -> They don't need an additional fade-in, as their palette animation is constantly fading in and out anyway
			super.palettefx.frame = 0
			super.palettefx.frame.tails = 0
		}

		super.palettefx.state = 0xff
		u8[0xffffb000 + 0x2e] = 0		// Reset "char.control_flags"
	}
	else  // (super.palettefx.state == 2)
	{
		// Fade out effect
		if (characterVersion <= 1)
		{
			// Sonic
			--super.palettefx.timer
			if (super.palettefx.timer >= 0)
				return

			UpdatePaletteEffects.SuperForm.applyGeneral(1, 0x00398e)

			super.palettefx.timer = 3
			super.palettefx.frame -= 6
			if (s16(super.palettefx.frame) < 0)
			{
//			#if STANDALONE
//				super.palettefx.frame = 0
//			#else
				u8[0xfffff65c] = 0		// Clear only upper byte of super.palettefx.frame (but why?)
//			#endif
				super.palettefx.state = 0
			}
		}
		else
		{
			// Tails / Knuckles: There is no fade-out, their colors instantly convert back to normal
			super.palettefx.frame = 0
			super.palettefx.state = 0
			super.palettefx.frame.tails = 0
			if (characterVersion == 2)
			{
				// Tails
//			#if STANDALONE
//				u32 offset = getMainCharacter() * 0x40
//				u16[0x802010 + offset] = u16[0x8021d0]
//				u16[0x802012 + offset] = u16[0x8021d2]
//				u16[0x802016 + offset] = u16[0x8021d6]
//				if (level.water_present)
//				{
//					u16[0x802310 + offset] = u16[0x8024d0]
//					u16[0x802312 + offset] = u16[0x8024d2]
//					u16[0x802316 + offset] = u16[0x8024d6]
//				}
//			#else
				UpdatePaletteEffects.SuperForm.applyGeneral(characterVersion, 0x003a8a)
//			#endif

				// Revert flickies colors
				UpdatePaletteEffects.SuperForm.applyGeneral(0xff, 0x00398e)
			}
			else
			{
				// Knuckles
//			#if STANDALONE
//				u32 offset = getMainCharacter() * 0x40
//				copyMemory(0x802004 + offset, 0x802204, 6)
//				if (level.water_present)
//					copyMemory(0x802304 + offset, 0x802504, 6)
//			#else
				UpdatePaletteEffects.SuperForm.applyGeneral(characterVersion, 0x003aea)
//			#endif
			}
		}
	}
}



// Do not allow smooth rotation and speedup after images in Original Mode.
// Also use Sonic Origins' drop dash animation.
// Function taken from standalone\rendering\render_character.lemon and updated to match AIR commit b29d9f1
function bool Standalone.drawCharacterSprite(u8 character, u8 variant, s16 px, s16 py, bool asSmallGhost)
{
	bool isPlayer1 = (variant == 0)
	u32 characterAddress = isPlayer1 ? 0xffffb000 : 0xffffb04a

	// Check only needed for Tails' tails
	if (variant == 2)
	{
		// No smooth rotation in Slot Machine
		if (global.zone == 0x15)
			return false

		characterAddress = 0xffff0000 + u16[A0 + 0x30]

		// Do not render when blinking after hit
		if (u8[characterAddress + 0x34] != 0 && ((u8[characterAddress + 0x34] + 1) & 0x04) == 0)
		{
			// Prevent emulator-like rendering
			return true
		}

		// Do not render when Tails looks into the background (e.g. LBZ 2 end cutscene) and in DEZ gravity transporters
		if (u8[characterAddress + 0x22] >= 0x55 && u8[characterAddress + 0x22] <= 0x5b)
		{
			// Prevent emulator-like rendering
			return true
		}

		isPlayer1 = (characterAddress == 0xffffb000)
		character = CHARACTER_TAILS
	}

	if (level.vertical_wrap == 0xff00)
	{
		// For vertically wrapping levels, "normalize" py into interval [-move_area.bottom.target * 3/4, -move_area.bottom.target * 1/4]
		py &= level.height.bitmask
		if (py > move_area.bottom.target * 3/4 && move_area.bottom.target >= 0xe0)	// move_area.bottom.target is very low in DEZ boss act
			py -= move_area.bottom.target
	}

	u8 animationSprite = char.animation.sprite
	u16 animationSpriteEx = Standalone.getModdedAnimationSpriteEx(character, animationSprite)
	u8 flags = (char.render_flags & (SPRITE_FLAG_FLIP_X | SPRITE_FLAG_FLIP_Y))
	u8 angle = 0
	u64 key = Standalone.getModdedAnimationSpriteKey(character, animationSpriteEx)		// First ask modded scripts
	u8 rotationMode = 0

	if (variant < 2)
	{
		if (character == CHARACTER_SONIC && animationSpriteEx == animationSprite)	// Last check is only false if modded scripts made their own changes
		{
			// Special handling for Drop Dash & Super Peel-Out
			if (char.state == char.state.SONIC_DROPDASH)
			{
				animationSpriteEx = CHAR_ANIMSPRITE_SONIC_DROPDASH + ((level.framecounter >> 1) & 0x01)
				if (originsDropDash)
					animationSpriteEx = CHAR_ANIMSPRITE_SONIC_DROPDASH + ((level.framecounter) & 0x0f)
			}
			else if (!super.active && animationSprite >= 0x21 && animationSprite <= 0x30)
			{
				if (sonic.fastrunanim.timer > 0)
				{
					animationSpriteEx = CHAR_ANIMSPRITE_SONIC_PEELOUT + (level.framecounter & 0x03)

					if (!Game.getSetting(SETTING_SMOOTH_ROTATION) && !original_mode)
					{
						angle = (animationSprite - 0x21) / 4 * 0xe0
						if ((char.flags & char.flag.FACING_LEFT) == (global.inv_gravity == 0))
							angle = -angle
						animationSprite = 0x21 + (animationSprite - 0x21) % 4
					}
				}
			}
		}

		if (Game.getSetting(SETTING_SMOOTH_ROTATION) && !original_mode)
		{
			// Character
			if (animationSprite >= 0x01 && animationSprite <= 0x20)
			{
				// Walking animation
				animationSprite = 0x01 + (animationSprite - 0x01) % 8
				rotationMode = 1
			}
			else if (animationSprite >= 0x21 && animationSprite <= 0x30)
			{
				// Running animation
				animationSprite = 0x21 + (animationSprite - 0x21) % 4
				rotationMode = 1
			}
			else if (animationSprite >= 0x78 && animationSprite <= 0x7f)
			{
				// Swinging animation
				animationSprite = 0x78
				rotationMode = 2
			}
			else if (character == CHARACTER_TAILS && animationSprite >= 0xc3 && animationSprite <= 0xca)
			{
				// Tails' fastest run animation
				animationSprite = 0xc3 + (animationSprite - 0xc3) % 2
				rotationMode = 1
			}
			else if (character == CHARACTER_KNUCKLES && animationSprite == 0xc0)
			{
				// Only for DDZ
				rotationMode = 1
			}

			if (rotationMode != 0)
			{
				bool useVanillaS3AIRRotation = true
				if (Game.getSetting(SETTING_SMOOTH_ROTATION) == 2)
				{
					useVanillaS3AIRRotation = (char.flags & char.flag.IN_AIR || global.zone == 0x0c)	// Use in-air rotation in DDZ
				}

				if (useVanillaS3AIRRotation)
				{
					s8 oldRotation = isPlayer1 ? oldRotationPlayer1 : oldRotationPlayer2
					flags = char.flags & char.flag.FACING_LEFT		// This really has to be "char.flags", not "char.render_flags"

					angle = char.rotation
					if (rotationMode == 1)
					{
						if (abs(s8(char.rotation)) <= 0x10 && abs(oldRotation) <= 0x10)
						{
							angle = 0
						}

						if (angle != char.rotation)
						{
							s8 diff = angle - oldRotation
							angle = oldRotation + clamp(diff, -3, 3)
						}
					}
				}
				else
				{
					// Mania-accurate rotation #contributed by Elsie The Pict
					u8 oldRotation = isPlayer1 ? oldRotationPlayer1 : oldRotationPlayer2
					flags = char.flags & char.flag.FACING_LEFT		// This really has to be "char.flags", not "char.render_flags"

					angle = char.rotation
					if (rotationMode == 1)
					{
						if (char.rotation <= 0x04 || char.rotation >= 0xfc)
						{
							oldRotation = 0
						}
						else
						{
							u32 targetRotation = 0
							if (char.rotation > 0x10 && char.rotation < 0xe8)
								targetRotation = char.rotation

							u32 rotate = targetRotation - oldRotation
							u32 shift = (abs(char.groundspeed) <= 0x6000) + 1

							if (abs(rotate) >= abs(rotate - 0x100))
							{
								if (abs(rotate - 0x200) < abs(rotate + 0x100))
									oldRotation += (rotate - 0x100) >> shift
								else
									oldRotation += (rotate + 0x100) >> shift
							}
							else
							{
								if (abs(rotate) < abs(rotate + 0x100))
									oldRotation += rotate >> shift
								else
									oldRotation += (rotate + 0x100) >> shift
							}
						}

						angle = oldRotation & 0xff
					}
				}
			}

			if (isPlayer1)
				oldRotationPlayer1 = angle
			else
				oldRotationPlayer2 = angle
		}

		if (key == 0 && animationSpriteEx >= 0x100)
		{
			// Special handling for Drop Dash & Super Peel-Out
			if (animationSpriteEx >= CHAR_ANIMSPRITE_SONIC_PEELOUT && char.state != char.state.SONIC_DROPDASH)
			{
				key = stringformat("sonic_peelout_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_PEELOUT)
			}
			else
			{
				key = stringformat("sonic_dropdash_%d", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_DROPDASH)
				if (originsDropDash)
					key = stringformat("sonic_origins_dropdash_%x", animationSpriteEx - CHAR_ANIMSPRITE_SONIC_DROPDASH)
			}
		}
		if (isPlayer1)
			timeattack.animSpriteEx = animationSpriteEx

		if (key == 0)
		{
			key = stringformat(stringformat("%s_0x%02x", getCharacterSpriteKey(character)), animationSprite)

			if (!Renderer.hasCustomSprite(key))
			{
				u32 sourceBase    = (character == CHARACTER_SONIC) ? ((animationSprite >= 0xda) ? 0x140060 : 0x100000) : (character == CHARACTER_TAILS) ? ((animationSprite >= 0xd1) ? 0x143d00 : 0x3200e0) : 0x1200e0
				u32 tableAddress  = (character == CHARACTER_SONIC) ? (super.active ? 0x148378 : 0x148182) : (character == CHARACTER_TAILS) ? 0x14a08a : 0x14bd0a
				u32 mappingOffset = (character == CHARACTER_SONIC) ? (super.active ? 0x146816 : 0x146620) : (character == CHARACTER_TAILS) ? 0x148eb8 : 0x14a8d6		// Not really necessary here, we could also use "char.mapping_offset"

				key = Renderer.setupCustomCharacterSprite(sourceBase, tableAddress, mappingOffset, animationSprite, 0x00)
			}
		}
	}
	else
	{
		if (Game.getSetting(SETTING_SMOOTH_ROTATION) && !original_mode)
		{
			// Tails' tails
			if (animationSprite >= 0x05 && animationSprite <= 0x14)
			{
				animationSprite = 0x05 + (animationSprite - 0x05) % 4
				angle = lookupAngleByVector(s16[characterAddress + 0x18], s16[characterAddress + 0x1a])

				flags = 0
				if (char.flags & char.flag.FACING_LEFT)
				{
					flags |= SPRITE_FLAG_FLIP_X
					angle += 0x80
				}
				if (global.inv_gravity)
				{
					flags ^= SPRITE_FLAG_FLIP_Y
					angle = -angle
				}
			}
		}

		key = stringformat(stringformat("%s_tails_0x%02x", getCharacterSpriteKey(CHARACTER_TAILS)), animationSprite)
		if (!Renderer.hasCustomSprite(key))
		{
			key = Renderer.setupCustomCharacterSprite(0x336620, 0x344d74, 0x344bb8, animationSprite, 0x00)
		}
	}

	u16 renderQueue = 0xa000 - char.sprite_priority
	u8 atex = (char.sprite_attributes >> 9) & 0x30
	if (EXTENDED_CHARACTER_PALETTES)
		atex = 0x40 + character * 0x20

	if (char.sprite_attributes & sprite_attribute.PRIORITY)
		flags |= SPRITE_FLAG_PRIO

	if (rotationMode != 0 && global.inv_gravity)
	{
		// Correction for inverse gravity
		angle = 128 - angle
		flags ^= SPRITE_FLAG_FLIP_X
	}

	if (ROMDataAnalyser.isEnabled())
	{
		string category = (variant < 2) ? getCharacterSpriteKey(character) : stringformat("%s_tails", getCharacterSpriteKey(CHARACTER_TAILS))
		Renderer.extractCustomSprite(key, category, animationSprite, atex)
	}

	// Render character
	if (asSmallGhost)
	{
		Renderer.drawCustomSprite(key, px, py, atex, flags | SPRITE_FLAG_PRIO, 0xa800, angle, 0xc0ffffff, 0x8000)
	}
	else
	{
		Renderer.drawCustomSprite(key, px, py, atex, flags, renderQueue, angle, 255)
	}

	bool useAfterImages
	if (isPlayer1)
	{
		if (((super.active == 0xff) || (super.active.tails == 0xff))  && !original_mode)
		{
			useAfterImages = true
		}
		else
		{
			if (Game.getSetting(SETTING_SPEEDUP_AFTERIMGS) && !original_mode)
			{
				useAfterImages = ((u8[characterAddress + 0x2b] & char.bonus.SPEED_UP) != 0)
			}
		}
	}

	if (useAfterImages)
	{
		// Additional offset for Sonic charging a Super Peel-Out (either Hyper Sonic or with Speed Shoes)
		s16 afterImagesOffsetX = 0
		if (char.character == CHARACTER_SONIC && char.spindash == 0x80)
		{
			afterImagesOffsetX = (char.groundspeed >> 7) * ((char.flags & char.flag.FACING_LEFT) ? 1 : -1)
		}
		for (s8 i = 3; i > 0; --i)
		{
			A1 = 0xffffe500 + u8(posbackup.offset.player1 - (i * 8 + 4))
			s16 px0 = u16[A1] - camera.foreground.x.u16 + (i * afterImagesOffsetX / 4)
			s16 py0 = u16[A1+2] - camera.foreground.y.u16
			if (level.vertical_wrap == 0xff00)	// Consider vertical level wrap
				py0 &= level.height.bitmask

			Renderer.setSpriteTagWithPosition(characterAddress + 0x10 + i, px0, py0)
			Renderer.drawCustomSprite(key, px0, py0, atex, flags, renderQueue - i, angle, 192 - i * 32)
		}
	}

	// Prevent emulator-like rendering
	return true
}



// Remove some character drawing corrections in Original Mode.
// Function taken from maingame\character\character_graphics.lemon
//# address-hook(0x012600) end(0x01286c)
//# translated(0x012a2a) end(0x012a6e)
function void UpdateSonicAnimation()
{
	if (char.state != char.state.former)
	{
		char.state.former = char.state
		char.animation.frame = 0
		char.animation.timer = 0
		char.flags &= ~char.flag.PUSHING
	}

	if (!original_mode)
		A1 = (super.active && char.state <= char.state.TRANSFORMING) ? 0x012c3a : 0x012aa6		// Fixed Super Sonic missing some animation states
	else
		A1 = (super.active) ? 0x012c3a : 0x012aa6

	A1 = tableLookupAddress(A1, char.state * 2)
	D0.u8 = u8[A1]

	// D0.u8 is either:
	//  - 0xff when running
	//  - 0xfe when rolling (on ground or in air)
	//  - between 0x00 and 0x7f in other cases (like standing, balancing, spring-jumping, getting hurt, etc.)

	if (D0.u8 < 0x80)
	{
		updateSonicAnimationStanding()
	}
	else if (D0.u8 == 0xff)
	{
		updateSonicAnimationRunning()
	}
	else // if (D0.u8 == 0xfe)
	{
		updateSonicAnimationRolling()
	}
}

function void updateSonicAnimationRunning()
{
	D0 = 0
	if ((char.flags2d & 0x80) || char.rotation.x != 0)
	{
		updateCharacterAnimationRunning_shared()
	}
	else
	{
		D0.u8 = (s8(char.rotation) > 0) ? (char.rotation - 1) : char.rotation
		D2.u8 = char.flags & char.flag.FACING_LEFT
		if (D2.u8 == 0)
			D0.s8 = -D0.s8 - 1

		D0.u8 += 0x10
		D1 = (D0.u8 & 0x80) ? (render_flag.FLIP_X | render_flag.FLIP_Y) : 0
		D2.u8 ^= D1.u8

		char.render_flags &= ~(render_flag.FLIP_X | render_flag.FLIP_Y)
		char.render_flags |= D2.u8

		if (char.flags & char.flag.PUSHING)
		{
			updateSonicAnimationPushing()
			return
		}

		D0.u8 = (D0.u8 >> 4) & 0x06
		D2.u16 = abs(char.groundspeed)
		if (char.bonus_effect & char.bonus.INFINITE_INERTIA)
			D2.u16 *= 2

		if (char.character == CHARACTER_SONIC)
		{
			if (super.active == 0)
			{
				if (D2.u16 < 0x600)
				{
					// Sonic's walking animation
					A1 = 0x012aee
					D3.u8 = D0.u8 * 4
				}
				else
				{
					// Sonic's running animation
					A1 = 0x012af8
					D3.u8 = D0.u8 * 2
				}
			}
			else
			{
				if (D2.u16 < 0x800)
				{
					// Super Sonic's walking animation
					A1 = 0x012c7a
					D3.u8 = D0.u8 * 4
				}
				else
				{
					// Super Sonic's running animation
					A1 = 0x012c84
					D3.u8 = D0.u8 * 2
				}
			}
		}
		else if (char.character == CHARACTER_TAILS)
		{
			if (D2.u16 < 0x600)
			{
				// Tails' walking animation
				A1 = 0x015b04
				D3.u8 = D0.u8 * 4
			}
			else if (D2.u16 < 0x700)
			{
				// Tails' running animation
				A1 = 0x015b0e
				D3.u8 = D0.u8 * 2
			}
			else
			{
				// Tails' faster running animation
				A1 = 0x015bfe
				D3.u8 = D0.u8
			}
		}
		else if (char.character == CHARACTER_KNUCKLES)
		{
			if (D2.u16 < 0x600)
			{
				// Knuckles' walking animation
				A1 = 0x017f3e
				D3.u8 = D0.u8 * 4
			}
			else
			{
				// Knuckles' running animation
				A1 = 0x017f48
				D3.u8 = D0.u8 * 2
			}
		}

		D0.u8 = u8[A1 + char.animation.frame + 1]	// Load next animation frame byte
		if ((D0.u8 >= 0xfe && !original_mode) || (D0.u8 == 0xff && original_mode))		// 0xfe is possible in rare cases when Sonic touches ground while being carried by Tails
		{
			// Loop animation from the start
			char.animation.frame = 0
			D0.u8 = u8[A1 + 1]
		}

		char.animation.sprite = D0.u8 + D3.u8		// Change sprites based on rotations
		--char.animation.timer
		if (s8(char.animation.timer) < 0)
		{
			char.animation.timer = max(0x800 - D2.s16, 0) >> 8
			++char.animation.frame
		}
	}
}



// In Original Mode, remove AIR changes to avoid some animation quirks
// Function taken from objects\shared.lemon
//# address-hook(0x01e0a2)
function void fn01e0a2()
{
	u8 bit = 1 << (D6.u16 + 2)
	if (objA0.flags2a & bit)
	{
		if (u8[A1 + 0x20] != char.state.ROLLING && u8[A1 + 0x20] != char.state.SPINDASH)
		{
		#if STANDALONE
			// Also add exceptions for...
			//  -> The win pose: This prevents characters from showing their walking animation when standing next to an object like the capsule during the level results
			//  -> Super/Hyper transformation: Without this, transforming next to a monitor switched to the run animation, and can even cause a softlock if immediately cancelling the transformation
			if ((u8[A1 + 0x20] != char.state.WIN_POSE && u8[A1 + 0x20] != char.state.TRANSFORMING) || original_mode)
		#endif
			{
				objA1.state = char.state.RUNNING
				u8[A1 + 0x21] = char.state.RUNNING2
			}
		}

		objA0.flags2a &= ~bit
		objA1.flags2a &= ~char.flag.PUSHING
	}
	D4 = 0
}






// In Original Mode, remove improvements to behavior of Knuckles gliding above the screen.
// Functions taken from maingame\character\character.lemon
//# address-hook(0x016ff6) end(0x0170c0)
function void UpdateKnucklesGlide()
{
	if (char.double_jump_state == 1)
	{
		// Glide direction:
		//  - 0x00: Right
		//  - 0x80: Left
		//  - 0x01...0x7f: Turning right to left
		//  - 0x81...0xff: Turning left to right
		u8 glideDirection = knuckles.glide_direction

		// Speed increases while gliding
		D0.u16 = char.groundspeed
		if (D0.u16 < 0x400)
		{
			D0.u16 += 8
		}
		else if (D0.u16 < 0x1800)
		{
			if ((glideDirection & 0x7f) == 0)
			{
				if (super.active)
					D0.u16 += 12
				else
					D0.u16 += 4
			}
		}
		char.groundspeed = D0.u16

		// Gradually change gliding direction
		if ((control.player1.state & CONTROL_LEFT) && glideDirection != 0x80)
		{
			// Change direction towards left
			glideDirection = 2 + abs(glideDirection)
		}
		else if ((control.player1.state & CONTROL_RIGHT) && glideDirection != 0)
		{
			// Change direction towards right
			glideDirection = 2 - abs(glideDirection)
		}
		else
		{
			// Gradually change direction until left/right is reached
			if (glideDirection & 0x7f)
			{
				glideDirection += 2
			}
		}
		knuckles.glide_direction = glideDirection

		s32 dx = lookupCos(glideDirection)
		char.velocity.x = (dx * char.groundspeed) >> 8
		char.velocity.y += (char.velocity.y >= 0x80) ? -0x20 : 0x20
		// Disable this behavior in S3AIR, as it feels like a bug in some places like the HCZ 1 boss fight
		if (level.vertical_wrap != 0xff00 && original_mode)	// ...but only if vertical wrap is disabled
		{
			if (s16(char.position.y.u16) < level.vertical_wrap + 0x10)
			{
				char.velocity.x >>= 1
				char.groundspeed >>= 1
			}
		}
	}

	centerCameraYOffset()
}

//# address-hook(0x016890) end(0x016c78)
//# translated(0x016f6c) end(0x016fa6)
function void UpdateKnucklesGlideCollision()
{
	if (char.double_jump_state == 0)
		return

	D0.u8 = char.double_jump_state
	if (char.double_jump_state == 1 || char.double_jump_state > 5)	// Last check is probably not needed, just added for full compatibility
	{
		// Gliding state
		fn01793e()
		if (knuckles.glideclimbstate & 0x02)	// Gliding?
		{
			if (knuckles.glideclimbstate & 0x20)	// Climbing?
			{
				if ((knuckles.preventclimbing & 0x80) == 0)
				{
					bool hit_wall = true
					D5.u8 = char.layer_flags2
					D0.u8 = knuckles.glide_direction + 0x40
					if (D0.s8 < 0)
					{
						char.flags |= char.flag.FACING_LEFT
						CheckHitboxCollisionLeft()

						D1.u16 |= D0.u16
						if (D1.u16 != 0)
						{
							D3.u16 = char.position.x.u16 - s8(char.hitbox_extends.y) - 1

							if (global.inv_gravity == 0)
							{
								D2.u16 = char.position.y.u16 - 11
								Character.checkFloorEdgeCollisionFixedY()
								if (D1.s16 < 0 || D1.u16 >= 12)
								{
									hit_wall = false
								}
								else
								{
									char.position.y.u16 += D1.u16
								}
							}
							else
							{
								D2.u16 = (char.position.y.u16 + 11) ^ 0x0f
								Character.checkCeilingEdgeCollisionFixedY()
								if (D1.s16 < 0 || D1.u16 >= 12)
								{
									hit_wall = false
								}
								else
								{
									char.position.y.u16 -= D1.u16
								}
							}
						}
						else
						{
							++char.position.x.u16
						}
					}
					else
					{
						char.flags &= ~char.flag.FACING_LEFT
						CheckHitboxCollisionRight()

						D1.u16 |= D0.u16
						if (D1.u16 != 0)
						{
							D3.u16 = char.position.x.u16 + s8(char.hitbox_extends.y) + 1

							if (global.inv_gravity == 0)
							{
								D2.u16 = char.position.y.u16 - 11
								Character.checkFloorEdgeCollisionFixedY()
								if (D1.s16 < 0 || D1.u16 >= 12)
								{
									hit_wall = false
								}
								else
								{
									char.position.y.u16 += D1.u16
								}
							}
							else
							{
								D2.u16 = (char.position.y.u16 + 11) ^ 0x0f
								Character.checkCeilingEdgeCollisionFixedY()
								if (D1.s16 < 0 || D1.u16 >= 12)
								{
									hit_wall = false
								}
								else
								{
									char.position.y.u16 -= D1.u16
								}
							}
						}
					}

					if (hit_wall)
					{
						// When Hyper Knuckles hits a wall fast enough, that kills all badniks on screen
						if ((super.active & 0x80) && u16(char.groundspeed) >= 0x480)
						{
							camera.hyper_knux_shake = 0x14
							Character.ClearEnemiesOnScreen()
							playSound(0x49)
						#if STANDALONE
							Input.setControllerRumbleByAddress(A0, 0.5f, 1.0f, 200)
						#endif
						}
						else
						{
							playSound(SFX_GRAB)
						#if STANDALONE
							Input.setControllerRumbleByAddress(A0, 0.5f, 0.0f, 200)
						#endif
						}

						char.groundspeed = 0
						char.velocity.x = 0
						char.velocity.y = 0
						char.double_jump_state = 4
						char.animation.sprite = 0xb7
						char.animation.timer = 0x7f
						char.animation.frame = 0
						knuckles.glide_direction = 3
						char.position.x.frac = char.position.x.u16
					#if STANDALONE
						// Prevent Knuckles from climbing above the screen limits
						//  -> This same check is down while climbing up/down, but we do it here to correct the position right away
						//  -> This is added for S3AIR specifically because it's now much easier to get outside the screen after we removed the stopping effect when gliding the the top of screen (see "UpdateKnucklesGlide")
						if (level.vertical_wrap != 0xff00 && !original_mode)
						{
							s16 minY = level.vertical_wrap + 0x10
							if (s16(char.position.y.u16) < minY)
							{
								char.position.y.u16 = minY
							}
						}
					#endif
						return
					}
				}

				char.double_jump_state = 2
				char.state = char.state.KNUX_FALLING
				char.hitbox_extends.x = char.hitbox.default.x
				char.hitbox_extends.y = char.hitbox.default.y
				knuckles.glideclimbstate |= 0x02
				return
			}

			if (control.player1.state & CONTROL_ABC)
			{
				fn016fa8()
			}
			else
			{
				// Stop gliding
				char.double_jump_state = 2
				char.state = char.state.KNUX_FALLING
				if (char.velocity.x < 0)
					char.flags |= char.flag.FACING_LEFT
				else
					char.flags &= ~char.flag.FACING_LEFT

				char.velocity.x >>= 2
				char.hitbox_extends.x = char.hitbox.default.x
				char.hitbox_extends.y = char.hitbox.default.y

			#if STANDALONE
				// Perform a ground collision check after updating the hitbox height
				//  -> This prevents getting killed when Knuckles stops gliding just above the floor and there's a blocker object right underneath
				if (!original_mode)
				{
					Character.CheckFloorCollision()
					if (D1.s16 < 0)
					{
						char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
					}
				}
			#endif
			}
		}
		else
		{
			if (char.velocity.x < 0)
				char.flags |= char.flag.FACING_LEFT
			else
				char.flags &= ~char.flag.FACING_LEFT

			D0.u8 = (char.rotation + 0x20) & 0xc0
			if (D0.u8 != 0)
			{
				char.velocity.x = char.groundspeed
				char.velocity.y = 0
				Character.LandingOnGroundNoSpindash()
			}
			else
			{
				char.double_jump_state = 3
				char.animation.sprite = 0xcc
				char.animation.timer = 0x7f
				char.animation.frame = 0
				if (char.drown_countdown >= 12)
				{
					u8[A6 + 0x05] = 6
					u8[A6 + 0x22] = 0x15
				}
			}
		}
	}
	else if (char.double_jump_state == 2)
	{
		// Falling state
		Character.UpdateControlInAir()

		// Gravity
		char.velocity.y += (char.flags & char.flag.UNDERWATER) ? 0x10 : 0x38

		fn01793e()
		if ((knuckles.glideclimbstate & 0x02) == 0)
		{
			char.groundspeed = 0
			char.velocity.x = 0
			char.velocity.y = 0
			s16 dy = s8(char.hitbox_extends.y - char.hitbox.default.y)
			char.position.y.u16 += global.inv_gravity ? -dy : dy
			playSound(0x4c)

			D0.u8 = (char.rotation + 0x20) & 0xc0
			if (D0.u8 != 0)
			{
				Character.LandingOnGroundNoSpindash()
			}
			else
			{
				Character.LandingOnGroundNoSpindash()
				char.hlock_countdown = 15
				char.state = char.state.KNUX_STANDUP2
			}
		}
	}
	else if (char.double_jump_state == 3)
	{
		// Touched ground while gliding
		bool goto016b64 = false
		if (control.player1.state & CONTROL_ABC)
		{
			if (char.velocity.x < 0)
			{
				char.velocity.x += 0x20
				goto016b64 = (char.velocity.x < 0)
			}
			else
			{
				char.velocity.x -= 0x20
				goto016b64 = (char.velocity.x >= 0)
			}
		}

		if (goto016b64)
		{
			fn01793e()
			Character.CheckFloorCollision()
			if (D1.s16 < 0x0e)
			{
				char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
				char.rotation = D3.u8
				if ((level.framecounter.low & 0x07) == 0)
				{
					playSound(0x7e)
				}
			#if STANDALONE
				Input.setControllerRumbleByAddress(A0, 0.2f, 0.2f, 100)
			#endif
			}
			else
			{
				char.double_jump_state = 2		// Knuckles glide drop state
				char.state = char.state.KNUX_FALLING
				char.hitbox_extends.x = char.hitbox.default.x
				char.hitbox_extends.y = char.hitbox.default.y
				knuckles.glideclimbstate |= 0x02
			}
		}
		else
		{
			char.groundspeed = 0
			char.velocity.x = 0
			char.velocity.y = 0
			s16 dy = s8(char.hitbox_extends.y - char.hitbox.default.y)
			char.position.y.u16 += global.inv_gravity ? -dy : dy
			Character.LandingOnGroundNoSpindash()
			char.hlock_countdown = 15
			char.state = char.state.KNUX_STANDUP
		}
	}
	else if (char.double_jump_state == 4)
	{
		// Climbing state
		if (knuckles.preventclimbing & 0x80 || char.position.x.u16 != char.position.x.frac || (char.flags & char.flag.ON_OBJECT))
		{
			fn016ed2()
			return
		}

		char.groundspeed = 0
		char.velocity.x = 0
		char.velocity.y = 0
		u32[0xfffff796] = (char.layer_flags2 == 0x0d) ? u32[0xfffff7b4] : u32[0xfffff7b8]
		D5.u8 = char.layer_flags2
		D1 = 0

		if ((control.player1.state & CONTROL_UP) == 0)
		{
			fn016d10()
			return
		}

		if (global.inv_gravity)
		{
			fn016da8()
			return
		}

		D2.u16 = char.position.y.u16 - 11
		fn016f4e()
		if (D1.s16 >= 4)
		{
			fn016eba()
			return
		}

		if (D1.u16 != 0)
		{
			fn016e60()
		}

		D5.u8 = char.layer_flags2
		D2.u16 = char.position.y.u16 - 8
		D3.u16 = char.position.x.u16
		fn00fbee()
		if (D1.s16 < 0)
		{
			char.position.y.u16 -= D1.u16
			D1 = 1
		}
		else
		{
			--char.position.y.u16
			if (super.active)
				--char.position.y.u16

			D1 = 1
			D0.u16 = level.vertical_wrap
			if (D0.u16 != 0xff00)
			{
				D0.u16 += 0x10
				if (D0.s16 > s16(objA0.position.y.u16))
				{
					char.position.y.u16 = D0.u16
				}
			}
		}
		fn016e10()
	}
	else if (char.double_jump_state == 5)
	{
		// Climbing up a ledge
		if (char.animation.timer == 0)
		{
			fn016efe()
			if (knuckles.glide_direction == 0x10)
			{
				char.groundspeed = 0
				char.velocity.x = 0
				char.velocity.y = 0
				if (char.flags & char.flag.FACING_LEFT)
					--char.position.x.u16

				Character.LandingOnGroundNoSpindash()
				char.state = char.state.STANDING
			}
		}
	}
}

//# address-hook(0x01174a) end(0x0117d8)
//# address-hook(0x014f74) end(0x015000)
function void Character.CheckForStartRolling()
{
	u8 input_state = (char.character == CHARACTER_TAILS) ? control.tails.state : control.player1.state

	if ((char.bonus_effect & char.bonus.INFINITE_INERTIA) == 0)
	{
		if ((input_state & (CONTROL_LEFT | CONTROL_RIGHT)) == 0)	// No left or right pressed
		{
			if (input_state & CONTROL_DOWN)
			{
				if (abs(char.groundspeed) >= 0x100)
				{
					// Start rolling
					u32 onObjectAddress = 0xffff0000 + char.object_standing_on
					bool allowRolling = (original_mode || !((char.flags & char.flag.ON_OBJECT) && (u32[onObjectAddress] == 0x01f752 || u32[onObjectAddress] == 0x03a252)))
					if ((char.flags & char.flag.ROLLING) == 0 && allowRolling)
					{
						char.flags |= char.flag.ROLLING
						char.hitbox_extends.x = char.hitbox.x.ROLLING
						char.hitbox_extends.y = char.hitbox.y.ROLLING
						char.state = char.state.ROLLING

						s8 dy = (char.character == CHARACTER_TAILS) ? 1 : 5
						char.position.y.u16 += (global.inv_gravity) ? -dy : dy

						playSound(SFX_ROLL)
						if (char.groundspeed == 0)
							char.groundspeed = 0x200
					}
				}
				else if ((char.flags & char.flag.ON_OBJECT) == 0)
				{
					char.state = char.state.COWERING
				#if STANDALONE
					// Also slow down a little
					if (char.groundspeed <= -4 && !original_mode)
						char.groundspeed += 4
					else if (char.groundspeed >= 4 && !original_mode)
						char.groundspeed -= 4
				#endif
				}
			}
			else
			{
				// Stop crouching
				if (char.state == char.state.COWERING)
					char.state = char.state.RUNNING

			#if STANDALONE
				// Allow for starting the Super Peel-Out even if still moving slowly, just like handling for the spindash
				//  (this logic here is active even if the Peel-Out is not enabled)
				if ((input_state & CONTROL_UP) && abs(char.groundspeed) < 0x100 && (char.flags & char.flag.ON_OBJECT) == 0 && !original_mode)
				{
					char.state = char.state.LOOKING_UP
					if (char.groundspeed <= -4)
						char.groundspeed += 4
					else if (char.groundspeed >= 4)
						char.groundspeed -= 4
				}
			#endif
			}
		}
	}
}




// In Original Mode, allows shields to be lost by characters on MGZ tops.
// Function taken from maingame\character\character.lemon
//# address-hook(0x010294) end(0x010364)
function void Character.GettingHurt()
{
	bool canLoseShield = true	// Usually true, gets false e.g. for 2nd player Tails
	bool isProtectedByObject = ((char.protection_flag & 0x80) != 0)
	bool spilledRings = false

	u16 rings = ring_counter
	if (A0 != 0xffffb000)
	{
		// It's the second player
		if (competition_mode.active)
		{
			rings = ring_counter.player2
		}
		else
		{
			canLoseShield = false
		}
	}

	if (canLoseShield && (char.bonus_effect & char.bonus.ANY_SHIELD) == 0)
	{
		if (!isProtectedByObject)
		{
			// No more rings?
			if (rings == 0)
			{
				D0 = getSoundIdByObstacleAddress(u32[A2])
				Character.Die_internal()
				return
			}

			// Create ring spill object
			if (allocDynamicObjectStd())
			{
				objA1.update_address = 0x01a64a
				objA1.position.x.u16 = char.position.x.u16
				objA1.position.y.u16 = char.position.y.u16
				u16[A1 + 0x3e] = A0.u16
			}
			spilledRings = true

			// Should be unnecessary, but make sure all shield flags are cleared
			char.bonus_effect &= ~char.bonus.ALL_SHIELDS
		}
	}
	else
	{
	#if STANDALONE
		// When using e.g. the MGZ spinning top, do not lose your shield
		if (!isProtectedByObject || original_mode)
	#endif
		{
			// Lose shield
			char.bonus_effect &= ~char.bonus.ALL_SHIELDS
		}
	}

	char.base_state = 0x04
	Character.LandingOnGroundNoSpindash()
	char.flags |= char.flag.IN_AIR
	if (char.flags & char.flag.UNDERWATER)
	{
		char.velocity.x = -0x100
		char.velocity.y = -0x200
	}
	else
	{
		char.velocity.x = -0x200
		char.velocity.y = -0x400
	}
	if (char.position.x.u16 >= u16[A2 + 0x10])
	{
		char.velocity.x = -char.velocity.x
	}

	char.groundspeed = 0
	char.state = char.state.GOT_HURT
	char.invuln.countdown = 120

#if STANDALONE
	if (char.character == CHARACTER_SONIC)
	{
		// Reset drop dash
		sonic.dropdash_counter = 0
	}

	// In standalone, don't play the sound when rings got spilled
	//  -> This check is not necessary in emulation, as the ring spill sound kills this one (only one of both can be played)
	if (!spilledRings)
#endif
	{
		playSound(getSoundIdByObstacleAddress(u32[A2]))
	}
	D0 = 0xffffffff
}






// Enforce using lives in Original Mode and fix issues with the extra life jingle.
// Functions taken from maingame\character\character.lemon
function bool checkForExtraLifeByRings()
{
	// No extra lives in Time Attack or when infinite lives option is enables
	//  -> These check ensure that the ring sound gets played when collecting the 100th / 200th / etc. ring
	//  -> Fix #contributed by Thorn
	if (time_attack == 1 || time_attack == 2 || (Game.getSetting(SETTING_INFINITE_LIVES) && !original_mode))
		return false

	// Here's a good place to check for the 300 rings achievement
	if (ring_counter >= 300)
	{
		Game.setAchievementComplete(ACHIEVEMENT_300_RINGS)
	}

	if (!Game.getSetting(SETTING_INFINITE_LIVES) && !original_mode)
	{
		// Standalone uses upper 7 bits of "extra_lives_granted" differently, to allow for extra lives at 300+ rings as well
		u16 currentExtraLives = (extra_lives_granted >> 1)
		u16 ringsNeeded = (currentExtraLives + 1) * 100
		if (ring_counter >= ringsNeeded)
		{
			extra_lives_granted += 2	// Increase the value in upper 7 bits by 1
			return true
		}
	}
	if (!original_mode)
		return false

	// Original mode extra lives by rings
	if (ring_counter >= 100)
	{
		if ((extra_lives_granted & 0x02) == 0)
		{
			extra_lives_granted |= 0x02
			return true
		}

		if (ring_counter >= 200 && (extra_lives_granted & 0x04) == 0)
		{
			extra_lives_granted |= 0x04
			return true
		}
	}
	return false
}

//# address-hook(0x0123c2) end(0x01257a)
function void Character.CheckDiedStateEnd()
{
	char.spindash = 0
	if (A0 == 0xffffb000)
		player1.camera_lock = 1
	else
		player2.camera_lock = 1

	D0.u16 = camera.position.y.u16
	if (global.inv_gravity)
	{
		D0.u16 -= 0x10
		if (s16(char.position.y.u16) > D0.s16)
			return
	}
	else
	{
		D0.s16 += (competition_mode.active) ? 0x90 : 0x100
		if (s16(char.position.y.u16) <= D0.s16)
			return
	}

#if STANDALONE
	if (!Game.onCharacterDied((A0 == 0xffffb000) ? 0 : 1))
		return
#endif

	if (competition_mode.active)
	{
		// Competition mode
		char.base_state = 0x02
		if (A0 == 0xffffb000)
		{
			player1.camera_lock = 0
			char.position.x.u16 = checkpoint.x
			char.position.y.u16 = checkpoint.y
			char.sprite_attributes = checkpoint.sprite_attr
			char.layer_flags = checkpoint.layer_flags
			ring_counter = 0
			extra_lives_granted = 0
			u8[0xfffff74a] = 1
		}
		else
		{
			player2.camera_lock = 0
			char.position.x.u16 = u16[0xfffffe4c]
			char.position.y.u16 = u16[0xfffffe4e]
			char.sprite_attributes = u16[0xfffffe56]
			char.layer_flags = u16[0xfffffe58]
			ring_counter.player2 = 0
			u8[0xfffff74b] = 1
		}

		char.control_flags = 0
		char.state = char.state.STANDING
		char.velocity.x = 0
		char.velocity.y = 0
		char.groundspeed = 0
		char.flags = char.flag.IN_AIR
		char.hlock_countdown = 0
		char.spindash_charge = 0
		char.speedup.countdown = 0

		A1 = 0x1e3c00 + char.character * 8
		u16[A4] = u16[A1]
		u16[A4 + 2] = u16[A1 + 2]
		u16[A4 + 4] = u16[A1 + 4]
	}
	else
	{
		// Normal game
		if (char.character == CHARACTER_TAILS && !isMainCharacter(CHARACTER_TAILS))
		{
			// Second player Tails
			char.base_state = 0x02
			RespawnTails()
		}
		else
		{
			char.base_state = 0x08
			char.spindash_charge = 0x3c
			global.in_extra_stage = 0

		#if STANDALONE
			if (!Game.getSetting(SETTING_INFINITE_LIVES) || original_mode)
		#endif
			{
				--lives_counter
			}
			++hud.dirty.lives

			bool lostGame = false
			if (lives_counter == 0)
			{
				u8[0xffffb094 + 0x22] = 0
				u8[0xffffb0de + 0x22] = 1
				global.time_over = 0	// It's game over instead
				lostGame = true
			}
			else if (global.time_over)
			{
				u8[0xffffb094 + 0x22] = 2
				u8[0xffffb0de + 0x22] = 3
				lostGame = true
			}

			if (lostGame)
			{
			#if GAMEAPP
				Game.setUnderwaterAudioEffect(0)
			#endif

				// Create time/game over objects
				u32[0xffffb094] = 0x02d5c6
				u32[0xffffb0de] = 0x02d5c6

				u16[0xffffb094 + 0x3e] = A0.u16
				char.spindash_charge = 0
				hud.dirty.timer = 0
				hud.dirty.timer.player2 = 0
				playMusic(MUSIC_GAMEOVER)

				// Load patterns for time/game over
				D0 = 3
				FillPatternLoadingCues()
			}
		}
	}
}






// Allow more than 99 lives in Original Mode.
// At the moment the life counter does not show the incorrect tens digit as it does in base S3&K.
// Function taken from maingame\character\character.lemon
function void gainExtraLife()
{
	// No extra lives in Time Attack
	if (time_attack == 1 || time_attack == 2)
		return

	if (original_mode)	// Original Mode does not check to see if lives have exceeded 99
	{
		++lives_counter
		++hud.dirty.lives
		playMusic(MUSIC_EXTRALIFE)
	}
	else if (!Game.getSetting(SETTING_INFINITE_LIVES))
	{
		lives_counter = min(lives_counter + 1, 99)
		++hud.dirty.lives
		playMusic(MUSIC_EXTRALIFE)
	}
}



// Implement Euka's fix for occasional spilled ring clipping only outside of Original Mode.
// Function taken from objects\basics\ring.lemon
//# address-hook(0x01a6b6) end(0x01a734)
//# translated(0x01a6ae) end(0x01a758)
function void SpillRings()
{
	while (D5.s16 >= 0)
	{
		objA1.update_address = D6
		objA1.render_flags = (render_flag.WORLD | render_flag.VISIBLE)
		objA1.base_state += 2
		objA1.box_size.x = 8
		if (!original_mode)
		{
			objA1.box_size.y = 8
		}
		objA1.sprite_priority = 0x180
		objA1.sprite_attributes = (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE1 | 0x06bc)
		objA1.mapping_offset = 0x01a99a
		objA1.position.x.u16 = objA0.position.x.u16
		objA1.position.y.u16 = objA0.position.y.u16
		objA1.hitbox_extends.y = 8
		objA1.hitbox_extends.x = 8
		objA1.collision_attributes = (collision.flag.ITEM | collision.size.6x6)

		spilled_rings.speed = 0xff
		if (D4.s16 >= 0)
		{
			// Entered only for every second ring (the others use x-mirrored directions)
			u8 angle = D4.u8
			u8 shift = D4.u16 >> 8
			D2.s16 = lookupSin(angle) << shift
			D3.s16 = lookupCos(angle) << shift

			// Go on with next angle (and possibly switch to a lower shift)
			if (D4.u8 < 0xf0)
			{
				D4.u8 += 0x10
			}
			else
			{
				D4.u16 -= 0x170
				if (D4.s16 < 0)
				{
					D4.s16 = 0x288
				}
			}
		}
		objA1.velocity.x = D2.u16
		objA1.velocity.y = D3.u16
		D2.s16 = -D2.s16
		D4.s16 = -D4.s16

		// Next ring
		--D5.s16
		if (D5.s16 < 0)
			break
		if (!allocDynamicObjectAfterA0())
			break
	}

	playSound(SFX_SPILLRINGS)
	ring_counter = 0
	hud.dirty.rings = 0x80
	extra_lives_granted = 0

	if (global.inv_gravity)
	{
		fn01a7e8()
	}
	else
	{
		fn01a75c()
	}
}




// Enforce Sonic 3 behavior for Bubble shield, transformations, and Insta-shield in Original Mode.
// Functions taken from maingame\character\character.lemon
function void SonicPressedJumpInMidAir()
{
	// Remove control lock
	char.flags &= ~char.flag.CONTROL_LOCK
#if STANDALONE
	char.double_jump_state = 1	// Always set this flag; needed for Drop Dash
#endif

	if ((super.active && Game.getSetting(SETTING_SUPER_SONIC_ABILITY) != 1 && !original_mode) || (super.active & 0x80))
	{
		bool isHyperSonic = (super.active & 0x80)			// Hyper Sonic active
		bool performHyperDash = isHyperSonic
		u8 input = control.player1.state & CONTROL_DPAD		// Only directions

	#if STANDALONE
		if (Game.getSetting(SETTING_SUPER_SONIC_ABILITY) == 2)
		{
			performHyperDash = (super.active)				// This allows Super Sonic to use the dash as well
		}

		if (performHyperDash && Game.getSetting(SETTING_HYPER_DASH_CONTROLS) == 1 && !original_mode)
		{
			// Hyper Dash requires also pressing D-pad in any direction
			//  -> To allow for Drop Dashing without activating the Hyper Dash before
			performHyperDash = (input != 0)
		}
	#endif

		if (performHyperDash)
		{
		#if STANDALONE
			if (isHyperSonic)	// Super Sonic's dash does not cause a screen flash
		#endif
			{
				Character.ClearEnemiesOnScreen()
			}

			camera.locktime.player1 = 0x2000
			// if (!original_mode)		// position backup removal still needed to prevent wild Hyper Dash camera movement in Classic Mode
				ClearPositionBackup()

			char.double_jump_state = 1
		#if STANDALONE
			if (!isHyperSonic)
				u8[0xffffcbc0 + 0x20] = 1
			else
		#endif
				u8[0xffffcd7c + 0x20] = 1

			playSound(SFX_SPINDASH_RELEASE)

			if (input != 0 && input < 0x0b)		// Not left and right at the same time
			{
				// Perform Hyper Dash
				A1 = 0x011afa + input * 4
				char.velocity.x = s16[A1]
				char.velocity.y = s16[A1+2]
			}
			else
			{
				char.velocity.x = (char.flags & char.flag.FACING_LEFT) ? -0x800 : 0x800
				char.velocity.y = 0
			}

		#if STANDALONE
			if (!isHyperSonic)
			{
				// Reduce dash speed for Super Sonic
				char.velocity.x = (char.velocity.x > 0) ? (char.velocity.x - 0x200) : (char.velocity.x < 0) ? (char.velocity.x + 0x200) : 0
				char.velocity.y = (char.velocity.y > 0) ? (char.velocity.y - 0x200) : (char.velocity.y < 0) ? (char.velocity.y + 0x200) : 0
			}
		#endif

			char.groundspeed = char.velocity.x
		}
		else
		{
			char.double_jump_state = 1
		}
	}
#if STANDALONE
	else if ((char.bonus_effect & char.bonus.INVINCIBLE) && (Game.getSetting(SETTING_SUPER_SONIC_ABILITY) != 1 && !original_mode && !super.active))
#else
	else if (char.bonus_effect & char.bonus.INVINCIBLE)
#endif
	{
		// No reaction
	}
	else if (char.bonus_effect & char.bonus.SHIELD_FIRE && !(super.active && original_mode) && !(char.bonus_effect & char.bonus.INVINCIBLE))
	{
	#if STANDALONE
		if (super.active)
			u8[0xffffcbc0 + 0x20] = 1
		else
	#endif
			u8[0xffffcce8 + 0x20] = 1		// That's 0x20 inside the shield object at 0xffffcce8
		char.double_jump_state = 1

		s16 vx = 0x800
		if (char.flags & char.flag.FACING_LEFT)
			vx = -vx

		char.velocity.x = vx
		char.velocity.y = 0
		char.groundspeed = vx
		camera.locktime.player1 = 0x2000
		ClearPositionBackup()
		playSound(SFX_FIRESHIELDDASH)
	}
	else if (char.bonus_effect & char.bonus.SHIELD_LIGHTNING && !(super.active && original_mode) && !(char.bonus_effect & char.bonus.INVINCIBLE))
	{
	#if STANDALONE
		if (super.active)
			u8[0xffffcbc0 + 0x20] = 1
		else
	#endif
			u8[0xffffcce8 + 0x20] = 1
		char.double_jump_state = 1

	#if STANDALONE
		if (super.active && !original_mode)
			char.velocity.y = -0x680	// Slightly increasing double jump height for Super Sonic
		else
	#endif
			char.velocity.y = -0x580
		char.jumping = 0
		playSound(SFX_LIGHTNINGJUMP)
	}
	else if (char.bonus_effect & char.bonus.SHIELD_BUBBLE && !(super.active && original_mode) && !(char.bonus_effect & char.bonus.INVINCIBLE))
	{
	#if STANDALONE
		if (super.active)
			u8[0xffffcbc0 + 0x20] = 1
		else
	#endif
			u8[0xffffcce8 + 0x20] = 1
		char.double_jump_state = 1

	#if STANDALONE
		if (!Game.getSetting(SETTING_BUBBLE_SHIELD_BOUNCE) || original_mode || time_attack)
	#endif
		{
			char.velocity.x = 0
		}
		char.velocity.y = 0x800
		char.groundspeed = 0
		playSound(SFX_BUBBLEBOUNCE)
	}
	else
	{
		if (!original_mode)
		{
			if (!Game.getSetting(SETTING_INSTA_SHIELD) && !original_mode && !time_attack)
				return

			// Knuckles in competition mode uses this code as well, but he should not have an insta-shield
			if (competition_mode.active && char.character == CHARACTER_KNUCKLES)
				return
		}
		if (original_mode && ((char.bonus_effect & char.bonus.INVINCIBLE) || super.active))
			return
		else if (original_mode || Input.buttonPressed(BUTTON_Y))
		{
			if (Character.performSuperTransformation())
				return
		}

		// Insta-Shield
		if ((char.bonus_effect & char.bonus.ANY_SHIELD) == 0)
		{
			u8[0xffffcce8 + 0x20] = 1
			char.double_jump_state = 1
			playSound(SFX_INSTASHIELD)
		}
	}
}

function void Character.LandingOnGroundResetState()
{
	char.flags &= ~char.flag.IN_AIR
	char.flags &= ~char.flag.PUSHING
	char.flags &= ~char.flag.CONTROL_LOCK
	char.jumping = 0
	score.bonus_counter = 0		// No more increasing bonusses after hitting the ground
	char.rotation.x = 0
	u8[A0 + 0x2d] = 0
	u8[A0 + 0x30] = 0
	char.look_up_down_timer = 0

	// Check for double jump state
	if (char.double_jump_state != 0)
	{
	#if STANDALONE
		if (char.character == CHARACTER_SONIC && (!super.active || (Game.getSetting(SETTING_SUPER_SONIC_ABILITY) == 1 && !original_mode && !(super.active & 0x80))) && (char.bonus_effect & char.bonus.SHIELD_BUBBLE))
	#else
		if (char.character == CHARACTER_SONIC && !super.active && (char.bonus_effect & char.bonus.SHIELD_BUBBLE))
	#endif
		{
		#if STANDALONE
			if (((char.bonus_effect & char.bonus.INVINCIBLE) == 0 && sonic.dropdash_counter == 0) || Game.getSetting(SETTING_SUPER_SONIC_ABILITY) == 1)
		#endif
			{
				SonicLandingBubbleBounce()
			}
		}
		char.double_jump_state = 0
	}

	// Check for Knuckles gliding/falling/standup state
	if (char.character == CHARACTER_KNUCKLES && char.state >= 0x20)
	{
		char.state = char.state.RUNNING
	}
}

//# address-hook(0x012232) end(0x0122b8)
function void SonicLandingBubbleBounce()
{
	s16 force = (char.flags & char.flag.UNDERWATER) ? 0x400 : 0x780

#if STANDALONE
	if (Game.getSetting(SETTING_BUBBLE_SHIELD_BOUNCE) && !original_mode && !time_attack)
	{
		s16 vx = mainchar.groundhit.velocity.x
		s16 vy = mainchar.groundhit.velocity.y
		u8 moveAngle = lookupAngleByVector(vx, vy)
		u8 groundAngle = char.rotation
		u8 reflectedAngle = groundAngle * 2 - moveAngle
		char.velocity.x = (s32(lookupCos(reflectedAngle)) * force) >> 8
		char.velocity.y = (s32(lookupSin(reflectedAngle)) * force) >> 8
	}
	else
#endif
	{
		u8 angle = char.rotation - 0x40
		char.velocity.x += (s32(lookupCos(angle)) * force) >> 8
		char.velocity.y += (s32(lookupSin(angle)) * force) >> 8
	}

	char.state = char.state.ROLLING
	char.flags |= (char.flag.IN_AIR | char.flag.ROLLING)
	char.flags &= ~char.flag.PUSHING
	char.jumping = 1
	char.on_convex_surface = 0
	char.hitbox_extends.y = 14
	char.hitbox_extends.x = 7

	s8 dy = char.hitbox_extends.y - char.hitbox.default.y
	char.position.y.u16 += (global.inv_gravity) ? dy : -dy

	u8[0xffffcce8 + 0x20] = 2
	playSound(SFX_BUBBLEBOUNCE)
}

//# address-hook(0x00fe8e) end(0x00ff04)
function void Character.CheckCollisionsWithDynamicObjects()
{
	SonicUpdateRingCollection()
	UpdateShieldDeflecting()

	bool hasInstaShield = false
#if STANDALONE
	if (Game.getSetting(SETTING_INSTA_SHIELD) || original_mode || time_attack)
#endif
	{
		if (char.character == CHARACTER_SONIC && (char.bonus_effect & (char.bonus.ALL_SHIELDS | char.bonus.INVINCIBLE)) == 0)
		{
			hasInstaShield = (char.double_jump_state == 1)
		}
	}

	if (hasInstaShield)
	{
		// Insta-shield makes Sonic briefly invincible and increases his hitbox
		u8 oldBonusEffect = char.bonus_effect
		char.bonus_effect |= char.bonus.INVINCIBLE
	#if STANDALONE
		if (!original_mode)
		{
			// Also make insta-shield bounce off projectiles
			char.bonus_effect |= char.bonus.ANY_SHIELD
		}
	#endif

		// Larger hitbox
		D2.u16 = char.position.x.u16 - 0x18
		D3.u16 = char.position.y.u16 - 0x18
		D4.u16 = 0x30
		D5.u16 = 0x30
		Character.CheckCollisionsWithDynamicObjects_partial()

		char.bonus_effect = oldBonusEffect
	}
	else
	{
		D5 = char.hitbox_extends.y - 3
		D2 = char.position.x.u16 - 8
		D3 = char.position.y.u16 - D5.u16
		D4 = 16
		D5 *= 2
		Character.CheckCollisionsWithDynamicObjects_partial()
	}
}




// Disable faster pushing in Original Mode.
// Function taken from objects\level\rocks.lemon
//# address-hook(0x0200cc) end(0x02011c)
function void fn0200cc()
{
	u32 bit = (1 << D6)
	if ((D3 & bit) && (D2.u16 < objA1.position.x.u16) && (D0 & 0x20))
	{
		--u16[A0 + 0x40]
		if (s16[A0 + 0x40] < 0)
		{
			u16[A0 + 0x40] = (Game.getSetting(SETTING_FASTER_PUSH) && !original_mode) ? 4 : 16
			if (objA0.value42 != 0)
			{
				--objA0.value42
				--objA0.position.x.u16
				--objA1.position.x.u16
				CheckGroundCollision()
				objA0.position.y.u16 += D1.u16

				D0.u16 = objA0.respawn_entry
				if (D0.u16 != 0)
				{
					A2 = 0xffff0000 + D0.u16
					u8[A2] = (0x40 - u8[A0 + 0x43]) | 0x80
				}
			}
		}
	}
}

// Function taken from objects\basics\spikes.lemon
//# address-hook(0x02438a) end(0x0243b8)
function void fn02438a()
{
	// Pushable?
	if ((D3 & (1 << D6)) && (D2.u16 >= objA1.position.x.u16) && (D0 & 0x20))
	{
		--u16[A0 + 0x3a]
		if (s16[A0 + 0x3a] < 0)
		{
			u16[A0 + 0x3a] = (Game.getSetting(SETTING_FASTER_PUSH) && !original_mode) ? 6 : 16
			if (u16[A0 + 0x3c] != 0)
			{
				--u16[A0 + 0x3c]
				++objA0.position.x.u16
				++objA1.position.x.u16
			}
		}
	}
}

// Function taken from objects\09_soz\soz_pushswitch.lemon
//# address-hook(0x0419fa) end(0x041a6a)
function void fn0419fa()
{
	if ((D3 & (1 << D6)) == 0)
		return

	if ((D0 & 0x20) == 0)
		return

	// Pushing from left or right?
	bool sign = (D2.u16 < objA1.position.x.u16)
	if (((objA0.flags2a & 0x01) == 0) == sign)
		return

	#if STANDALONE
		// Check character's orientation, is he faced away?
		if (sign != ((u8[A1 + 0x2a] & char.flag.FACING_LEFT) != 0) && !original_mode)
			return
	#endif

	if (u16[A0 + 0x36] != 0x80)
	{
		if (Game.getSetting(SETTING_FASTER_PUSH) && !original_mode)
		{
			u16[A0 + 0x36] = min(u16[A0 + 0x36] / 2 * 2 + 2, 0x80)
			if ((u16[A0 + 0x36] % 4) == 0)
			{
				objA1.position.x.u16 += (sign ? -1 : 1)
				playSound(0x69)
			}
		}
		else	// This setup for Original Mode causes a visible jitter that isn't in the ROM hack, but it's functionally correct.
		{		// The jitter is actually the switch moving one frame before the character does.
				// Even using the AIR script directly with the STANDALONE part stripped out shows the jitter; this is likely not a DAGE bug.
			++u16[A0 + 0x36]
			objA1.position.x.u16 += (sign ? -1 : 1)
			if ((u16[A0 + 0x36] % 4) == 0)
			{
				playSound(0x69)
			}
		}
	}

	D5 = 1
}

// Function taken from objects\09_soz\soz_pushablerock.lemon
//# address-hook(0x0406e4) end(0x04076c)
//# translated(0x04076e) end(0x040770)
function void fn0406e4()
{
	if ((D3 & (1 << D6)) == 0)
		return

	if ((D0 & 0x20) == 0)
		return

	s8 sign = (D2.u16 < objA1.position.x.u16) ? -1 : 1

	--objA0.value32
	if (s16(objA0.value32) < 0)
	{
		objA0.value32 = 4
	#if STANDALONE
		// Tweak: Gotta push fast! (Except for rolling demo, as this would break the SOZ one)
		if (Game.getSetting(SETTING_FASTER_PUSH) && !original_mode && !global.rolling_demo)
		{
			// ...and even faster when spindashing
			objA0.value32 = (u8[A1 + 0x3d] != 0) ? 0 : 1
		}
	#endif

		objA0.position.x.u16 += sign
		objA1.position.x.u16 += sign
		playSound(0x69)

		D3.u16 = objA0.position.x.u16 - sign * 0x10
		CheckGroundCollisionFixedX()

		if (D1.s16 > 0x0e)
		{
			objA0.flags2a |= 0x02
			objA0.update_address = 0x0405d8
		}
		else
		{
			objA0.position.y.u16 += D1.u16
		}
	}
	D5 = 1
}

// Functions taken from objects\09_soz\soz_closingwall.lemon
//# address-hook(0x041be0) end(0x041c34)
function void fn041be0()
{
	D0.u16 = objA0.subtype2c & 0x0f
	A3 = 0xfffff7e0
	D0.u8 = u8[A3 + D0.s16]
	if (D0.u16 != u16[A0 + 0x36])
	{
		// If setting is active, the wall is opening too slowly without this speed-up
		s8 maxChange = (Game.getSetting(SETTING_FASTER_PUSH) && !original_mode) ? 2 : 1
		u16[A0 + 0x36] += clamp(s16(D0.u16 - u16[A0 + 0x36]), -maxChange, maxChange)
	}

	D0.u16 = u16[A0 + 0x36]
	if ((objA0.flags2a & 0x01) == 0)
	{
		D0.s16 = -D0.s16
	}
	D0.u16 += u16[A0 + 0x46]
	objA0.position.y.u16 = D0.u16

	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	fn01dc56()

	DrawOrUnloadObject()
}

//# address-hook(0x041c3a) end(0x041c70)
function void fn041c3a()
{
	D0.u16 = objA0.subtype2c & 0x0f
	A3 = 0xfffff7e0
	D0.u8 = u8[A3 + D0.s16]
	if (D0.u16 != u16[A0 + 0x36])
	{
		// If setting is active, the wall is opening too slowly without this speed-up
		s8 maxChange = (Game.getSetting(SETTING_FASTER_PUSH) && !original_mode) ? 2 : 1
		u16[A0 + 0x36] += clamp(s16(D0.u16 - u16[A0 + 0x36]), -maxChange, maxChange)
	}

	D0.u16 = u16[A0 + 0x36]
	if ((objA0.flags2a & 0x01) == 0)
	{
		D0.s16 = -D0.s16
	}
	D0.u16 += u16[A0 + 0x44]
	objA0.position.x.u16 = D0.u16

	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	fn01dc56()

	DrawOrUnloadObject()
}




// Disable flight assist and other Tails flight and AI changes in Original Mode.
// Functions taken from maingame\character\tails_ai.lemon
//# address-hook(0x0139cc) end(0x0139e8)
function void Character.TailsAI.Update()
{
	A1 = 0xffffb000		// Player 1

	// When player 2 presses any key, that disables the AI for 10 seconds
	if (control.tails.state & ~CONTROL_START)
	{
		tails.control_counter = 600		// 10 sec
	}

#if STANDALONE
	if (MODIFICATION_TOGETHERNESS && !original_mode)
	{
		if (Input.buttonPressed(BUTTON_PAD2 | BUTTON_Y) && tails.ai_routine == 0x06 && tails.ai_routine <= 0x06)
		{
			// Reset Tails next to Player 1
			u32 positionLookupAddress = 0xffffe500 + u32(u8(posbackup.offset.player1 - 20))

			char.render_flags = (char.render_flags & ~(render_flag.FLIP_X | render_flag.FLIP_Y)) | (objA1.render_flags & (render_flag.FLIP_X | render_flag.FLIP_Y))
			char.position.x.u16 = u16[positionLookupAddress]
			char.position.y.u16 = u16[positionLookupAddress + 2]
			char.velocity.x = objA1.velocity.x
			char.velocity.y = objA1.velocity.y
			char.groundspeed = objA1.groundspeed
			char.state = objA1.state
			char.rotation = u8[A1 + 0x26]
			char.rotation.x = u8[A1 + 0x27]
			char.flags = (char.flags & ~0x03) | (objA1.flags2a & 0x03)
			char.control_flags = u8[A1 + 0x2e]
			char.layer_flags1 = u8[A1 + 0x46]
			char.layer_flags2 = u8[A1 + 0x47]

			tails.ai_routine = 0x06
			tails.control_counter = 600		// 10 sec
		}
	}

	// This should only be called if SETTING_TAILS_ASSIST_MODE is active
	if (tails.ai_routine == 0x30)
	{
		if (updateTailsAssist())
			return

		// Return to usual behavior
		tails.ai_routine = 0x06
	}
#endif

	// Targets:
	//  - 0x013a10	-> tails.ai_routine = 0x00	-> Initialization (single frame)
	//  - 0x013b26	-> tails.ai_routine = 0x02	-> Respawn (can be a single frame)
	//  - 0x013bf8	-> tails.ai_routine = 0x04	-> Flying in
	//  - 0x013d4a	-> tails.ai_routine = 0x06	-> Normal state, controlled by player or AI
	//  - 0x013f40	-> tails.ai_routine = 0x08	-> Unknown
	//  - 0x013fc0	-> tails.ai_routine = 0x0a	-> Inactive (e.g. in AIZ Intro with Sonic & Tails, but not with Sonic alone)
	//  - 0x013fc2	-> tails.ai_routine = 0x0c	-> Unknown
	//  - 0x013ffa	-> tails.ai_routine = 0x0e	-> Flying Sonic in automatically (e.g. CNZ 1 start with Sonic & Tails)
	//  - 0x01408a	-> tails.ai_routine = 0x10	-> Flying away to disappear      (e.g. CNZ 1 start with Sonic alone)
	//  - 0x0140c6	-> tails.ai_routine = 0x12	-> Direct control in MGZ 2 boss, waiting (direct control by first player, used in MGZ 2 boss with Sonic)
	//  - 0x0140ce	-> tails.ai_routine = 0x14	-> Direct control in MGZ 2 boss, initialization
	//  - 0x014106	-> tails.ai_routine = 0x16	-> Direct control in MGZ 2 boss, entering the screen from below
	//  - 0x01414c	-> tails.ai_routine = 0x18	-> Direct control in MGZ 2 boss, now actually controllable
	//  - 0x0141f2	-> tails.ai_routine = 0x1a	-> Unknown (no code ported)
	//  - 0x01421c	-> tails.ai_routine = 0x1c	-> Unknown (no code ported)
	//  - 0x014254	-> tails.ai_routine = 0x1e	-> Unknown (no code ported)
	//  - 0x01425c	-> tails.ai_routine = 0x20	-> Unknown
	//  - 0x014286	-> tails.ai_routine = 0x22	-> Flying in automatically alone (e.g. CNZ 1 start with Tails alone)
	call tableLookupAddress(0x0139ec, tails.ai_routine)
}

function bool updateTailsAssist()
{
	if (!original_mode)
		return base.updateTailsAssist()
	else
		return false
}

// Functions taken from maingame\character\character.lemon
//# address-hook(0x0143ba) end(0x014520)
function void Tails.UpdateCarrySonic()
{
	// In all known cases, A1 and A2 are the same here:
	//  A1 = 0xffffb000  -> Player 1 object address
	//  A2 = 0xfffff73e  -> Address of "tails.carrying"

	if (u8[A2] == 0)
	{
		// Not carrying: Check if close enough to grab player 1
		Tails.CheckCatchSonic()
		return
	}

	if (u8[A1 + 0x05] < 0x04)
	{
		if ((objA1.flags2a & char.flag.IN_AIR) && (objA1.velocity.x == tails.carried_velocity_x))
		{
			if (tails.carried_velocity_y != objA1.velocity.y)
			{
				u8[A1 + 0x40] = 0
				u8[A1 + 0x2e] = 0
				u8[A2] = 0
				u8[A2+1] = 60
				return
			}

			if (s8[A1 + 0x2e] < 0)
			{
				u8[A2] = 0
				u8[A2+1] = 60
				return
			}

			bool jumpOff = (D0.u8 & CONTROL_ABC) != 0
			u16 catchTimeout = 60
		#if STANDALONE
			if (jumpOff && Game.getSetting(SETTING_TAILS_ASSIST_MODE) >= 2 && !original_mode)		// Hybrid & Mania style only
			{
				// Don't jump off unless Down is pressed as well
				jumpOff = ((D0.u16 >> 8) & CONTROL_DOWN) != 0

				// No catch timeout in Mania style, but holding Down will prevent the catch
				if (Game.getSetting(SETTING_TAILS_ASSIST_MODE) == 3)
					catchTimeout = 0
			}
		#endif
			if (!jumpOff)
			{
				objA1.position.x.u16 = char.position.x.u16
				objA1.position.y.u16 = char.position.y.u16 + (global.inv_gravity ? -0x1c : 0x1c)

				objA1.render_flags &= ~(render_flag.FLIP_X | render_flag.FLIP_Y)
				objA1.flags2a &= ~char.flag.FACING_LEFT
				D0.u8 = char.flags & char.flag.FACING_LEFT
				objA1.render_flags |= D0.u8
				objA1.flags2a |= D0.u8
				if (global.inv_gravity)
					objA1.render_flags ^= render_flag.FLIP_Y

				--u8[A1 + 0x24]
				if (s8[A1 + 0x24] < 0)
				{
					u8[A1 + 0x24] = 0x0b
					D1 = u8[A1 + 0x23]
					D0.u8 = u8[0x014522 + D1.s16]
					if (D0.u8 == 0xff)
					{
						u8[A1 + 0x23] = 0
						D0.u8 = u8[0x014522]
					}
					else
					{
						++u8[A1 + 0x23]
					}
					u8[A1 + 0x22] = D0.u8
					D0 = u8[A1 + 0x22]

					u32 backupA2 = A2
					SetCharacterSpritePatterns()
					A2 = backupA2
				}

				s16[0xffffb000 + 0x18] = char.velocity.x
				s16[0xffffb000 + 0x1a] = char.velocity.y
				tails.carried_velocity_x = char.velocity.x
				tails.carried_velocity_y = char.velocity.y

				pushAll()
				A0 = 0xffffb000
				Character.CheckCollision()
				popAll()
			}
			else
			{
				// Jumping off
				u8[A1 + 0x2e] = 0
				u8[A2] = 0

				if (D0.u16 & 0x0f00)	// Any direction held?
				{
					u8[A2+1] = catchTimeout

					if (D0 & 0x0400)	// CONTROL_LEFT held
						objA1.velocity.x = -0x200
					if (D0 & 0x0800)	// CONTROL_RIGHT held
						objA1.velocity.x = 0x200
				}
				else
				{
					u8[A2+1] = 18
				}

				objA1.velocity.y = -0x380		// TODO: Should Knuckles have a different jump acceleration here?
				u8[A1 + 0x1e] = 0x0e
				u8[A1 + 0x1f] = 0x07
				u8[A1 + 0x20] = char.state.ROLLING
				objA1.flags2a |= (char.flag.IN_AIR | char.flag.ROLLING)
				objA1.flags2a &= ~char.flag.CONTROL_LOCK
				u8[A1 + 0x40] = 0x01

			#if STANDALONE
				playSound(SFX_JUMP)
			#endif
			}
			return
		}

		objA1.velocity.y = -0x100
		u8[A1 + 0x40] = 0
	}

	u8[A1 + 0x2e] = 0
	u8[A2] = 0
	u8[A2+1] = 60
}

function bool onCharacterPressedJumpInMidAir(u8 input_state, u8 input_pressed)
{
	// The following is only relevant for first player if having Tails as second character
	if (A0 == 0xffffb000 && isSecondCharacter(CHARACTER_TAILS) && L_TailsAssist != 1)	// a value of 1 represents only the L button may trigger Tails Assist
		return checkStartTailsAssist(input_state)

	// Use normal jump button reaction
	return true
}

// We make this its own function so we can also access it with the L button
function bool checkStartTailsAssist(u8 input_state)
{
	// Start Tails Assist flight?
	if (Game.getSetting(SETTING_TAILS_ASSIST_MODE) != 0 && ((input_state & CONTROL_UP) || Input.buttonPressed(BUTTON_L)) && !original_mode)
	{
		// Tails must be AI controlled and not too far away
		s16 dx = s16[0xffffb04a + 0x10] - s16[0xffffb000 + 0x10]
		s16 dy = s16[0xffffb04a + 0x14] - s16[0xffffb000 + 0x14]
		if (tails.control_counter == 0 && tails.ai_routine == 0x06 && abs(dx) < 0xc0 && abs(dy) < 0x80)
		{
			// Tails must not already be flying already, and ready for flying
			bool startFlight = false
			if (u8[0xffffb04a + 0x20] == char.state.ROLLING && u8[0xffffb04a + 0x40] == 1)	// char.jumping must be set
			{
				startFlight = true
			}

			// Alternatively, Tails can be standing or running and ready to jump
			else if ((u8[0xffffb04a + 0x2a] & char.flag.IN_AIR) == 0)
			{
				A0 = 0xffffb04a
				control.tails.pressed |= CONTROL_ABC
				if (Character.CheckStartJump())
				{
					tails.ai_routine = 0x30		// No valid value in vanilla, but we're using it for the Tails Assist flight routine
					tails_assist.trigger_countdown = 8	// Hold jump button for 8 frames before triggering flight
				}
				A0 = 0xffffb000
			}

			if (startFlight)
			{
				A0 = 0xffffb04a
				TailsStartFlight()
				char.velocity.y = max(char.velocity.y, -0x200)	// Limit Tails' velocity
				tails.ai_routine = 0x30		// No valid value in vanilla, but we're using it for the Tails Assist flight routine
				tails_assist.trigger_countdown = 0
				tails.catch_timeout = 0
				A0 = 0xffffb000

				if (Input.buttonPressed(BUTTON_L))
					return false	// no need to prevent jump button action if L was used
				// No further reaction to jump button if:
				//  - it would activate the fire or bubble shield
				//  - Knuckles would start gliding
				bool preventAction = false
				if (isMainCharacter(CHARACTER_SONIC))
				{
					preventAction = (char.bonus_effect & (char.bonus.SHIELD_FIRE | char.bonus.SHIELD_BUBBLE)) != 0 && (char.bonus_effect & char.bonus.INVINCIBLE) == 0 && !super.active
				}
				else if (isMainCharacter(CHARACTER_KNUCKLES))
				{
					preventAction = (abs(char.velocity.x) < 0x100)
				}
				return !preventAction
			}
		}
	}
	return true
}

function bool UpdateTailsFlight_innerA()
{
	// Flight countdown
	if (level.framecounter.low & 0x01)
	{
		if (tails.flight_countdown > 0)
			--tails.flight_countdown
	}

	bool canAscend = (char.velocity.y >= -0x100 && tails.flight_countdown > 0 && ((char.flags & char.flag.UNDERWATER) == 0 || !tails.carrying))

#if STANDALONE
	// Allow for holding [up] to gain height
	if ((control.tails.state & CONTROL_UP) && !original_mode && canAscend && char.velocity.y >= -0xf8)
	{
		char.double_jump_state = 0x1f
	}

	// Cancel flight ("Tails Drop"): Stop flying and roll into a ball again
	else if (Game.getSetting(SETTING_CANCEL_FLIGHT) && !original_mode && (control.tails.state & CONTROL_DOWN) && (control.tails.state & CONTROL_ABC))
	{
		char.double_jump_state = 0
		char.state = char.state.ROLLING
		char.jumping = 0			// Clear this flag to prevent a new flight while falling

		Tails.CheckDropSonic()
		updateTailsInAir_shared()
		return false
	}
#endif

	// For Tails' flight, char.double_jump_state is 1 or higher
	//  -> If you don't do anything, it stays 1
	//  -> Press jump to fly higher, and it starts counting up until 0x20, as a timer for the upwards flight effect
	if (char.double_jump_state != 1)
	{
		if (char.velocity.y >= -0x100)
		{
			// Fly up
			char.velocity.y -= 0x20

			++char.double_jump_state
			if (char.double_jump_state == 0x20)
			{
				char.double_jump_state = 1
			}
		}
		else
		{
			char.double_jump_state = 1
		}
	}
	else
	{
		if ((control.tails.pressed & CONTROL_ABC) && canAscend)
		{
			char.double_jump_state = 2
		}

		// Reduced gravity effect during flight (8 instead of 0x38)
		char.velocity.y += 8
	}

	if (s16(char.position.y.u16) <= s16(level.vertical_wrap + 0x10))
	{
		if (char.velocity.y < 0)
			char.velocity.y = 0
	}
	return true
}

// Also enforces jump button transformations in Original Mode
function void TailsPressedJumpInMidAir()
{
	if (original_mode || Input.buttonPressed(BUTTON_Y))
	{
		if (Character.performSuperTransformation())
			return
	}

	// Don't start to fly if that would be aborted right away (this could be solved differently, of course)
	if (Game.getSetting(SETTING_CANCEL_FLIGHT) && !original_mode && (control.tails.state & CONTROL_DOWN))
		return

	// Tails is manually controlled?
	if (isMainCharacter(CHARACTER_TAILS) || tails.control_counter != 0)
	{
		TailsStartFlight()
	}
#if STANDALONE
	// Make an exception for AI Tails, e.g. on MHZ 1 (Sonic alone) start when Sonic jumps off early
	else if (tails.ai_routine == 0x10)
	{
		TailsStartFlight()
	}
#endif
}

function void KnucklesPressedJumpInMidAir()
{
	if (original_mode || Input.buttonPressed(BUTTON_Y))
	{
		if (Character.performSuperTransformation())
			return
	}
	
	base.KnucklesPressedJumpInMidAir()
}

//# address-hook(0x0148ac)
function void UpdateTailsFlight_innerB()
{
	if (char.flags & char.flag.UNDERWATER)
	{
		// Swimming
		if (tails.flight_countdown == 0)
		{
			// Tired
		#if STANDALONE
			// Use proper animation when both exhausted and carrying Sonic at the same time underwater, #contributed by mrgrassman14
			if (tails.carrying && !original_mode)
			{
				char.state = char.state.TAILS_SWIMCARRY
			}
			else
		#endif
			{
				char.state = char.state.TAILS_SWIMTIRED
			}
		}
		else
		{
			// Not tired
			if (tails.carrying)
			{
				char.state = char.state.TAILS_SWIMCARRY
			}
			else
			{
				char.state = (char.velocity.y < 0) ? char.state.TAILS_SWIMUP : char.state.TAILS_SWIMDOWN
			}
		}
	}
	else
	{
		// Flying
		if (competition_mode.active)
		{
			// Not really clear why this is here, competition mode Tails doesn't seem to even use this function
			char.state = char.state.TAILS_FLYDOWN
		}
		else
		{
			if (tails.flight_countdown == 0)
			{
				char.state = char.state.TAILS_FLYTIRED
			}
			else if (tails.carrying)
			{
				char.state = (char.velocity.y < 0) ? char.state.TAILS_CARRYUP : char.state.TAILS_CARRYDOWN
			}
			else
			{
				char.state = (char.velocity.y < 0) ? char.state.TAILS_FLYUP : char.state.TAILS_FLYDOWN
			}
		}

		if (char.render_flags & render_flag.VISIBLE)
		{
			if (((level.framecounter.low + 8) & 0x0f) == 0)
			{
				playSound((char.state == char.state.TAILS_FLYTIRED) ? 0xbb : 0xba)
			#if STANDALONE
				Input.setControllerRumbleByAddress(A0, 0.0f, 0.1f, 150)
			#endif
			}
		}
	}
}



// Do not allow canceling Super/Hyper transformations in Original Mode.
// Also prevent playing level music while in win pose (e.g., invincibility wears off).
// Reload lightning shield sparks after cancellation in Sonic 2 acts.
// Function taken from maingame\character\character.lemon
function void Character.updateBonusEffects()
{
#if STANDALONE
	// Super Cancel
	if (Game.getSetting(SETTING_SUPER_CANCEL) && !original_mode && Input.buttonPressed(BUTTON_Y))
	{
		bool isSuperActive = (char.character == CHARACTER_TAILS) ? super.active.tails : super.active
		u8 transformingState = (char.character == CHARACTER_TAILS) ? char.state.TAILS_TRANSFORM : char.state.TRANSFORMING
		if (isSuperActive && char.state != transformingState)
		{
			// Not in Doomsday and not in Sonic's AIZ intro
			if (global.zone_act != 0x0c00 && (char.control_flags & 0x40) == 0)
			{
				Character.cancelSuperTransformation()	// there is actually some code that should be modified here for Original Mode to reintroduce a soft lock and award another frame of invincibility, but AIR needs that frame gone to set music properly
				// If lightning shield is active in a Sonic 2 act, reload sprite patterns for the sparks. The above function handles this for S3&K acts.
				if (u32[0xffffcce8] == 0x019732 && unlock_act)
				{
					updateSpritePattern(0x34e402, 0xf760, 0x50)
				}
				chooseFittingMusic()
				char.jumping = 0		// Do not allow another transformation until hit the ground
			}
		}
	}
#endif

	bool doRender = true
	if (char.invuln.countdown > 0)
	{
		doRender = ((char.invuln.countdown & 0x04) != 0)
		--char.invuln.countdown
	}
	if (doRender)
	{
		DrawObject()
	}

	if ((char.bonus_effect & char.bonus.INVINCIBLE) && char.invinc.countdown > 0)
	{
		if ((level.framecounter & 0x07) == 0)
		{
			--char.invinc.countdown
			if (char.invinc.countdown == 0)
			{
				// Back to normal
				if (!level.boss_encounter && char.drown_countdown >= 12 && u8[0xffffb020] != char.state.WIN_POSE)
				{
					playMusic(level.default_music)
				}
				char.bonus_effect &= ~char.bonus.INVINCIBLE

				if (!original_mode)
				{
					// Half a second of extra invincibility
					char.invuln.countdown = max(char.invuln.countdown, 60)
				}
				// If lightning shield is active in a Sonic 2 act, reload sprite patterns for the sparks. This is a non-issue in S3&K due to different VRAM locations.
				if (u32[0xffffcce8] == 0x019732 && unlock_act)
				{
					updateSpritePattern(0x34e402, 0xf760, 0x50)
				}
			}
		}
	}

	if ((char.bonus_effect & char.bonus.SPEED_UP) && char.speedup.countdown > 0)
	{
		if ((level.framecounter & 0x07) == 0)
		{
			--char.speedup.countdown
			if (char.speedup.countdown == 0)
			{
				char.bonus_effect &= ~char.bonus.SPEED_UP

				if (char.character != CHARACTER_KNUCKLES && competition_mode.active)
				{
					A1 = 0x1e3c00 + (char.character * 8)
					u16[A4] = u16[A1]
					u16[A4+2] = u16[A1+2]
					u16[A4+4] = u16[A1+4]
				}
				else
				{
					setSpeedCapProperties(A4)
					changeMusicTempo(0)
				}
			}
		}
	}
}




// Do not allow a transformation for Tails if he only has Chaos Emeralds in Original Mode.
// Function taken form maingame\character\character.lemon
function bool Character.performSuperTransformation()
{
	// Already super?
	if (super.active)
		return false
	if (!original_mode && !Input.buttonPressed(BUTTON_Y))	// safety check at this point, as recent updates have put this check just before any call to this function as well.
		return false

	u8 possibleSuperForm = 0	// 1 for Super, 2 for Hyper

	// Tails is first player?
	if (char.character == CHARACTER_TAILS)
	{
		if (!isMainCharacter(CHARACTER_TAILS))
			return false

		if (super.active.tails)
			return false
	}

	// Special handling for Tails
	if (char.character == CHARACTER_TAILS && (original_mode || !Game.getSetting(SETTING_HYPER_TAILS)))
	{
		// Ready to get Super Tails?
		if (global.super_emeralds >= 7)
		{
			possibleSuperForm = 2
		}
	}
	else
	{
		// Can go super?
		if (global.super_emeralds >= 7)
		{
			possibleSuperForm = 2
		}
		else if (global.chaos_emeralds >= 7 && global.traded_emeralds == 0)
		{
			possibleSuperForm = 1
		}
	}

	if (possibleSuperForm == 0)
		return false

	// Check requirements
	if (ring_counter < 50 || !hud.dirty.timer || char.control_flags != 0)	// Last check is needed e.g. for the snowboarding section
		return false

	if (char.character == CHARACTER_SONIC)
	{
		char.mapping_offset = 0x146816
		char.state = char.state.TRANSFORMING

		if (possibleSuperForm == 2)
		{
			super.active = 0xff
			u32[0xffffcd7c] = 0x019348		// Hyper Sonic stars
			u32[0xffffcbc0] = 0x01a494		// After-images effect
		}
		else
		{
			super.active = 1
			u32[0xffffcbc0] = 0x019156		// Super Sonic stars
		}
	}
	else if (char.character == CHARACTER_TAILS)
	{
		super.active.tails = 1
		char.state = char.state.TAILS_TRANSFORM

		if (possibleSuperForm == 2)
		{
			// Call the flicky army of death
			u32[0xffffcd7c] = 0x01a170		// Super Flickies (the first one spawns the others)

		#if STANDALONE
			super.active.tails = 0xff
		#endif
		}
	}
	else if (char.character == CHARACTER_KNUCKLES)
	{
		char.state = char.state.TRANSFORMING

		if (possibleSuperForm == 2)
		{
			super.active = 0xff
			u32[0xffffcbc0] = 0x01a494		// After-images effect
		}
		else
		{
			super.active = 1
			u32[0xffffcbc0] = 0x019156		// Super Knuckles stars
		}
	}

#if STANDALONE
	if (super.active == 0xff)
	{
		// Stop drowning music
		if (char.drown_countdown < 12)
		{
			playMusic(MUSIC_CTRL_FADEOUT)
		}

		// Reset drowning countdown
		char.drown_countdown = 30
	}
#endif

	super.palettefx.state = 1
	super.palettefx.timer = 0x0f
	super.ring_dec.frames = 60
	char.control_flags = 0x81

	setSpeedCapProperties(A4)

	char.invinc.countdown = 0
	char.bonus_effect |= char.bonus.INVINCIBLE

	playSound(SFX_SUPERTRANSFORM)
	if (!original_mode)
		chooseFittingMusic()	// Usually switches to super theme
	else
		playMusic(MUSIC_INVINCIBLE)

#if STANDALONE
	if (super.active == 0xff || super.active.tails == 0xff)
	{
		Game.setAchievementComplete(ACHIEVEMENT_GOING_HYPER)
	}
#endif
	return true
}





// In Original Mode, let Knuckles revert to a particular animation frame if he remains still on a wall.
// Also reintroduces climbing in midair if shoved by an object in Original Mode.
// Function taken form maingame\character\character.lemon
//# address-hook(0x016e10)
function void fn016e10()
{
	D0.u8 = control.player1.state & (CONTROL_UP | CONTROL_DOWN)
	if (D0.u8 == 0)
	{
		if (!original_mode)
		{
			// Check if Knuckles is hanging in mid-air, e.g. after he got pushed down by a moving object (like a HCZ pillar)
			D2.u16 = char.position.y.u16 + (global.inv_gravity ? -11 : 11)
			fn016f4e()
			if (D1.s16 != 0)
			{
				fn016ed2()
				return
			}
		}

		D5.u8 = char.layer_flags1
		D2.u16 = char.position.y.u16 + 9
		D3.u16 = char.position.x.u16
		fn00f828()
		if (D1.s16 < 0)
		{
			fn016d6e()
			return
		}

		if (!original_mode)
		{	// This fixes an animation bug when Knuckles is on a wall, but very close to the ground
			D1.s16 = 0
		}
	}

	if (D1.s16 != 0)
	{
		--knuckles.glide_direction
		if (s8(knuckles.glide_direction) < 0)
		{
			knuckles.glide_direction = 3

			D1.u8 += char.animation.sprite
			if (D1.u8 < 0xb7)
				D1.u8 = 0xbc
			if (D1.u8 > 0xbc)
				D1.u8 = 0xb7
			char.animation.sprite = D1.u8

//			if (!original_mode)
//			{
			// Fix for an animation bug
				char.state = char.state.KNUX_FLYCLIMB
//			}
		}
	}

	fn016e60()
}






// Enforce roll jump lock in Original Mode.
// Function taken from maingame\character\character.lemon
//# translated(0x0117da) end(0x0118ba)
//# translated(0x015002) end(0x0150d8)
//# translated(0x017710) end(0x0177e8)
function bool Character.CheckStartJump()
{
	u8 input_pressed = (char.character == CHARACTER_TAILS) ? control.tails.pressed : control.player1.pressed
	if ((input_pressed & CONTROL_ABC) == 0)
		return false

	D0 = char.rotation
	if (global.inv_gravity)
	{
		D0.s8 = -D0.s8
	}
	else
	{
		D0.s8 += 0x80
	}

	pushA456()
	fn00f72e()
	popA456()

	if (D1.s16 < 6)
		return false

	// Get jump acceleration depending on character
	u16 acceleration
	if (char.character != CHARACTER_KNUCKLES || competition_mode.active)
	{
		if (char.flags & char.flag.UNDERWATER)
		{
			acceleration = 0x380
		}
		else if (super.active && char.character == CHARACTER_SONIC)
		{
			acceleration = 0x800
		}
		else
		{
			acceleration = 0x680
		}
	}
	else
	{
		if (char.flags & char.flag.UNDERWATER)
		{
			acceleration = 0x300
		}
		else
		{
			acceleration = 0x600
		}
	}

	u8 angle = char.rotation - 0x40
	s32 accel_x = (s32(lookupCos(angle)) * acceleration) >> 8
	s32 accel_y = (s32(lookupSin(angle)) * acceleration) >> 8

	char.velocity.x += accel_x
	char.velocity.y += accel_y

	char.flags |= char.flag.IN_AIR
	char.flags &= ~char.flag.PUSHING

	char.jumping = 1
	char.on_convex_surface = 0

	playSound(SFX_JUMP)

	// Start roll jump
	if (char.flags & char.flag.ROLLING)
	{
	#if STANDALONE
		if (!Game.getSetting(SETTING_NO_CONTROL_LOCK) || original_mode)
	#endif
		{
			char.hitbox_extends.x = char.hitbox.default.x
			char.hitbox_extends.y = char.hitbox.default.y
			char.flags |= char.flag.CONTROL_LOCK
		}
	}
	else
	{
		char.hitbox_extends.x = 7
		char.hitbox_extends.y = 14
		char.flags |= char.flag.ROLLING
		char.state = char.state.ROLLING

		s8 dy = s8(char.hitbox_extends.y) - s8(char.hitbox.default.y)
		char.position.y.u16 += global.inv_gravity ? dy : -dy

	#if STANDALONE
		// Glitch fix for Knuckles being unable to jump off underwater objects
		//  -> Move him up a single pixel up so he won't stick to objects
		// TODO: Does not work for the HCZ snake platforms
		if (acceleration <= 0x300 && (char.flags & char.flag.ON_OBJECT))
		{
			--char.position.y.u16
		}
	#endif
	}
	return true
}










// Do not use the peelout run animation in Original Mode.
// Function taken from maingame\character\character.lemon
//# address-hook(0x010bba) end(0x010c8e)
function void Character.UpdateNormalState.Sonic()
{
	if (updateDebugModeInput(false))
		return

	if (player1.control_override == 0)
	{
		// Set player 1 control state
		control.player1 = control.pad1
	}

	if (char.control_flags & 0x01)
	{
		// Character is not directly controllable (but may be indirectly via an object, like when hanging on a pole or similar)
		char.double_jump_state = 0
	}
	else
	{
		// Call update function depending on flags
		pushA456()
		// Targets:
		//  - 0x010f2c	-> (char.flags & (char.flag.IN_AIR | char.flag.ROLLING)) = 0x00												-> Character.UpdateSonicUprightOnGround()
		//  - 0x010fb6	-> (char.flags & (char.flag.IN_AIR | char.flag.ROLLING)) = char.flag.IN_AIR									-> Character.UpdateSonicUprightInAir()
		//  - 0x010fe0	-> (char.flags & (char.flag.IN_AIR | char.flag.ROLLING)) = char.flag.ROLLING								-> Character.UpdateSonicRollingOnGround()
		//  - 0x011036	-> (char.flags & (char.flag.IN_AIR | char.flag.ROLLING)) = (char.flag.IN_AIR | char.flag.ROLLING)			-> Character.UpdateSonicRollingInAir()
		call tableLookupAddress(0x010c90, char.flags & (char.flag.IN_AIR | char.flag.ROLLING))
		popA456()
	}

#if STANDALONE
	if (sonic_moves && !competition_mode.active)
	{
		if (sonic.dropdash_counter > 0)
		{
			// Check if hit the ground with drop dash charged
			if ((sonic.dropdash_counter == DROPDASH_FULLCHARGE) && (char.flags & char.flag.IN_AIR) == 0)
			{
				if (char.state != char.state.WIN_POSE)		// This check is only needed for drop dash vs. win pose after FBZ 2 boss
				{
					releaseDropDash()
				}
				else
				{
					// Abort drop dash (e.g. when jumping on a spring)
					sonic.dropdash_counter = 0
				}
			}
			else
			{
				u8 expectedState = (sonic.dropdash_counter < DROPDASH_FULLCHARGE) ? char.state.ROLLING : char.state.SONIC_DROPDASH
				if (char.state != expectedState)
				{
					// Abort drop dash (e.g. when jumping on a spring)
					sonic.dropdash_counter = 0
				}
			}
		}
	}

	if (Game.getSetting(SETTING_SUPERFAST_RUNANIM) && !super.active && abs(char.groundspeed) >= 0x0d00 && !original_mode)
	{
		sonic.fastrunanim.timer = 30
	}
	else if (sonic.fastrunanim.timer > 0)
	{
		if (abs(char.groundspeed) >= 0x0800)
			--sonic.fastrunanim.timer
		else
			sonic.fastrunanim.timer = 0
	}
#endif

	if (level.vertical_wrap == 0xff00)
	{
		char.position.y.u16 &= level.height.bitmask
	}

	Character.updateBonusEffects()
	Character.UpdateRingsInSuperForm()
	Character.WriteToPositionBackup()
	Character.checkForWaterSurface()

	char.angle_sensor_1 = u8[0xfffff768]
	char.angle_sensor_2 = u8[0xfffff76a]

	if (u8[0xfffff7c8] != 0)
	{
		if (char.state == char.state.RUNNING)
			char.state = char.state.former
	}

	if ((char.control_flags & 0x02) == 0)	// Hanging flag
	{
		UpdateSonicAnimation()
		if (global.inv_gravity)
		{
			char.render_flags ^= render_flag.FLIP_Y
		}
		UpdateSonicSpritePatterns()
	}

	if ((char.control_flags & 0xa0) == 0)
	{
		Character.CheckCollisionsWithDynamicObjects()
	}
}



// Do not muffle audio underwater or fix Knuckles's bubble location in Original Mode.
// Also fix a quirk with resetting the drowning countdown outside of Original Mode
// and implement CPZ damaging water.
// Function taken from maingame\character\underwater_update.lemon
//# address-hook(0x018466) end(0x018680)
function void fn018466()
{
	A2 = u32[A0 + 0x40]
	#if GAMEAPP
		if (A2 == 0xffffb000 && u8[0xffffb000 + 0x05] <= 0x04)
		{
			if (Game.getSetting(SETTING_UNDERWATER_AUDIO) && !original_mode)
			{
				s16 diff = s16[0xffffb000 + 0x14] - s16(water.height.current)
				Game.setUnderwaterAudioEffect(clamp(diff - 8, 0, 64) * 0xff / 64)
			}
			else
			{
				Game.setUnderwaterAudioEffect(0)
			}
		}
	#endif

	bool doChecks = true

	// Outside of Original Mode, reset the frames counter for the drowning countdown too, not just the seconds counter.
	// Without this reset, the player can get up to 30 seconds and 59 frames of time underwater.
	u16 drowningFrames = u16[A0 + 0x3c]		// store the frames counter
	if (!original_mode)
		u16[A0 + 0x3c] = 0					// set it to zero so early exits to this function don't maintain the value

	if (u16[A0 + 0x30] == 0)
	{
		// Character died?
		if (u8[A2 + 0x05] >= 0x06)
			return

		// Protected by bubble shield?
		if (u8[A2 + 0x2b] & char.bonus.SHIELD_BUBBLE)
			return

	#if STANDALONE
		// Hyper form active?
		if (u8[A2 + 0x38] == CHARACTER_TAILS && !original_mode)
		{
			if (super.active.tails & 0x80)
				return
		}
		else
	#endif
		{
			if (super.active & 0x80)
				return
		}

		// Left the water?
		if ((u8[A2 + 0x2a] & char.flag.UNDERWATER) == 0)
			return

		u16[A0 + 0x3c] = drowningFrames

		// Decrease the drown countdown
		--u16[A0 + 0x3c]
		// Knux CPZ water and time to lose a ring (every half-second), but not invulnerable/invincible/super
		if (s16[A0 + 0x3c] % 30 == 0 && A2 == 0xffffb000 && layout.part == 2 && !u8[A2 + 0x34] && !(u8[A2 + 0x2b] & char.bonus.INVINCIBLE) && !super.active)
		{
			if (ring_counter == 0)
			{
				u32 backupA0 = A0
				A0 = A2
				Character.Die()
				A0 = backupA0
			}
			else
			{
				D0.u16 = ring_counter - 1
				if (D0.u16 == 0 || ring_counter == 10 || ring_counter == 100)
				{
					hud.dirty.rings |= 0x80
				}
				ring_counter = D0.u16
				hud.dirty.rings |= 0x01
				playSound(0x64)	// SFX_HITSPIKES instead?
			}
		}


		if (s16[A0 + 0x3c] < 0)
		{
			u16[A0 + 0x3c] = 0x3b
			u16[A0 + 0x3a] = 0x01
			objA0.flags38 = (getRandomNumber() & 0x01)

			D0 = u8[A2 + 0x2c]
			if (D0.u16 != 0x0f && D0.u16 != 0x14 && D0.u16 != 0x19)
			{
				if (D0.u16 <= 0x0c)
				{
					if (D0.u16 == 0x0c && u8[A0 + 0x43] == 0)
					{
						playMusic(MUSIC_DROWNING)
					}

					--u8[A0 + 0x36]
					if (s8[A0 + 0x36] < 0)
					{
						u8[A0 + 0x36] = u8[A0 + 0x37]
						objA0.value3a |= 0x80
					}
				}
			}
			else
			{
				if (u8[A0 + 0x43] == 0)
				{
					playSound(SFX_UNDERWATER_BELL)
				}
			}

			--u8[A2 + 0x2c]
			if (s8[A2 + 0x2c] < 0)
			{
				// Drowned
				u8[A2 + 0x2e] = 0x81
				playSound(SFX_DROWN)

				objA0.flags38 = 0x0a
				u16[A0 + 0x3a] = 0x01
				u16[A0 + 0x30] = 0x78

				A1 = A2
				UpdateMusicOnWaterTransition()
				u32 backupA0 = A0

				A0 = A2
				Character.LandingOnGroundNoSpindash()

				objA0.state = char.state.DROWNED
				objA0.flags2a |= 0x02
				u8[A0 + 0x0a] |= 0x80
				objA0.velocity.y = 0
				objA0.velocity.x = 0
				s16[A0 + 0x1c] = 0
				objA0.base_state = 0x0c
				A0 = backupA0
				if (A2 == 0xffffb000)
				{
					u8[0xffffee30] = 1
				}
				return
			}
			else
			{
				doChecks = false
			}
		}
	}
	else
	{
		u8[A2 + 0x20] = char.state.DROWNED
		--u16[A0 + 0x30]
		if (u16[A0 + 0x30] == 0)
		{
			u8[A2 + 0x05] = 0x06
			return
		}
	}

	if (doChecks)
	{
		if (u16[A0 + 0x3a] == 0)
			return

		--objA0.value3e
		if (s16[A0 + 0x3e] >= 0)
			return
	}

	objA0.value3e = 8 + (getRandomNumber() & 0x0f)
	if (allocDynamicObjectStd())
	{
		objA1.update_address = objA0.update_address
		objA1.position.x.u16 = u16[A2 + 0x10]
		D0 = 6
		if (u8[A2 + 0x2a] & char.flag.FACING_LEFT)
		{
			D0.s16 = -D0.s16
			u8[A1 + 0x26] = 0x40
		}
		objA1.position.x.u16 += D0.u16
		objA1.position.y.u16 = u16[A2 + 0x14]
	#if STANDALONE
		// Moves Knuckles' respiratory system back into his mouth, #contributed by iCloudius
		if (u8[A2 + 0x38] == CHARACTER_KNUCKLES && !original_mode)
			objA1.position.y.u16 -= 5
	#endif
		u32[A1 + 0x40] = u32[A0 + 0x40]
		u8[A1 + 0x2c] = 6
		if (u16[A0 + 0x30] != 0)
		{
			objA0.value3e &= 0x07
			D0.u16 = u16[A2 + 0x14] - 12
			objA1.position.y.u16 = D0.u16
			u8[A1 + 0x26] = getRandomNumber()
			D0.u16 = level.framecounter & 0x03
			if (D0.u8 == 0)
			{
				u8[A1 + 0x2c] = 0x0e
			}
		}
		else
		{
			if (objA0.value3a & 0x80)
			{
				D2 = u8[A2 + 0x2c]
				if (D2.u8 < 0x0c)
				{
					D2.u16 >>= 1
					D0.u16 = getRandomNumber() & 0x03
					if (D0.u16 == 0)
					{
						if ((objA0.value3a & 0x40) == 0)
						{
							objA0.value3a |= 0x40
							u8[A1 + 0x2c] = D2.u8
							u16[A1 + 0x3c] = 28
						}
					}
					if (objA0.flags38 == 0)
					{
						if ((objA0.value3a & 0x40) == 0)
						{
							objA0.value3a |= 0x40
							u8[A1 + 0x2c] = D2.u8
							u16[A1 + 0x3c] = 28
						}
					}
				}
			}
		}

		--objA0.flags38
		if (s8[A0 + 0x38] < 0)
			u16[A0 + 0x3a] = 0
	}
}




// Do not show hints for hidden monitors in Original Mode,
// and show hints correctly in unlockable acts.
// Function taken from objects\basics\signpost.lemon
//# address-hook(0x083708) end(0x083798)
function void fn083708()
{
	// Check for signpost hit
	if (level.signpost.address != 0)
	{
		A1 = 0xffff0000 + level.signpost.address
		if (objA1.update_address == 0x0837b2)
		{
			u16 px = objA1.position.x.u16
			u16 py = objA1.position.y.u16

			A2 = 0x08379e
			u16 minX = objA0.position.x.u16 + u16[(A2+=2)-2]
			u16 maxX = minX + u16[(A2+=2)-2]
			u16 minY = objA0.position.y.u16 + u16[(A2+=2)-2]
			u16 maxY = minY + u16[(A2+=2)-2]

			if (px >= minX && px < maxX)
			{
				if (py >= minY && py < maxY && (objA1.flags38 & 0x01))
				{
					objA1.flags38 &= ~0x01

					objA0.update_address = 0x01d566		// Make this a real monitor
					objA0.base_state = 0x02
					u8[A0 + 0x3c] = 0x04
					objA0.velocity.y = -0x500
				#if STANDALONE
					if (objA0.state == 0x0b)	// Classic Shield's state is not completely supported
						objA0.state = 0x05
				#endif

					playSound(SFX_BUBBLEBOUNCE)

					if (objA0.render_flags & render_flag.FLIP_X)
					{
						objA0.render_flags &= ~render_flag.FLIP_X
						objA0.sprite_attributes |= sprite_attribute.PRIORITY
						objA0.flags2a = 0
					}

					DrawOrUnloadObject()
					return
				}
			#if STANDALONE
				else if (objA1.velocity.x != 0)
				{
					// Only needed for the hint
					u8 maximum = 0x50 + abs(s8(global.framecounter & 0x1f) - 0x10) * 0x02
					u8[A0 + 0x49] = min(u8[A0 + 0x49] + 4, maximum)
				}
			#endif
			}
			else
			{
				bool unload = (objA1.flags38 & 0x01)
			#if STANDALONE
				if (!original_mode)
				{
					// As a bug fix, also check "countdown_value" to make sure it's not the exact frame where the signpost hit the ground, but a later one
					//  -> Otherwise hidden monitors can get locked too early
					unload = unload && (s16[A1 + 0x2e] < 0x40)

					// Only needed for the hint
					u8[A0 + 0x49] = (u8[A0 + 0x49] > 4) ? (u8[A0 + 0x49] - 4) : 0
				}
			#endif

				if (unload)
				{
					// Signpost touched ground without hitting a monitor
					playSound(0x7e)
					objA0.update_address = 0x01b588		// Address of "DrawOrUnloadObject"
					if (unlock_act)
						objA0.update_address = 0x08370a	// dummy address for renderhooking
				}
			}

		#if STANDALONE
			if (Game.getSetting(SETTING_HIDDEN_MONITOR_HINT) && u8[A0 + 0x49] > 0x20 && !original_mode)
			{
				// Draw a hint
				px = objA0.position.x.u16 - camera.foreground.x.u16 - 0x10
				py = objA0.position.y.u16 - camera.foreground.y.u16 - 0x10
				Renderer.drawVdpSpriteWithAlpha(px, py, 0x0f, sprite_attribute.PRIORITY | 0x04c4, 0xd000, u8[A0 + 0x49] - 0x20)
			}
		#endif
		}
	}

	CheckForUnloadObject()
}

//# address-hook(0x08370a)
function void HiddenMonitor.RenderS2Hint()
{
	DrawOrUnloadObject()	// adding this to the drawn object queue allows the renderhook to draw over it
}




// Add more leniency to the camera check for ICZ1's first sliding ice platform.
// Also allow vertical wrapping in Original Mode.
// Function taken from general\camera.lemon
//# address-hook(0x01c11e) end(0x01c236)
function void UpdateCameraPositionY()
{
	D0.s16 = char.position.y.u16 - u16[A1]
	if (level.vertical_wrap == 0xff00)
	{
		D0.s16 &= level.height.bitmask
	}
	if (char.flags & char.flag.ROLLING)
	{
	#if STANDALONE
		// Accounting for Tails` smaller rolling box. see: https://s3unlocked.blogspot.com/2017/12/roll-height-bugs-part-1.html
		D0.s16 -= (char.character == CHARACTER_TAILS && !original_mode) ? 1 : 5
	#else
		D0.s16 -= 5
	#endif
	}

	#if STANDALONE
		// Prevent the infamous level wrap glitch
		if (Game.getSetting(SETTING_FIX_GLITCHES) && !original_mode && level.vertical_wrap == 0xff00)
		{
			if (D0.s16 > level.height.bitmask / 2)
			{
				D0.s16 -= level.height.bitmask
			}
		}
	#endif

	D1 = D3.u16
	if (competition_mode.active)
		D1.u16 >>= 1

	if (char.flags & char.flag.IN_AIR)
	{
		D0.s16 += 0x20 - D1.u16
		if (D0.s16 < 0)
		{
			D1.u16 = 0x1800
		}
		else
		{
			D0.u16 -= 0x40
			if (D0.s16 >= 0)
			{
				D1.u16 = 0x1800
			}
			else if (u8[0xffffee32] != 0)
			{
				u8[0xffffee32] = 0
				D0 = 0
			}
			else
			{
				u16[A4] = 0
				return
			}
		}
	}
	else
	{
		D0.s16 -= D1.u16
		if (D0.s16 == 0)
		{
			if (u8[0xffffee32] != 0)
			{
				u8[0xffffee32] = 0
				D0 = 0
			}
			else
			{
				u16[A4] = 0
				return
			}
		}
		else
		{
		#if !STANDALONE
			// This check leads to strange camera behavior when looking up/down on (fast) vertically moving object
			//  -> For example, on the moving ice platform in ICZ 1; this can lead to a vertical wrap glitch
			//  -> I don't know yet what this check is even for...
			if (D3.u16 != 0x60)
			{
				D1.u16 = 0x200
			}
			else
		#endif
			if (u8[0xffffee39] != 0 || (global.zone_act == 0x0500 && object.flag.P1_ON_OBJECT && u16[0xffffb010] > 0x3f80 && u16[0xffffb010] <= 0x4300))
			{	// The player may be on the first sliding ice platform and falling fast. The first flag *is* set, but if a second platform spawns, that one may un-set it.
				D1.u16 = 0x1800		// should be 0x1800
			}
			else if (abs(s16[A0 + 0x1c]) >= 0x800)
			{
				D1.u16 = 0x1800		// should be 0x1800
			}
			else
			{
				D1.u16 = 0x600		// should be 0x0600
			}
		}
	}

	s16 threshold = (D1.u16 >> 8)
	if (D0.s16 > threshold)
	{
		D1.s32 = D1.s16 << 8
		D1 += u32[A1]
		D1 = (D1 << 16) + (D1 >> 16)
	}
	else if (D0.s16 < -threshold)
	{
		D1.s32 = (-D1.s16) << 8
		D1 += u32[A1]
		D1 = (D1 << 16) + (D1 >> 16)
	}
	else
	{
		D1 = D0.u16
		D1.u16 += u16[A1]
	}

	if (D0.s16 < 0)
	{
		if (D1.s16 <= s16[A2 + 4])
		{
			if (D1.s16 <= -0x100)
			{
				D1.u16 &= level.height.bitmask
			}
			else
			{
				D1.u16 = u16[A2 + 4]
			}
		}
	}
	else
	{
		if (D1.s16 >= s16[A2 + 6])
		{
			u16 levelHeight = level.height.bitmask + 1
			D1.u16 -= levelHeight
			if (D1.s16 >= 0)
			{
				u16[A1] -= levelHeight
			}
			else
			{
				D1.u16 = u16[A2 + 6]
			}
		}
	}

	D4.u16 = u16[A1]
	D1 = (D1 << 16) + (D1 >> 16)
	D3 = D1 - u32[A1]
	D3 = (D3 >> 8) + (D3 << 24)
	u16[A4] = D3.u16
	u32[A1] = D1

	if (competition_mode.active)
	{
		D1 = (D1 << 16) + (D1 >> 16)
		D1.u16 &= level.height.bitmask
		u16[A1] = D1.u16
	}
}



// Allow the South theme to edit the movement of title card text.
// Function taken from maingame\hud\titlecard.lemon
//# address-hook(0x02d95c) end(0x02d99a)
function void TitleCard.TextElement.Update()
{
	if (theme.hud == theme.south)
		South.TitleCard.TextElement.Update()
	else
		base.TitleCard.TextElement.Update()
}



// This massive function handles instances where graphics are loaded from outside of VRAM.
// Code is inserted here to handle new title cards and Eggrobo.

function bool Standalone.onWriteToSpriteTable(s16 px, s16 py, u16 renderQueue)
{
	bool prioFlag = (objA0.sprite_attributes & 0x8000) != 0

	if ((A0 == 0xffffb000 || A0 == 0xffffb04a || A0 == 0xffffcc0a) && original_mode)	// Player 1, sidekick Tails, Tails' tails
		return false

	// New custom code for title cards is inserted here.
	// First, the colored bar.
	if (objA0.update_address == 0x02d8e2)	// still title card bar but not with new title on
	{
		if (!original_mode)
		{
			if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				return Flicky.TitleCardBar(px, py, renderQueue)
			else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				return Saturn.TitleCardBar(px, py, renderQueue)
			else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				return South.TitleCardBar(px, py, renderQueue)
			else if (theme.hud == theme.westside && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				return Westside.TitleCardBar(px, py, renderQueue)
			else if (unlock_act)
				Renderer.drawCustomSprite("titlecard_redbar_dage_rtwi", px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue)
			else
				Renderer.drawCustomSprite("titlecard_redbar_dage", px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue)
		}
		else
			Renderer.drawCustomSprite("titlecard_redbar_dage_orig", px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue)
		return true
	}
	// Next, code for zone and act names.
	if (objA0.update_address == 0x02d95c && !original_mode)
	{
		if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			return Flicky.TitleCardText(px, py, renderQueue)
		else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			return Saturn.TitleCardText(px, py, renderQueue)
		else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			return South.TitleCardText(px, py, renderQueue)
		else if (theme.hud == theme.westside && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			return Westside.TitleCardText(px, py, renderQueue)

/*
		// Act number, found by checking which mappings will be used since the actual zone ID order is unwieldy.
		if (objA0.animation.sprite == 0x02 && global.zone_act == 0x1600) // force "Act 2" to show in the LRZ2 boss level
		{
			Renderer.drawCustomSprite("titlecard_act2", px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}

		else if (objA0.animation.sprite == 0x02 && global.zone_act == 0x1700) // force "Act 2" to show in the DEZ2 final boss level
		{
			Renderer.drawCustomSprite("titlecard_act2", px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}
		else if (objA0.animation.sprite == 0x02 && global.zone_act != 0x1601 && global.zone != 0x0a && global.zone != 0x0c) // exclude HPZ, SSZ, and DDZ from drawing act numbers
		{
			Renderer.drawCustomSprite(stringformat("titlecard_act%d", global.act.apparent + 1), px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}
*/
		if (objA0.animation.sprite == 0x02 && unlock_act)
		{
			return true		// do not render an act number in unlockable acts
		}
/*
		// Originally the word "zone", now white bars
		else if (objA0.animation.sprite == 0x03)
		{
			Renderer.drawCustomSprite("titlecard_whitebars", px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}
*/
		else if (objA0.animation.sprite == 0x03)
		{
			Renderer.drawCustomSprite("angel_titlecard_zone", px, py + 12, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}
/*
		// Zone name, found by checking which mappings will be used since the actual zone ID order is unwieldy
		else if (objA0.animation.sprite >= 0x04 && objA0.animation.sprite <= 0x11)
		{
			Renderer.drawCustomSprite(stringformat("titlecard_zone%d", objA0.animation.sprite - 4), px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}
*/
		else if (objA0.animation.sprite == 0x06 && unlock_act)
		{
			Renderer.drawCustomSprite(stringformat("angel_titlecard_unlock%04d", unlock_act), px, py + 12, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}
/*
		// "Bonus"
		else if (objA0.animation.sprite == 0x12 || objA0.animation.sprite == 0x13)
		{
			Renderer.drawCustomSprite("titlecard_bonus", px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}
		// "Stage"
		else if (objA0.animation.sprite == 0x14)
		{
			Renderer.drawCustomSprite("titlecard_stage", px - 0x20, py - 0x40, 0x00, SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT, renderQueue + 0x4000)
			return true
		}
*/
	}

	// Level results texts
	if (objA0.update_address == 0x02dd98)
	{
		if (original_mode)
			return false

		// Extra check for displaying giant ring counter before branching to theme-specific level results. If (object is TOTAL text and not in a zone without giant rings or playing a modded character...)
		if (giant_ring_counter && objA0.animation.sprite == 0x0b && !unlock_act && (global.zone == 0x16 || global.zone <= 0x09) && !u8[0xffffe654] && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		{
			GiantRings.displayNumberCollected(getScreenWidth()/2, px/8 + 189, 0xe008)
		}

		if (!System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		{
			if (theme.hud == theme.flicky)
				return Flicky.LevelResults(px, py, renderQueue)
			else if (theme.hud == theme.saturn)
				return Saturn.LevelResults(px, py, renderQueue)
			else if (theme.hud == theme.south)
				return South.LevelResults(px, py, renderQueue)
			else if (theme.hud == theme.westside)
				return Westside.LevelResults(px, py, renderQueue)
		}
		
		if (objA0.animation.sprite == 0x0b)
		{
			Renderer.drawCustomSprite(getCharacterBonusTextIcon(getMainCharacter()), px+36, py-5, 0, SPRITE_FLAG_PRIO, 0xe000)

			Renderer.drawCustomSprite("hud_text_total", px, py, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		else if (objA0.animation.sprite == 0x0c)
		{
		//	if (getMainCharacter() == CHARACTER_TAILS)	// && original_mode
		//		Renderer.drawCustomSprite("hud_bonus_icon_blue", px+37, py-5, 0, SPRITE_FLAG_PRIO, 0xe000)
		//	else
				Renderer.drawCustomSprite(getCharacterBonusTextIcon(getMainCharacter()), px+37, py-5, 0, SPRITE_FLAG_PRIO, 0xe000)

			Renderer.drawCustomSprite("hud_text_bonus", px, py, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		else if (objA0.animation.sprite == 0x0d)
		{
			Renderer.drawCustomSprite("hud_text_ring", px, py, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		else if (objA0.animation.sprite == 0x0e)
		{
			Renderer.drawCustomSprite("hud_text_time", px, py, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		else if (objA0.animation.sprite == 0x13)
		{
			Renderer.drawCustomSprite("angel_sonic_text", px + 36, py + 8, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		else if (objA0.animation.sprite == 0x15)
		{
			Renderer.drawCustomSprite("angel_tails_text", px + 32, py + 8, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		else if (objA0.animation.sprite == 0x14)
		{
			Renderer.drawCustomSprite("angel_miles_text", px + 39, py + 8, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		if (objA0.animation.sprite == 0x16)
		{
			if (isMainCharacter(CHARACTER_KNUCKLES))
				px += (global.zone_act == 0x0a00 || unlock_act) ? 26 : 0

			Renderer.drawCustomSprite("angel_knuckles_text", px + 62, py + 8, 0, SPRITE_FLAG_PRIO, 0xe008) // large horizontal shift for Knuckles to center KNUCKLES GOT
			return true
		}
		 else if (objA0.animation.sprite == 0x11)
		{
			if (isMainCharacter(CHARACTER_KNUCKLES))
				px += (global.zone_act == 0x0a00 || unlock_act) ? 26 : 0

			Renderer.drawCustomSprite("angel_got_text", px + 22, py + 8, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		else if (objA0.animation.sprite == 0x10)
		{
			s16 through_x_offset = (global.zone_act == 0x0a00 || unlock_act) ? -36 : 0		// show "Zone" in SSZ and unlockable acts, thus shift "Through" left.
			Renderer.drawCustomSprite("angel_through_text", px + through_x_offset + 57, py + 8, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
		else if (objA0.animation.sprite == 0x0f && (global.zone_act == 0x0a00 || unlock_act))	// show "Zone" in SSZ.
		{
			Renderer.drawCustomSprite("angel_zone_text", px, py + 24, 0, SPRITE_FLAG_PRIO, 0xe008)
			return true
		}
	//	else if (objA0.animation.sprite == 0x0f && new_title)
	//	{
	//		Renderer.drawCustomSprite(stringformat("titlecard_act%d", global.zone_act == 0x1600 ? 2 : global.act.apparent + 1), px, py - 0x28, 0, SPRITE_FLAG_PRIO, 0xe008)
	//		return true
	//	}
	}

	// GAME/TIME OVER text
	if (objA0.update_address == 0x02d612 || objA0.update_address == 0x02d638)	// first address while text is in motion, second when at screen center
	{
		if (!System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") && !original_mode)
		{
			if (theme.hud == theme.flicky)
				return Flicky.GameTimeOver(px, py, renderQueue)
			else if (theme.hud == theme.saturn)
				return Saturn.GameTimeOver(px, py, renderQueue)
			else if (theme.hud == theme.south)
				return South.GameTimeOver(px, py, renderQueue)
			else if (theme.hud == theme.westside)
				return Westside.GameTimeOver(px, py, renderQueue)
		}

		// Standard theme requires renderhook due to unlockable act palettes
		if (objA0.animation.sprite == 0)
		{
			Renderer.drawCustomSprite("angel_game", px - 72, py - 8, 0, SPRITE_FLAG_PRIO, renderQueue)
			return false
		}
		else if (objA0.animation.sprite == 1 || objA0.animation.sprite == 3)	// first goes with GAME, second with TIME
		{
			Renderer.drawCustomSprite("angel_over", (global.time_over) ? px + 12 : px + 8, py - 8, 0, SPRITE_FLAG_PRIO, renderQueue)	// first goes with TIME, second with GAME
			return false
		}
		else if (objA0.animation.sprite == 2)
		{
			Renderer.drawCustomSprite("angel_time", px - 57, py - 8, 0, SPRITE_FLAG_PRIO, renderQueue)
			return false
		}
		else
			return false
	}

	// EggRobo
	if (objA0.mapping_offset == 0x184f34)
	{
		if (objA0.animation.sprite == 0)	// EggRobo0 isn't a key
			return true
		if (objA0.animation.sprite == 7)	// this is the laser, which gets custom fading
			if (objA0.subtype2c < 128)
				Renderer.drawCustomSprite(stringformat("EggRobo7", objA0.animation.sprite), px, py , 0x00, (objA0.render_flags & 0x01) | (prioFlag ? SPRITE_FLAG_PRIO : 0), renderQueue)
			else
				Renderer.drawCustomSprite(stringformat("EggRobo7", objA0.animation.sprite), px, py , 0x00, (objA0.render_flags & 0x01) | (prioFlag ? SPRITE_FLAG_PRIO : 0), renderQueue, 0, 240 - (2 * (objA0.subtype2c - 128)))
		else
			Renderer.drawCustomSprite(stringformat("EggRobo%d", objA0.animation.sprite), px, py , 0x00, (objA0.render_flags & 0x01) | (prioFlag ? SPRITE_FLAG_PRIO : 0), renderQueue)

		return true
	}

	// Mini Time Stone
	if ((objA0.update_address == 0x01a51c) && objA0.base_state == 0x02)	// stone, with mirrored rotation compared to rings
	{
		// Use smoother ring rotation based on standalone\rendering\renderhooks.lemon
		u16 animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8	// divide by 2 instead of 4 to animate at double speed
		u64 key = stringformat("minitimestone_0%d", animFrame)
		if (unlock_act)
			key = stringformat("minitimestone_0%d_s2", animFrame)
		u16 miniTimeStoneRenderQueue = (global.zone_act == 0x0401 || unlock_act == 2) ? 0xa000 : 0x02000
		if (objA0.subtype2c == 0)
			Renderer.drawCustomSprite(key, px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, miniTimeStoneRenderQueue, 0, 255)
		else
			Renderer.drawCustomSprite(key, px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, miniTimeStoneRenderQueue, 0, 0xffffffff, 0x40000)
		return true
	}
	if ((objA0.update_address == 0x01a51c) && objA0.base_state >= 0x06)	// sparkle while stone disappears, also mirrored compared to rings
	{
		u16 miniTimeStoneRenderQueue = (global.zone_act == 0x0401 || unlock_act == 2) ? 0xa000 : 0x02000
		u64 sparkleKey = (unlock_act) ? "minitimestone_sparkle_s2" : "minitimestone_sparkle"
		if (objA0.animation.sprite == 4)
		{
			if (objA0.subtype2c == 0)
				Renderer.drawCustomSprite(sparkleKey, px, py, 0x00, 2, miniTimeStoneRenderQueue, 0, 255)
			else
				Renderer.drawCustomSprite(sparkleKey, px, py, 0x00, 2, miniTimeStoneRenderQueue, 0, 0xffffffff, 0x40000)
		}
		else if (objA0.animation.sprite == 5)
		{
			if (objA0.subtype2c == 0)
				Renderer.drawCustomSprite(sparkleKey, px, py, 0x00, 1, miniTimeStoneRenderQueue, 0, 255)
			else
				Renderer.drawCustomSprite(sparkleKey, px, py, 0x00, 1, miniTimeStoneRenderQueue, 0, 0xffffffff, 0x40000)
		}
		else if (objA0.animation.sprite == 6)
		{
			if (objA0.subtype2c == 0)
				Renderer.drawCustomSprite(sparkleKey, px, py, 0x00, 3, miniTimeStoneRenderQueue, 0, 255)
			else
				Renderer.drawCustomSprite(sparkleKey, px, py, 0x00, 3, miniTimeStoneRenderQueue, 0, 0xffffffff, 0x40000)
		}
		else
		{
			if (objA0.subtype2c == 0)
				Renderer.drawCustomSprite(sparkleKey, px, py, 0x00, 0, miniTimeStoneRenderQueue, 0, 255)
			else
				Renderer.drawCustomSprite(sparkleKey, px, py, 0x00, 0, miniTimeStoneRenderQueue, 0, 0xffffffff, 0x40000)
		}
		return true
	}

	// Red Star Ring
	if ((objA0.update_address == 0x047776) && objA0.base_state == 0x02)	// red star ring, with mirrored rotation compared to rings
	{
		// Use smoother ring rotation based on standalone\rendering\renderhooks.lemon
		u16 animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8	// divide by 2 instead of 4 to animate at double speed
		u8 ringNum = objA0.subtype2c & 0x1f
		u64 ringKey = ((u8[redstarring_address] & ringNum) || objA0.value26) ? "medal_02" : "redstarring"
		u32 alpha = ((u8[redstarring_address] & ringNum)) ? 0xa0c0c0c0 : 0xffffffff
		if (objA0.value26)		// if red star ring is for another character,
			alpha = 0x80c0c0c0	// render very faintly
		u64 key = stringformat("%s_0%d", ringKey, animFrame)
		u16 redStarRingRenderQueue = (global.zone_act == 0x0401 || unlock_act == 2) ? 0xa000 : 0x02000

		Renderer.drawCustomSprite(key, px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, redStarRingRenderQueue, 0, alpha, 0x10000)
		if (objA0.value26)
		{
			if (objA0.subtype2c <= 0x30)
				Renderer.drawCustomSprite("rsr_icon_sonic", px + 8, py + 8, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, redStarRingRenderQueue + 1, 0, 0xa0ffffff, 0x10000)
			else if (objA0.subtype2c <= 0x50)
				Renderer.drawCustomSprite("rsr_icon_tails", px + 8, py + 8, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, redStarRingRenderQueue + 1, 0, 0xa0ffffff, 0x10000)
			else
				Renderer.drawCustomSprite("rsr_icon_knuckles", px + 8, py + 8, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, redStarRingRenderQueue + 1, 0, 0xa0ffffff, 0x10000)
		}
		return true
	}
	if ((objA0.update_address == 0x047776) && objA0.base_state >= 0x06)	// sparkle while ring disappears, also mirrored compared to rings
	{
		u16 px_hud = getScreenWidth() - 70
		u16 py_hud = getScreenHeight() - 16
		if (time_attack_end && time_attack_hud == 0)
			py_hud -= 9	// 6 if version number is against bottom of screen as in older versions
		u8 sparkleNum = objA0.subtype2c & 0x1f
		if (sparkleNum == 0x02)
			px_hud += 12
		else if (sparkleNum == 0x04)
			px_hud += 24
		else if (sparkleNum == 0x08)
			px_hud += 36
		else if (sparkleNum == 0x10)
			px_hud += 48
		u16 sparkleRenderQueue = (global.zone_act == 0x0401 || unlock_act == 2) ? 0xa000 : 0x02000

		if (objA0.animation.sprite == 4)
		{
			if (objA0.value39 == 0)
			{
				Renderer.drawCustomSprite("redstarring_sparkle", px, py, 0x00, 2, sparkleRenderQueue, 0, 0xffffffff, 0x10000)
				Renderer.drawCustomSprite("redstarring_sparkle", px_hud, py_hud, 0x00, SPRITE_FLAG_PRIO + 2, 0xfff2)
			}
			else
				if (!unlock_act)
					Renderer.drawCustomSprite("minitimestone_sparkle", px, py, 0x00, 2, sparkleRenderQueue, 0, 0x80ffffff, 0x10000)
				else
					Renderer.drawCustomSprite("minitimestone_sparkle_s2", px, py, 0x00, 2, sparkleRenderQueue, 0, 0x80ffffff, 0x10000)
		}
		else if (objA0.animation.sprite == 5)
		{
			if (objA0.value39 == 0)
			{
				Renderer.drawCustomSprite("redstarring_sparkle", px, py, 0x00, 1, sparkleRenderQueue, 0, 0xffffffff, 0x10000)
				Renderer.drawCustomSprite("redstarring_sparkle", px_hud, py_hud, 0x00, SPRITE_FLAG_PRIO + 1, 0xfff2)
			}
			else
				if (!unlock_act)
					Renderer.drawCustomSprite("minitimestone_sparkle", px, py, 0x00, 1, sparkleRenderQueue, 0, 0x80ffffff, 0x10000)
				else
					Renderer.drawCustomSprite("minitimestone_sparkle_s2", px, py, 0x00, 1, sparkleRenderQueue, 0, 0x80ffffff, 0x10000)
		}
		else if (objA0.animation.sprite == 6)
		{
			if (objA0.value39 == 0)
			{
				Renderer.drawCustomSprite("redstarring_sparkle", px, py, 0x00, 3, sparkleRenderQueue, 0, 0xffffffff, 0x10000)
				Renderer.drawCustomSprite("redstarring_sparkle", px_hud, py_hud, 0x00, SPRITE_FLAG_PRIO + 3, 0xfff2)
			}
			else
				if (!unlock_act)
					Renderer.drawCustomSprite("minitimestone_sparkle", px, py, 0x00, 3, sparkleRenderQueue, 0, 0x80ffffff, 0x10000)
				else
					Renderer.drawCustomSprite("minitimestone_sparkle_s2", px, py, 0x00, 3, sparkleRenderQueue, 0, 0x80ffffff, 0x10000)
		}
		else
		{
			if (objA0.value39 == 0)
			{
				Renderer.drawCustomSprite("redstarring_sparkle", px, py, 0x00, 0, sparkleRenderQueue, 0, 0xffffffff, 0x10000)
				Renderer.drawCustomSprite("redstarring_sparkle", px_hud, py_hud, 0x00, SPRITE_FLAG_PRIO + 0, 0xfff2)
			}
			else
				if (!unlock_act)
					Renderer.drawCustomSprite("minitimestone_sparkle", px, py, 0x00, 0, sparkleRenderQueue, 0, 0x80ffffff, 0x10000)
				else
					Renderer.drawCustomSprite("minitimestone_sparkle_s2", px, py, 0x00, 0, sparkleRenderQueue, 0, 0x80ffffff, 0x10000)
		}
		return true
	}

	// Monitors (to include Time Freeze)
	if (objA0.update_address >= 0x01d566 && objA0.update_address <= 0x01d61e)
	{
		u8 flags = ((objA0.render_flags & 0x02) ? SPRITE_FLAG_FLIP_Y : 0) | ((objA0.sprite_attributes & 0x8000) ? SPRITE_FLAG_PRIO : 0)
		u64 key
		bool s2Challenge = time_attack && unlock_act
		if (objA0.animation.sprite == 11)
		{
			if ((Game.getSetting(SETTING_MONITOR_STYLE) || unlock_act) && !original_mode && (!time_attack || s2Challenge))
			{
				key = (unlock_act) ? "s2_monitor_s2_broken" : "monitor_s2_broken"
				Renderer.drawCustomSprite(key, px, py, 0x00, flags, renderQueue)
			}
			else
			{
				Renderer.drawCustomSprite("monitor_s3_broken", px, py, 0x00, flags, renderQueue)
			}
		}
		else
		{
			if ((Game.getSetting(SETTING_MONITOR_STYLE) || unlock_act) && !original_mode && (!time_attack || s2Challenge))
			{
				key = (unlock_act) ? "s2_monitor_s2_intact" : "monitor_s2_intact"
				Renderer.drawCustomSprite(key, px, py, 0x00, flags, renderQueue)
				py += (objA0.render_flags & 0x02) ? 2 : -2
			}
			else
			{
				Renderer.drawCustomSprite("monitor_s3_intact", px, py, 0x00, flags, renderQueue)
				py += (objA0.render_flags & 0x02) ? 5 : -5
			}

			if (objA0.subtype2c == 0x0f && level.framecounter % 6 > 1)	// use level frame counter to make Time Freeze item flicker
			{
				key = (unlock_act) ? "s2_monitor_icon_timefreeze" : "monitor_icon_timefreeze"
				Renderer.drawCustomSprite(key, px, py, 0x00, flags, renderQueue + 1)
			}

			else if (objA0.animation.sprite <= 1)
			{
				if (objA0.animation.sprite == 1)
				{
					key = (unlock_act) ? "s2_monitor_icon_static" : "monitor_icon_static"
					Renderer.drawCustomSprite(key, px, py, 0x00, flags, renderQueue + 1)
				}
			}
			else
			{
				key = Monitor.getIconSpriteKey(objA0.subtype2c)
				if (objA0.subtype2c >= 0x05 && objA0.subtype2c <= 0x07)
				{
					if (Monitor.enforceClassicShield())
					{
						key = (unlock_act) ? "s2_monitor_icon_classicshield" : "monitor_icon_classicshield"
					}
				}
				if (key != 0)
				{
					Renderer.drawCustomSprite(key, px, py, 0x00, flags, renderQueue + 1)
				}
			}
		}
		return true
	}

	// Dummy address given to hidden monitor hints in unlockable acts
	if (objA0.update_address == 0x08370a)
	{
		Renderer.drawCustomSprite("s2_monitor_s2_intact", px, py, 0x00, 0, renderQueue)
		return true
	}

	// Blue Spheres results texts
	u8 gameMode = global.game_mode & 0x7f
	if (objA0.update_address == 0x02ea50 || objA0.update_address == 0x02eac8 || objA0.update_address == 0x02ebcc || objA0.update_address == 0x02ec1e && (gameMode == 0x48 || gameMode == 0x0c))
	{
//		if (original_mode)
//			return false
		
		if (!original_mode && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		{		
			if (theme.hud == theme.flicky)
				return Flicky.SpecialStageResults(px, py, renderQueue)
			else if (theme.hud == theme.saturn)
				return Saturn.SpecialStageResults(px, py, renderQueue)
			else if (theme.hud == theme.south)
				return South.SpecialStageResults(px, py, renderQueue)
			else if (theme.hud == theme.westside)
				return Westside.SpecialStageResults(px, py, renderQueue)
		}

		bool isSKStage = (global.lock_on_state == 0 && global.sk_bluespheres)
		if (objA0.animation.sprite == 0x17 || objA0.animation.sprite == 0x31 || objA0.animation.sprite == 0x36)
		{
			if (original_mode)
			{
				HUD.drawNumber(isSKStage ? "hud_digit_%d" : "hud_digit_%d_chaosstage", player.score * 10, px + 88, py, renderQueue + 1)	// doesn't actually seem necessary, unlike the RING BONUS and Perfect digit drawing
				return false
			}

			if (getMainCharacter() == CHARACTER_TAILS && original_mode)
				HUD.drawSprite("hud_bonus_icon_blue", px-60, py-5, renderQueue-1)
			else
				HUD.drawSprite(getCharacterBonusTextIcon(getMainCharacter()), px-60, py-5, renderQueue-1)
				
			HUD.drawSprite(isSKStage ? "hud_text_score_superstage" : "hud_text_score_chaosstage", px - 96, py, renderQueue)
			HUD.drawNumber(isSKStage ? "hud_digit_%d" : "hud_digit_%d_chaosstage", player.score * 10, px + 88, py, renderQueue)
			return true
		}
		else if (objA0.animation.sprite == 0x18 || objA0.animation.sprite == 0x32 || objA0.animation.sprite == 0x37)
		{
			if (original_mode)
			{
				HUD.drawNumber(isSKStage ? "hud_digit_%d" : "hud_digit_%d_chaosstage", results.ring_bonus * 10, px + 184, py, renderQueue)
				return false
			}

			if (getMainCharacter() == CHARACTER_TAILS && original_mode)
				HUD.drawSprite("hud_bonus_icon_blue", px+77, py-5, renderQueue-1)
			else
				HUD.drawSprite(getCharacterBonusTextIcon(getMainCharacter()), px+77, py-5, renderQueue-1)

			HUD.drawSprite(isSKStage ? "hud_text_ring_superstage" : "hud_text_ring_chaosstage", px, py, renderQueue)
			HUD.drawSprite(isSKStage ? "hud_text_bonus_superstage" : "hud_text_bonus_chaosstage", px + 40, py, renderQueue)
			HUD.drawNumber(isSKStage ? "hud_digit_%d" : "hud_digit_%d_chaosstage", results.ring_bonus * 10, px + 184, py, renderQueue)
			return true
		}
		else if (objA0.animation.sprite == 0x19 || objA0.animation.sprite == 0x33 || objA0.animation.sprite == 0x38)
		{
			if (original_mode)
			{
				HUD.drawNumber(isSKStage ? "hud_digit_%d" : "hud_digit_%d_chaosstage", results.time_bonus * 10, px + 184, py, renderQueue)
				return false
			}

			if (getMainCharacter() == CHARACTER_TAILS && original_mode)
				HUD.drawSprite("hud_bonus_icon_blue", px+52, py-5, renderQueue-1)
			else
				HUD.drawSprite(getCharacterBonusTextIcon(getMainCharacter()), (unlock_act) ? px + 93 : px+52, py-5, renderQueue-1)

			if (!unlock_act)
				HUD.drawSprite(isSKStage ? "hud_text_perfect_superstage" : "hud_text_perfect_chaosstage", px, py, renderQueue)
			else
			{
				HUD.drawSprite(isSKStage ? "hud_text_sphere_superstage" : "hud_text_sphere_chaosstage", px, py, renderQueue)
				HUD.drawSprite(isSKStage ? "hud_text_bonus_superstage" : "hud_text_bonus_chaosstage", px + 56, py, renderQueue)
			}
			HUD.drawNumber(isSKStage ? "hud_digit_%d" : "hud_digit_%d_chaosstage", results.time_bonus * 10, px + 184, py, renderQueue)
			return true
		}
		else if (objA0.animation.sprite == 0x1a || objA0.animation.sprite == 0x34 || objA0.animation.sprite == 0x39)
		{
			if (original_mode)
				return false
			
			if (getMainCharacter() == CHARACTER_TAILS && original_mode)
				HUD.drawSprite("hud_bonus_icon_blue", px+60, py-5, renderQueue-1)
			else
				HUD.drawSprite(getCharacterBonusTextIcon(getMainCharacter()), px+60, py-5, renderQueue-1)
			HUD.drawSprite(isSKStage ? "hud_text_continue_superstage" : "hud_text_continue_chaosstage", px, py, renderQueue)
			return true
		}
		else if (objA0.animation.sprite >= 0x12 && objA0.animation.sprite <= 0x16)
		{
			u8 character = getMainCharacter()
			u64 key = getCharacterResultsNameplate(character)
			u8 atex = 0x40 + character * 0x20
			if (objA0.animation.sprite == 0x12)
				key = stringformat((global.super_emeralds < 7) ? "%s_super" : "%s_hyper", key)
			if (Renderer.hasCustomSprite(key))
			{
				Renderer.drawCustomSprite(key, px, py, atex, SPRITE_FLAG_PRIO, renderQueue)
				return true
			}
		}
	}

	// Continue icon
	if (objA0.update_address == 0x02ebe8 && objA0.animation.sprite >= 0x29 && objA0.animation.sprite <= 0x2b)
	{
		if (original_mode)
			return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)

		if (theme.hud == theme.flicky)
			return Flicky.SpecialStageResultsContinue(px, py, renderQueue)
		else if (theme.hud == theme.saturn)
			return Saturn.SpecialStageResultsContinue(px, py, renderQueue)
		else if (theme.hud == theme.south)
			return South.SpecialStageResultsContinue(px, py, renderQueue)
		else
		{
			string key = getCharacterContinueIcon(getMainCharacter())
			Renderer.drawCustomSprite(key, px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
			return true
		}
	}

	// Missile in DDZ
	if (objA0.update_address == 0x0820d0 && original_mode)	// in Original Mode, don't use smooth rotation on missiles. Non-Original Mode will use the base check below.
	{
		return false
	}

	// HCZ Pointdexter: conditionally do NOT use a renderhook for Original Mode
	if (objA0.update_address == 0x088282)
	{
		if (original_mode)
		{
			s8[0x360e8e] = -0x0c
			s8[0x360e9a] = -0x0c
			return false
		}
		else
		{
			s8[0x360e8e] = -0x08
			s8[0x360e9a] = -0x08
			Standalone.renderWithKosinskiCompression(px, py, 0x36ad8a, 0xff, renderQueue)
			return true
		}
	}

	#if GAMEAPP > 0x22091000
	// CNZ Balloon
	if (objA0.update_address == 0x031754 && objA0.subtype2c == 0x04 && !original_mode)
	{
		// This only works for the red balloon; its cord and other colors use a copy of the art that's Nemesis-compressed
		Standalone.renderWithKosinskiCompression(px, py, 0x37060e, 0xff, renderQueue, 0xae80)		// Draw the balloon sprite

		// Directly drawing the cord sprites
		if (objA0.animation.sprite == 0x14)
			Renderer.drawVdpSprite(px-4, py+16, 0x03, (sprite_attribute.PALETTE.LINE2 | 0x035c), renderQueue)
		if (objA0.animation.sprite == 0x15)
			Renderer.drawVdpSprite(px-4, py+16, 0x03, (sprite_attribute.PALETTE.LINE2 | 0x0360), renderQueue)
		if (objA0.animation.sprite == 0x16)
			Renderer.drawVdpSprite(px-4, py+16, 0x03, (sprite_attribute.FLIP_X | sprite_attribute.PALETTE.LINE2 | 0x035c), renderQueue)

		return false			// Skip hardware drawing the original balloon
	}
	#endif

	// FBZ 2 boss fight Egg Robo head
	if (objA0.update_address == 0x067b96 && isMainCharacter(CHARACTER_KNUCKLES) && original_mode)
	{
		return false	// if in Original Mode, don't use the Eggrobo art for the FBZ2 boss
	}

	// Tornado in outro, when flying left
	if (objA0.update_address == 0x05ea52 && char.render_flags & render_flag.FLIP_X)
	{
		// Render additional sprite on top
		if (!original_mode)
			Renderer.drawCustomSprite("tornado_text_sonic", px-16, py-6, 0, 0x00, renderQueue + 1)
		return false
	}

	// Dynamic ring (placed by debug mode, or those in Knuckles' SSZ)
	if ((objA0.update_address == 0x01a51a) && objA0.base_state == 0x02)
	{
		// Use smoother ring rotation
		u16 animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8
		if (original_mode)
			animFrame &= 0xfe	// remove the last bit to only draw original game frames in Original Mode
		u64 key = stringformat("ring_0%d", animFrame)
		if (unlock_act)
			key = stringformat("s2_ring_0%d", animFrame)
		Renderer.drawCustomSprite(key, px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue, 0, 255)
		return true
	}

	// Spilled ring
	if ((objA0.update_address == 0x01a64a || objA0.update_address == 0x01a662) && objA0.base_state == 0x02)
	{
		// Use smoother ring rotation
		u16 animFrame = (spilled_rings.progress >> 8) % 8
		u8 alpha = min(255, u16(spilled_rings.speed) * 10)
		if (original_mode)
		{
			animFrame &= 0xfe	// remove the last bit to only draw original game frames in Original Mode
			alpha = 255			// no fading out in Original Mode
		}
		u64 key = stringformat("ring_0%d", animFrame)
		if (unlock_act)
			key = stringformat("s2_ring_0%d", animFrame)
		Renderer.drawCustomSprite(key, px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue, 0, alpha)
		return true
	}

	// Dynamic ring
	if (objA0.update_address == 0x01a88c && objA0.base_state == 0x00)
	{
		// Use smoother ring rotation
		u16 animFrame = ((objA0.animation.sprite * 4 + 3 - objA0.animation.timer) / 2) % 8
		if (original_mode)
			animFrame &= 0xfe	// remove the last bit to only draw original game frames in Original Mode
		u64 key = stringformat("ring_0%d", animFrame)
		if (unlock_act)
			key = stringformat("s2_ring_0%d", animFrame)
		Renderer.drawCustomSprite(key, px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue, 0, 255)
		return true
	}

	// Star post arrows
	if (objA0.update_address == 0x02cfa8 && checkpoint.number >= (objA0.subtype2c & 0x7f) && objA0.base_state <= 4 && !original_mode)
	{
		// Render arrows pointing in the correct direction
		u16[A0 + 0x36] = min(u16[A0 + 0x36] + 16, 240)	
		u32 alpha = (u16[A0 + 0x36] << 24)
		u32 highlight1 = (level.framecounter.low % 32 < 8 ? 0x20b0ff : 0xffffff)
		u32 highlight2 = ((level.framecounter.low - 8) % 32 < 8 ? 0x20b0ff : 0xffffff)
		u32 highlight3 = ((level.framecounter.low - 16) % 32 < 8 ? 0x20b0ff : 0xffffff)
		u32 highlight4 = ((level.framecounter.low - 24) % 32 < 8 ? 0x20b0ff : 0xffffff)
		if (objA0.subtype2c < 0x80)		// star post respawns player facing right
		{
			Renderer.drawCustomSprite("rightarrow_medium", objA0.position.x.u16 - 0x1c, objA0.position.y.u16 + 0x08, 0x00, 0x20, 0x9d7a, 0, alpha + highlight1, 0x10000)
			Renderer.drawCustomSprite("rightarrow_medium", objA0.position.x.u16 - 0x10, objA0.position.y.u16 + 0x08, 0x00, 0x20, 0x9d7a, 0, alpha + highlight2, 0x10000)
			Renderer.drawCustomSprite("rightarrow_medium", objA0.position.x.u16 + 0x10, objA0.position.y.u16 + 0x08, 0x00, 0x20, 0x9d7a, 0, alpha + highlight3, 0x10000)
			Renderer.drawCustomSprite("rightarrow_medium", objA0.position.x.u16 + 0x1c, objA0.position.y.u16 + 0x08, 0x00, 0x20, 0x9d7a, 0, alpha + highlight4, 0x10000)
		}
		else	// star post respawns player facing left
		{
			Renderer.drawCustomSprite("leftarrow_medium", objA0.position.x.u16 - 0x1c, objA0.position.y.u16 + 0x08, 0x00, 0x20, 0x9d7a, 0, alpha + highlight4, 0x10000)
			Renderer.drawCustomSprite("leftarrow_medium", objA0.position.x.u16 - 0x10, objA0.position.y.u16 + 0x08, 0x00, 0x20, 0x9d7a, 0, alpha + highlight3, 0x10000)
			Renderer.drawCustomSprite("leftarrow_medium", objA0.position.x.u16 + 0x10, objA0.position.y.u16 + 0x08, 0x00, 0x20, 0x9d7a, 0, alpha + highlight2, 0x10000)
			Renderer.drawCustomSprite("leftarrow_medium", objA0.position.x.u16 + 0x1c, objA0.position.y.u16 + 0x08, 0x00, 0x20, 0x9d7a, 0, alpha + highlight1, 0x10000)
		}
	}

	// Character sprites for riding the Tornado
	if (objA0.update_address == 0x05ebb4 || objA0.update_address == 0x05ed18)
	{
		u64 key = 0
		u8 atex = 0
		u8 character = isMainCharacter(CHARACTER_SONIC) ? CHARACTER_TAILS : isMainCharacter(CHARACTER_TAILS) ? CHARACTER_SONIC : isSecondCharacter(CHARACTER_TAILS) ? CHARACTER_TAILS : CHARACTER_SONIC
		if (objA0.update_address == 0x05ebb4)
		{
			key = stringformat("%s_pilot", getCharacterTornadoSpriteKey(character))
		}
		else //if (objA0.update_address == 0x05ed18)
		{
			if (objA0.subtype2c != 0)
				character = getMainCharacter()
			key = stringformat((objA0.subtype2c == 0) ? "%s_pilot_small" : "%s_small", getCharacterTornadoSpriteKey(character))

			if (objA0.subtype2c != 0 && isMainCharacter(CHARACTER_KNUCKLES) && outro.ending_type < 0)
			{
				if (original_mode)
					return false
				
				// Replace Knuckles' smaller tornado sprite with a more fitting sprite in bad ending
				key = stringformat((global.zone_act == 0x0d01) ? "%s_small_standing" : "%s_small_exhausted", getCharacterTornadoSpriteKey(CHARACTER_KNUCKLES))
			}
		}

		atex = 0x40 + character * 0x20
		if (Renderer.hasCustomSprite(key))
		{
			if (objA0.subtype2c != 0 && isMainCharacter(CHARACTER_KNUCKLES) && outro.ending_type >= 0)
			{
				// Render the Master Emerald sprite separately
				Renderer.drawVdpSprite(px-18, py-24, 0x0d, sprite_attribute.PRIORITY | sprite_attribute.FLIP_X | sprite_attribute.PALETTE.LINE2 | 0x02e7, renderQueue-1)
				Renderer.drawVdpSprite(px-10, py-8, 0x04, sprite_attribute.PRIORITY | sprite_attribute.FLIP_X | sprite_attribute.PALETTE.LINE2 | 0x02ef, renderQueue-1)
			}
			Renderer.drawCustomSprite(key, px, py, atex, (objA0.render_flags & render_flag.FLIP_X) | (prioFlag ? SPRITE_FLAG_PRIO : 0), renderQueue)
			return true
		}
	}

	// FBZ propeller for Act 2
	if (objA0.update_address == 0x03c1ee && !original_mode)
	{
		Renderer.drawCustomSprite(stringformat("fbz_propeller%d", u8[A0 + 0x1d]), px, py , 0x00, (objA0.render_flags & 0x01) | SPRITE_FLAG_PRIO, renderQueue)	// frame to show is kept in offset 0x1d
		return true
	}	
/*
	// Characters in special stage. Add 46 to use new screen size.
	if (objA0.update_address == 0x00903e || objA0.update_address == 0x00927a)
	{
		u8 character = (objA0.update_address == 0x00927a) ? getSecondCharacter() : getMainCharacter()
		u8 atex = (character == CHARACTER_TAILS) ? 0x10 : 0x00
		u64 key = stringformat((character == CHARACTER_SONIC) ? "bluesphere_sonic_0x%02x" : (character == CHARACTER_TAILS) ? "bluesphere_tails_0x%02x" : "bluesphere_knuckles_0x%02x", objA0.animation.sprite)
		if (Renderer.hasCustomSprite(key))
		{
			// Check if there's also a custom palette
			string paletteKey = (character == CHARACTER_SONIC) ? "bluesphere_palette_sonic" : (character == CHARACTER_TAILS) ? "bluesphere_palette_tails" : "bluesphere_palette_knuckles"
			if (System.hasExternalPaletteData(paletteKey, 0))
			{
				atex = 0x40 + character * 0x20
			}
		}
		else
		{
			if (character == CHARACTER_SONIC)
				key = Renderer.setupCustomCharacterSprite(0x0aaa7c, 0x0abe14, objA0.mapping_offset, objA0.animation.sprite, 0x00)
			else if (character == CHARACTER_TAILS)
				key = Renderer.setupCustomCharacterSprite(0x28f95a, 0x2908d2, objA0.mapping_offset, objA0.animation.sprite, 0x10)
			else
				key = Renderer.setupCustomCharacterSprite(0x0abf22, 0x0ad31a, objA0.mapping_offset, objA0.animation.sprite, 0x00)
		}
		Renderer.drawCustomSprite(key, px, py + 46, atex, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}

	// Tails' tails object in special stage
	if (objA0.update_address == 0x009488)
	{
		u8 atex = 0x10
		u64 key = stringformat("bluesphere_tails_tails_0x%02x", objA0.animation.sprite)
		if (Renderer.hasCustomSprite(key))
		{
			// Check if there's also a custom palette
			u64 paletteKey = "bluesphere_palette_tails"
			if (System.hasExternalPaletteData(paletteKey, 0))
			{
				atex = 0x40 + CHARACTER_TAILS * 0x20
			}
		}
		else
		{
			key = Renderer.setupCustomCharacterSprite(0x2909e8, 0x291106, objA0.mapping_offset, objA0.animation.sprite, 0x10)
		}
		Renderer.drawCustomSprite(key, px, py + 46, atex, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}
*/

	// EHZ Platforms
	if (unlock_act && objA0.update_address == 0x0255f4)
	{
		Renderer.drawCustomSprite(stringformat("ehz_platform_%02x", objA0.animation.sprite), px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}
	if (unlock_act && (objA0.update_address == 0x024ef2 || objA0.update_address == 0x0251ae))
	{
		Renderer.drawCustomSprite("ehz_platform_fall", px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}

	// Sonic 2 Explosion
	if (unlock_act && objA0.update_address == 0x01e66e && objA0.animation.sprite < 5)
	{
		Renderer.drawCustomSprite(stringformat("s2_explosion_%02x", objA0.animation.sprite), px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}

	// Sonic 2 Ricky
	if (unlock_act && objA0.update_address == 0x02c778 && u8[A0 + 0x30] == 6)
	{
		Renderer.drawCustomSprite(stringformat("s2_ricky_%02x", objA0.animation.sprite), px, py, 0x00, (objA0.render_flags & 0x01) | (prioFlag ? SPRITE_FLAG_PRIO : 0), renderQueue)
		return true
	}

	// Sonic 2 Flicky and Locky
	if (unlock_act && objA0.update_address == 0x02c778 && u8[A0 + 0x30] == 5)
	{
		if (unlock_act == 2)
			Renderer.drawCustomSprite(stringformat("s2_locky_%02x", objA0.animation.sprite), px, py, 0x00, (objA0.render_flags & 0x01) | (prioFlag ? SPRITE_FLAG_PRIO : 0), renderQueue)
		else
			Renderer.drawCustomSprite(stringformat("s2_flicky_%02x", objA0.animation.sprite), px, py, 0x00, (objA0.render_flags & 0x01) | (prioFlag ? SPRITE_FLAG_PRIO : 0), renderQueue)
		return true
	}

	// Sonic 2 Pocky
	if (unlock_act && objA0.update_address == 0x02c778 && u8[A0 + 0x30] == 0)
	{
		Renderer.drawCustomSprite(stringformat("s2_pocky_%02x", objA0.animation.sprite), px, py, 0x00, (objA0.render_flags & 0x01) | (prioFlag ? SPRITE_FLAG_PRIO : 0), renderQueue)
		return true
	}

	// Sonic 2 emeralds for special stage results screen
	if (unlock_act && objA0.update_address == 0x02eaa6)
	{
		// objA0.box_size.x contains the emerald's ID (zero-indexed)
		px = getScreenWidth()/2
		if (objA0.box_size.x == 1 || objA0.box_size.x == 2)
			px += 24
		else if (objA0.box_size.x == 4 || objA0.box_size.x == 5)
			px -= 24
		py = getScreenHeight()/2 - 12
		if (objA0.box_size.x == 0)
			py -= 24
		else if (objA0.box_size.x == 1 || objA0.box_size.x == 5)
			py -= 12
		else if (objA0.box_size.x == 2 || objA0.box_size.x == 4)
			py += 12
		else if (objA0.box_size.x == 3)
			py += 24
		
		Renderer.drawCustomSprite(stringformat("sonic2_emerald_%02x", objA0.box_size.x), px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}

	// Signpost sign when in Sonic 2 acts
	if (objA0.update_address == 0x0837b2 && unlock_act)
	{
		u8 customAtex = (objA0.animation.sprite == 2) ? 0x80 : 0x40		// Use Knuckles' AIR palette line when needed. 0x40 is the Sonic AIR palette line.
		Standalone.renderWithStandardPacking(px, py, 0x083b42, customAtex, renderQueue)
		Nemesis.loadDataToVRAM(0xdd976, 0xd3c0)	// load signpost pole
		return true
	}

	// Signpost pole
	if (objA0.update_address == 0x083a40 && unlock_act)
	{
		// Nemesis.loadDataToVRAM(0xdd976, 0xd3c0)	// load signpost pole
		Renderer.drawCustomSprite("signpost_pole", px, py, 0x00, prioFlag ? SPRITE_FLAG_PRIO : 0, renderQueue)
		return true
	}

	return base.Standalone.onWriteToSpriteTable(px, py, renderQueue)
}


// Undo some AIR visual improvements for Original Mode.
// Function taken from standalone\rendering\renderhooks.lemon
function bool Standalone.onDrawVdpSpriteCompound(s16 px, s16 py, u8 size, u16 index, u16 renderQueue, u8 spriteCounter)
{
	// HCZ water waves effect
	if (objA0.update_address == 0x01f244)
	{
		if (A0 == 0xffffcf82 && D4.u16 == 0)		// Only for one sprite of the main object
		{
			Renderer.clearSpriteTag()
			px = (camera.position.x.u16 & 0xffe0) - camera.position.x.u16 - 0x10	// Extend a bit more to the left just for sprite interpolation
			for (; px < s16(getScreenWidth()); px += 0x20)
			{
				if (!original_mode)
				{
					renderQueue = 0xdfe1
					for (u8 i = 0; i <= 0x6d; i++)
					{
						if (u32[0xffffb000 + (i * 0x4a)] == 0x02d8e2)
						{
							renderQueue = 0x9fe1	// when in act transition area, do not cover Angel theme zone name, act number, or red bar
							break
						}
					}
					Renderer.drawVdpSpriteWithAlpha(px, py, size, index, renderQueue, 160)
				}
				else
				{
					if (!(((px & 0xffe0) + 0x20 * (level.framecounter.low & 0x01)) % 0x40))
						Renderer.drawVdpSprite(px, py, size, index, 0xdfe1)
				}
			}
		}
		return true
	}

	// CPZ water waves effect
	if (objA0.update_address == 0x0208dc)
	{
		s16 x_shift = (level.framecounter.low & 0x10) ? -0x10 : 0x10
		if (A0 == 0xffffcf82 && D4.u16 == 0)		// Only for one sprite of the main object
		{
			Renderer.clearSpriteTag()
			px = (camera.position.x.u16 & 0xffc0) - camera.position.x.u16 + x_shift	// Extend a bit more to the left just for sprite interpolation
			for (; px < s16(getScreenWidth()); px += 0x40)
			{
				renderQueue = 0xdfe1
				for (u8 i = 0; i <= 0x6d; i++)
				{
					if (u32[0xffffb000 + (i * 0x4a)] == 0x02d8e2)
					{
						renderQueue = 0x9fe1	// when in act transition area, do not cover Angel theme zone name, act number, or red bar
						break
					}
				}
				Renderer.drawVdpSpriteWithAlpha(px, py, size, index, renderQueue, 208)
			}
		}
		else if (A0 == 0xffffcf82 && D4.u16 == 1)		// Only for one sprite of the main object
		{
			Renderer.clearSpriteTag()
			px = (camera.position.x.u16 & 0xffc0) - camera.position.x.u16 - x_shift	// Extend a bit more to the left just for sprite interpolation
			for (; px < s16(getScreenWidth()); px += 0x40)
			{
				renderQueue = 0xdfe1
				for (u8 i = 0; i <= 0x6d; i++)
				{
					if (u32[0xffffb000 + (i * 0x4a)] == 0x02d8e2)
					{
						renderQueue = 0x9fe1	// when in act transition area, do not cover Angel theme zone name, act number, or red bar
						break
					}
				}
				Renderer.drawVdpSpriteWithAlpha(px, py, size, index, renderQueue, 208)
			}
		}
		return true		
	}

	// SSZ clouds effect
	if (objA0.update_address == 0x057bf6)
	{
		if (original_mode)
			return false
		
		// SSZ clouds effect
		if (objA0.update_address == 0x057bf6)
		{
			Renderer.drawVdpSpriteWithAlpha(px,   py, size, index, 0xd000, 140)
			Renderer.drawVdpSpriteWithAlpha(px+1, py, size, index, 0xd000, 144)

			if (getScreenWidth() > 400)
			{
				// Draw an additional copy of the cloud one loop further to the right
				Renderer.drawVdpSpriteWithAlpha(px+512, py, size, index, 0xd000, 140)
				Renderer.drawVdpSpriteWithAlpha(px+513, py, size, index, 0xd000, 144)
			}

		return true
		}
	}

	return base.Standalone.onDrawVdpSpriteCompound(px, py, size, index, renderQueue, spriteCounter)
}




// Allow a DEZ retracting spring in DEZ1 to use correct graphics for its base.
// Render hyper stars fully opaque in Original Mode.
// Also makes a check from AIR commits after the latest stable build.
// Function taken from standalone\rendering\renderhooks.lemon
function bool Standalone.onDrawVdpSprite(s16 px, s16 py, u8 size, u16 index, u16 renderQueue)
{
	// Hyper Sonic stars
	if (objA0.update_address == 0x0193ec || objA0.update_address == 0x0193ca)
	{
		// Draw not fully opaque
		u8 alpha = 0xff
		if (Game.getSetting(SETTING_GFX_ANTIFLICKER) >= 1 && !original_mode)
		{
			u8 step = objA0.animation.sprite * 2 + (1 - objA0.animation.timer)	// Ranges from 0 to 5
			if (Game.getSetting(SETTING_GFX_ANTIFLICKER) == 2)
				alpha = 0xe0 - step * 0x20
			else
				alpha = 0xff - step * 0x18
		}
		Renderer.drawVdpSpriteWithAlpha(px, py, size, index, renderQueue, alpha)
		return true
	}

	// DEZ 1 Retractable Spring (the one added for S3AIR specifically)
	if (objA0.update_address == 0x0480d4 && global.zone_act == 0x0b00 && index >= sprite_attribute.PALETTE.LINE1)	// >= works for now, but if yellow spring art is ever used, this is insufficient
	{
		Renderer.drawCustomSprite("dez_retracting_spring_base", px + 0x10, py + 8, 0, objA0.render_flags, renderQueue + 1)
		return true
	}

	// Trees in the background before the AIZ 2 boss. In 6 Aug 2023 AIR commit 6a4b5dc.
	if (objA0.update_address == 0x05068a)
	{
		// Draw trees over the full screen height, to avoid occasional visible gaps there
		Renderer.drawVdpSprite(px, py+64, size, index, 0x1f00)
		Renderer.drawVdpSprite(px, py-64, size, index, 0x1f00)
		return false
	}

	return base.Standalone.onDrawVdpSprite(px, py, size, index, renderQueue)
}





// Make sure digits drawn in act results do not disappear before leaving the screen.
// Fix from 12 Aug 2023 AIR commit eda7347
// Function taken from maingame\hud\levelresults.lemon
//# translated(0x02de04) end(0x02de4e)
function bool fn02de04()
{
	A1 = 0xffff0000 + u16[A0 + 0x48]
	D0.u16 = u16[A1 + 0x32]
	if (D0.u16 != 0)
	{
	#if STANDALONE
		// In standalone, we don't call "DrawObject", so the visibility flag does not get updated automatically
		s16 px = s16(objA0.position.x.u16) - 0x80
		if (px + objA0.box_size.x >= 0 && px < getScreenWidth())
			objA0.render_flags |= render_flag.VISIBLE
		else
			objA0.render_flags &= ~render_flag.VISIBLE
	#endif

		if (!(objA0.render_flags & render_flag.VISIBLE))
		{
			--u16[A1 + 0x30]
			UnloadObject()
			return true
		}

		if (D0.u8 < u8[A0 + 0x28])
			return false

		objA0.position.x.u16 += (objA0.base_state != 0) ? 0x20 : -0x20
	}
	else
	{
		s16 diff = u16[A0 + 0x46] - objA0.position.x.u16
		if (diff != 0)
		{
			objA0.position.x.u16 += clamp(diff, -0x10, 0x10)
		}
	}
	return false
}







// In Original Mode, don't use AIR's new method for gaining a continue in Slot Machine bonus stage
// Function taken from level\bonus_sm\level_slotmachine.lemon
function void SlotMachine.collectRing()
{
	CollectRing()

	++slotmachine.rings_collected
	if ((slotmachine.rings_collected >= 50 && !original_mode) || (ring_counter >= 50 && original_mode))
	{
		if ((extra_lives_granted & 0x01) == 0)
		{
			extra_lives_granted |= 0x01
			++continues_counter
			playMusic(0xac)

		#if STANDALONE
			if (continues_counter >= 5)
			{
				Game.setAchievementComplete(ACHIEVEMENT_CONTINUES)
			}
		#endif
		}
	}
}



// In Original Mode, don't let Slot Machine bonus stage rings use smooth rotation
// and use the original rotation methods for blocks and other objects
// Function taken from level\bonus_sm\level_slotmachine.lemon
//# address-hook(0x04b356) end(0x04b48e)
function void BonusSM.RenderRotatingMaze()
{
#if STANDALONE
	// We need to draw objects further away as well, so a larger lookup table is needed
	//  -> We need a square of 20x20 blocks instead of only 16x16 blocks
	//  -> Use shared memory for this, namely the start (that is also used by Blue Spheres, temporarily as well)
	u32 lookupTableAddress = 0x800000
	u16 lookupTableSize = 0x14
#else
	u32 lookupTableAddress = 0xffff7800
	u16 lookupTableSize = 0x10
#endif

	s16 cameraX = camera.position.x.u16 + getScreenExtend()		// This is a bit ugly, but it works
	s16 cameraY = camera.position.y.u16

	fn04b4c4()
	fn04b592()

	// The following code updates the positions of blocks around, depending on current rotation
	A1 = lookupTableAddress
	u8 angle = (u8[0xffffe400] & 0xfc)
	s32 sine   = lookupSin(angle)
	s32 cosine = lookupCos(angle)
	s32 stepX = cosine * 0x18
	s32 stepY = sine   * 0x18
	D2.s16 = -(cameraX % 0x18) - (0x0c * (lookupTableSize - 1))
	D3.s16 = -(cameraY % 0x18) - (0x0c * (lookupTableSize - 1))

	for (u8 row = 0; row < lookupTableSize; ++row)
	{
		s32 px = cosine * D2.s16 - sine * D3.s16
		s32 py = cosine * D3.s16 + sine * D2.s16

		for (u8 col = 0; col < lookupTableSize; ++col)
		{
			s16[A1]   = px >> 8
			s16[A1+2] = py >> 8
			px += stepX
			py += stepY
			A1 += 4
			//debugDrawRect(camera.foreground.x.u16 + s16[A1] - 4 + getScreenWidth() / 2, camera.foreground.y.u16 + s16[A1+2] - 4 + getScreenHeight() / 2, 9, 9, 0xe000ff00)
		}

		D3.u16 += 0x18
	}

	// The following code draws the blocks (as sprites)
	A0 = 0xffff3000
	A0 += ((cameraX / 0x18) + (0x10 - lookupTableSize) / 2)
	A0 += ((cameraY / 0x18) + (0x10 - lookupTableSize) / 2) * 0x80

	A4 = lookupTableAddress
	D5 = u8[0xfffff62c]
	A2 = 0xfffff800 + D5.u16 * 8

	for (u8 row = 0; row < lookupTableSize; ++row)
	{
		for (u8 col = 0; col < lookupTableSize; ++col)
		{
			// Get the block type
			u8 blockType = u8[A0]
			++A0
			if (blockType != 0 && blockType <= 0x13)
			{
				// The explicit cast to s16 is needed due to a bug in lemonscript, sorry...
				s16 px = s16(u16[A4]   + getScreenWidth() / 2)
				s16 py = s16(u16[A4+2] + getScreenHeight() / 2)
				if (px >= -0x10 && px < getScreenWidth() + 0x10 && py >= -0x10 && py < getScreenHeight() + 0x10)
				{
					A5 = 0xffff7000 + blockType * 8
					A1 = tableLookupAddress(u32[A5], u16[A5+4] * 2)
					A3 = 0xffff0000 + u16[A5+6]
					D1 = u8[A1] - 1
					++A1
					D3.u16 = px + 0x80
					D2.u16 = py + 0x80

					if (blockType == 0x08)
					{
						// Custom smoother ring animations
						u8 animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8
						if (original_mode)
							animFrame &= 0xfe	// remove the last bit to only draw original game frames in Original Mode
						u64 key = stringformat("ring_0%d", animFrame)
						Renderer.drawCustomSprite(key, px, py, 0x00, 0, 0x9000)
					}
					else
					{
						fn04b490()
					}
				}
			}
			A4 += 4
		}
		A0 += 0x80 - lookupTableSize
	}

	u8[0xfffff62c] = D5.u8
}


// Ensure slot machine blocks do not continue to animate while the game is paused.
// Also adds a check for Classic Mode to Goal block rendering.
// Function taken from level\bonus_sm\level_slotmachine.lemon
//# address-hook(0x04b4c4) end(0x04b54e)
function void fn04b4c4()
{
	if (global.game.paused)
		return

	D0 = (slotmachine.rotation.u8 >> 2) & 0x0f
	A1 = 0xffff700c
	for (u8 i = 0; i < 3; ++i)
	{
		u16[A1] = D0.u16
		A1 += 8
	}
	A1 = 0xffff706c
	for (u8 i = 0; i < 3; ++i)
	{
		u16[A1] = D0.u16
		A1 += 8
	}

	// This updates animations of the blocks
	A1 = 0xffff7005
	--slotmachine.goalblock.animtimer
	if (s8(slotmachine.goalblock.animtimer) < 0)
	{
		slotmachine.goalblock.animtimer = 1
	#if STANDALONE
		// Slow down animation of "Goal" blocks on highest anti-flicker setting
		if (Game.getSetting(SETTING_GFX_ANTIFLICKER) == 2 && !original_mode)
			slotmachine.goalblock.animtimer = 0x0f
	#endif

		++u8[A1 + 0x20]
		if (u8[A1 + 0x20] >= 3)
			u8[A1 + 0x20] = 0
		++slotmachine.goalblock.animframe
		if (slotmachine.goalblock.animframe >= 6)
			slotmachine.goalblock.animframe = 0
	}

	u8[A1 + 0x48] = slotmachine.goalblock.animframe
	u8[A1 + 0x40] = static_rings.animframe
	--slotmachine.peppermintblock.animtimer
	if (s8(slotmachine.peppermintblock.animtimer) < 0)
	{
		slotmachine.peppermintblock.animtimer = 3
		slotmachine.peppermintblock.animframe = (slotmachine.peppermintblock.animframe + 1) & 0x03
	}
	u8[A1 + 0x38] = slotmachine.peppermintblock.animframe
}



//# address-hook(0x04bf9a) end(0x04c012)
function void fn04bf9a()
{
	D0.u8 = (u8[0xffffe400] & 0xfc)
	LookupSinCos()
	A1 = 0xffffb000
	s32 px = 0x0460 - objA1.position.x.u16
	s32 py = 0x0430 - objA1.position.y.u16
	D2.s32 = (px * D1.s16 - py * D0.s16) >> 8
	D3.s32 = (px * D0.s16 + py * D1.s16) >> 8
	D2.u16 += objA1.position.x.u16
	D3.u16 += objA1.position.y.u16
	objA0.position.x.u16 = D2.u16
	objA0.position.y.u16 = D3.u16
	level.display_routine = D2.u16
	u16[0xffffeed4] = D3.u16

	A2 = A0 + 0x34
	A1 = 0xffffb000
	fn04c014()

	--objA0.animation.timer
	if (s8(objA0.animation.timer) < 0)
	{
		objA0.animation.timer = 0x01
		++objA0.animation.sprite
		if (objA0.animation.sprite >= 0x06)
		{
			objA0.animation.sprite = 0
		}
	}
}





// Loops SEGA logo and Sonic 3 title screen instead of starting demos
// as well as set the appropriately colored image
// Function taken from menus\titlescreen.lemon
//# address-hook(0x003e32) end(0x004342)
function void TitleScreen()
{
	/*
	if (original_mode)
		Renderer.setScreenSize(320, 224)
	else
		Renderer.setScreenSize(400, 224)
	*/

	original_mode = 0
	time_attack = 0
	Renderer.setScreenSize(400, 224)

	playMusic(MUSIC_CTRL_FADEOUT)
	kosinski.queue_size = 0

	zeroMemory(0xffffff10, 0x6c)

	ClearPatternLoadingQueue()
	global.zone_act = 0
	FadeOutScreenBlocking()
	set_status_register(0x2700)

	VDP.Config.enableHInt(false)
	VDP.Config.setNameTableBasePlaneA(0xc000)
	VDP.Config.setNameTableBasePlaneB(0xe000)
	VDP.Config.setPlayfieldSizeInPixels(512, 256)
	VDP.Config.setupWindowPlane(false, 0)			// Disable window plane
	VDP.Config.setVerticalScrolling(false, 0xff)	// Good old horizontal scrolling mode
	VDP.Config.setBackdropColor(0)
	VDP.Config.setRenderingModeConfiguration(false)

	water.fullscreen = 0
	level.water_present = 0

	fn0011ca()

	zeroMemory(0xffffac00, 0x400)
	zeroMemory(0xffffb000, 0x2000)
	zeroMemory(0xfffff700, 0x100)
	zeroMemory(0xffffee00, 0x100)

#if STANDALONE
	Renderer.resetSprites()

	// Move planes a bit to the right
	for (u8 i = 0; i < getScreenHeight(); ++i)
		u32[0xffffe000 + i*4] = getScreenExtend() * 0x10001
#endif

	fn01aa6e()

	zeroMemory(0xfffffc00, 0x100)

	checkpoint.number = 0
	global.stage_type = 0
	debug_mode.state = 0
	global.rolling_demo = 0
	u16[0xfffff634] = 0
	competition_mode.active = 0
	global.level_started = 0
	debug_mode.enabled.u8 = 0
	competition_mode.active = 0
	u16[0xffffffe4] = 0
	u16[0xffffffe6] = 0
	bluespheres.minigame_mode = 0
	global.demo_countdown = 359		// 6 seconds (minus one frame)
	u16[0xfffffb00] = 0
	u32[0xfffffbfc] = 0xfffffb00

#if STANDALONE
	if (Game.getSetting(SETTING_TITLE_SCREEN))
#else
	if (global.lock_on_state != 0)
#endif
	{
		// Sonic & Knuckles title screen
		TitleScreen_SK()
		return
	}

	Kosinski.decompress(0x350d26, 0xffff0000)	// After this, A1 points to where uncompressed data ends
	updateSpritePattern(0xffff0000, 0x0000, A1.u16 >> 1)

	Enigma.decompress(0x34f6a0, 0xffff8000, 0x0000)
	if ((global.region_code & 0x80) == 0)
	{
		u32[0xffff83ac] = 0
	}
	copyRectToVRAM(0xffff8000, 0xc000, 0x28, 0x1c)

	copyMemory(0xfffffc80, 0x00460c, 0x20)

	global.demo_countdown = 240		// 4 seconds
	VDP.Config.setActiveDisplay(true)
	Menu.FadeInAfterInit()

#if STANDALONE
	// Stop any music that might be playing or restarting (this can happen after aborting a rolling demo)
	playMusic(MUSIC_CTRL_STOP)
#endif
	playMusic(0xff)

	global.demo_countdown = 180		// 3 seconds
	while (global.demo_countdown != 0)
	{
		global.frame_state = 0x14
		waitForNextFrame()
	@EntryPoint_003fd2:

		if (control.pad1.pressed & CONTROL_START)
			break

	#if STANDALONE
		Renderer.resetSprites()
		Renderer.drawCustomSprite("original_game_by", getScreenWidth() / 2 - 85, 60, 0x00, 0, 0x2000, 0, 96)
	#endif
	}

#if !STANDALONE
	playMusic(0xfe)
#endif

	// While loop: SEGA logo background fade from white to black
	A1 = 0x00459c
	while (true)
	{
		global.frame_state = 0x02
		waitForNextFrame()

		copyMemory(0xfffffc00, A1, 0x0e)
		if (u16[A1] == 0)
			break

		A1 += 0x0e

	#if STANDALONE
		Renderer.resetSprites()
		if (u8[0xfffffc01] & 0x0e)
			Renderer.drawCustomSprite("original_game_by", getScreenWidth() / 2 - 85, 60, 0x00, 0, 0x2000, 0, u16(u8[0xfffffc01] & 0x0e) * 96 / 0x0e)
	#endif

		cheatEntry = 0
	}

	outro.wait_time = 0
	u16[0xfffff662] = 0
	u8[0xffffffbc] = 0xff
	titleintro.frames = 0
	titleintro.animstep = 1
	D0 = 1
	fn00440c()

	global.demo_countdown = (global.region_code & 0x40) ? 750 : 900
#if STANDALONE
	// Slightly increase the wait time until demo starts
	global.demo_countdown += 20
#endif

	Kosinski.addToDecompressionQueue(0x351c86, 0xffff0000)
	playMusic(0x25)

	// While loop: Intro sequence with Sonic running towards the camera
	while (true)
	{
		global.frame_state = 0x04
		Kosinski.ProcessDecompressionQueue()

		waitForNextFrame()

	#if STANDALONE
		// Overwrite two frames with custom widescreen versions
		if (titleintro.animstep == 7)
		{
			Renderer.drawCustomSprite("intro_wideframe1", getScreenExtend() - 40, 0, 0x00, 0, 0x5000)
		}
		else if (titleintro.animstep == 8)
		{
			Renderer.drawCustomSprite("intro_wideframe2", getScreenExtend() - 40, 0, 0x00, 0, 0x5000)
		}
	#endif

		fn0043d4()
		UpdateGameObjects()
		RenderSprites()
		LoadRequiredSpritePatterns()

		if (control.pad1.pressed & CONTROL_START)
			break

		if (titleintro.animstep >= 12)
			break
	}

	// White screen
	titleintro.animstep = 12
	fillMemory_u16(0xfffffc00, 0x80, 0x0eee)

#if STANDALONE
	titleintro.frames = 15
	global.frame_state = 0x04
	for (u8 k = 0; k < titleintro.frames; ++k)
	{
		waitForNextFrame()
	}

	// This is to make sure screen stays white in the next frame even if skipping the intro
	VDP.Config.setActiveDisplay(false)
#else
	titleintro.frames = 3
	global.frame_state = 0x04
	waitForNextFrame()
#endif

	// Fill the planes with decompressed screen content
	Kosinski.decompress(0x359fc6, 0xffff0000)	// After this, A1 points to where uncompressed data ends
	updateSpritePattern(0xffff0000, 0x0000, A1.u16 >> 1)

	Enigma.decompress(0x350018, 0xffff8000, 0x8000)
	copyRectToVRAM(0xffff8000, 0xc000, 0x28, 0x1c)

	Enigma.decompress(0x350112, 0xffff8000, 0x4000)
	copyRectToVRAM(0xffff8000, 0xe000, 0x28, 0x1c)

	global.frame_state = 0x04
	waitForNextFrame()

#if STANDALONE
	VDP.Config.setActiveDisplay(true)
#endif

	copyMemory(0xfffffc80, 0x0047ac, 0x80)

	// Load patterns used in title screen
	{
		// Large banner
		Nemesis.loadDataToVRAM(0x35026c, 0xa000)

		// Menu options
		Nemesis.loadDataToVRAM(0x2d55e4, 0xd000)	// originally 0x004d2a but moved to new rominject address due to original space being six bytes too small

		// Wiggling finger, twinkle, Tails & Tornado in BG
		Nemesis.loadDataToVRAM(0x2c49cc, 0x8000)

		// "& Knuckles"
		Nemesis.loadDataToVRAM(0x0d6498, 0x9800)
	}

	u32[0xffffb000] = 0x00482c
	u32[0xffffb04a] = 0x004a5c
	u32[0xffffb0de] = 0x004a1e
	u32[0xffffb128] = 0x004ae4
	u32[0xffffb172] = 0x004b54
	u32[0xffffb1bc] = 0x004bb2
	u32[0xffffb206] = 0x00496a
	titleintro.frames = 0

	#if STANDALONE
		global.whiteflash_timeout = 25
		airHighlightAnimationTimer = 0

		// This is needed for the background to be shown in first frame at all (when VDP sprite rendering seems to be disabled)
		Renderer.resetSprites()
		if (palette_set < 2 || original_mode)
			Renderer.drawCustomSprite("bg_title_screen", getScreenExtend() - 40, 0, 0x00, 0, 0x1100)
		else
			Renderer.drawCustomSprite("bg_title_screen_new", getScreenExtend() - 40, 0, 0x00, 0, 0x1100)
	#endif

	while (true)
	{
		global.frame_state = 0x04
		waitForNextFrame()
	@EntryPoint:

		UpdateGameObjects()
		RenderSprites()
		LoadRequiredSpritePatterns()

	#if STANDALONE
		// Allow the player to press Start before the logo animation is finished already; only wait for the short white flash to finish
		if (global.whiteflash_timeout > 0)
			continue
	#else
		if (u32[0xffffb094] == 0)
			continue
	#endif

		if (global.demo_countdown == 0)
			break

		Titlescreen.EnterCheat()

		if (((control.pad1.pressed | control.player2.pressed) & 0xe0) && !(Input.buttonDown(BUTTON_L) || Input.buttonDown(BUTTON_R)))	// usually "& CONTROL_START", but switched to START, A, or C
		{
			global.game_mode = 0x0c
			lives_counter = 3
			u8[0xfffffec6] = 3
			ring_counter = 0
			timer.alldata = 0
			player.score = 0
			u16[0xfffffed0] = 0
			u32[0xfffffed2] = 0
			u32[0xfffffed6] = 0
			continues_counter = 0
			player.next_life_score = 5000
			u32[0xffffffc4] = 5000

			playSound(MUSIC_CTRL_FADEOUT)

//		#if STANDALONE
//			// In S3AIR, there is no choice, sorry...
//			global.game_mode = 0x58 // use 0x58 for main menu
//
//		#else
			D0 = u8[0xffffff86]
			if (D0.u8 == 0)
			{
				// DAGE Main Menu // Data Select
				global.game_mode = 0x58	// 0x4c
			}
			else if (D0.u8 == 1)
			{
				// Competition Mode
				// global.game_mode = 0x38
				FadeOutScreenBlocking()
				exitGame = 1
			//	Game.returnToMainMenu()
				Audio.fadeOutChannel(0, 0x40)	// Do the rest of music fade out relatively quickly
			//	yieldExecution()
			}
			else	// this should be inaccessible
			{
				// Level Select
				global.game_mode = 0x28
			}
//		#endif
			return
		}
	}

	// Start rolling demo
	playSound(MUSIC_CTRL_FADEOUT)

#if STANDALONE
	if (u16[0xffffffd2] == 4)	// Skip FBZ demo for now, as it's not in the game yet
		++u16[0xffffffd2]
	if (u16[0xffffffd2] == 5)	// Skip SOZ demo because it's broken
		++u16[0xffffffd2]
	if (u16[0xffffffd2] == 6)	// Skip Blue Spheres demo because it's also broken
		u16[0xffffffd2] = 0
#endif

	u16[0xffffef7a] = u16[0xffffffd2]
	D0.u16 = (u16[0xffffffd2] & 0x07) * 2
	D0.u16 = u16[0x004344 + D0.s16]
	global.zone_act = D0.u16
	global.zone_act.apparent = D0.u16
	checkpoint.zone_act = D0.u16

	D1.u16 = u16[0xffffffd2] + 1
	if (global.lock_on_state == 0)
	{
		if (D1.u16 == 3)
		{
			D1 = 4
		}
		else if (D1.u16 >= 7)
		{
			D1 = 0
		}
	}
	else
	{
		if (D1.u16 >= 3)
		{
			D1 = 0
		}
	}

	u16[0xffffffd2] = D1.u16
	if (D0.s16 < 0)
	{
		// Blue Spheres rolling demo
	//	global.game_mode = 0x34		// prevents special stage demo from starting
		global.next_bluespheres = 1
		global.sk_bluespheres = 1
		global.zone = 0x07
		u16[0xffffffb0] = 0
		u32[0xffffffb2] = 0
		u16[0xffffffb6] = 0
		u8[0xffffffb8] = 0
		u8[0xffffffb3] = 0x02
	}
	else
	{
		// Normal Game rolling demo
	//	global.game_mode = 0x08		// prevents standard demo from starting
	}

	global.rolling_demo = 1
	lives_counter = 3
	u8[0xfffffec6] = 3
	ring_counter = 0
	timer.alldata = 0
	player.score = 0
	u16[0xfffffed0] = 0
	u32[0xfffffed2] = 0
	u32[0xfffffed6] = 0
	player.next_life_score = 5000
	u32[0xffffffc4] = 5000
}

// Move title screen Sonic and the ring upward from his A.I.R. position.
// Function taken from menus\titlescreen.lemon
//# address-hook(0x00486c) end(0x0048d8)
function void fn00486c()
{
	D2.u8 = u8[A0 + 0x34]
	u32[A0 + 0x30] += objA0.velocity.y << 8
	D0.u16 = u16[A0 + 0x30]
	u8[A0 + 0x34] = 0
	D1.u16 = 0x40

	if (D0.u16 == 0 && objA0.velocity.y == 0xffa5)
	{
		objA0.update_address = 0x0048dc
		u32[0xffffb094] = 0x004924		// Trademark
	}
	else
	{
		if (D0.s16 >= 0)
		{

			u8[A0 + 0x34] = 0xff
			D1.u16 = 0xffc0
		}

		objA0.velocity.y += D1.u16
		if (D2.u8 != u8[A0 + 0x34])
		{
			objA0.velocity.y >>= 1
		}
	}

	D0.s16 = 0xd4 - s16[A0 + 0x30]
	objA0.position.y.u16 = D0.u16
// #if STANDALONE
	// Move it down
	objA0.position.y.u16 += 0x10
// #else

	// Movement of Sonic and the ring around him
	if (scrolloffset.y.planeA != 0x08)
	{
		++scrolloffset.y.planeA
	}
// #endif

	fn0048dc()
}

function void Titlescreen.EnterCheat()
{
	if (Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R) && !cheatStars)
	{
		Renderer.drawCustomSprite("blackscreen", 0, 0, 0x00, SPRITE_FLAG_PRIO, 0xfffe, 0, 0xc0)
		Renderer.drawText("sonic3_fontB", getScreenWidth()/2, getScreenHeight()/2, "ENTER CHEAT:", 0xffffffff, 5, 0, 0xffff, 0)
	}

	if (!(Input.buttonDown(BUTTON_L) || Input.buttonDown(BUTTON_R)) && cheatEntry != 11)
		cheatEntry = 0
	else if (cheatEntry == 0 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_A))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 1 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_B))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 2 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_RIGHT))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 3 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_A))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 4 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_C))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 5 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_A))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 6 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_DOWN))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 7 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_A))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 8 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_B))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 9 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R))
	{
		if ((control.pad1.pressed & CONTROL_RIGHT))
			++cheatEntry
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
	else if (cheatEntry == 10 && Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R) && (control.pad1.pressed | CONTROL_A) && !cheatStars)
	{
		if ((control.pad1.pressed & CONTROL_A))
		{
			++cheatEntry
			cheatStars = 100
			playSound(0x46)
		}
		else if (control.pad1.pressed)
			cheatEntry = 0
	}
}

// Again, make sure to draw the title screen image with the correct colors. Also remove START GAME.
// Function taken from menus\titlescreen.lemon
//# address-hook(0x0048dc) end(0x0048fe)
function void fn0048dc()
{
	PrintVersionNumber()

	--objA0.animation.timer
	if (s8(objA0.animation.timer) < 0)
	{
		objA0.animation.timer = 9
		objA0.animation.frame = (objA0.animation.frame + 4) & 0x1c
	}

	u32[0xfffffcda] = u32[0x004904 + objA0.animation.frame]
	DrawObject()

#if STANDALONE
	// Here is a good place to draw the widescreen background
	if (palette_set < 2 || original_mode)
		Renderer.drawCustomSprite("bg_title_screen", getScreenExtend() - 40, 0, 0x00, 0, 0x1100)
	else
	{
		Renderer.drawCustomSprite("bg_title_screen_new", getScreenExtend() - 40, 0, 0x00, 0, 0x1100)
		s64 rippleShiftIndex = (global.demo_countdown / 12) % 66
		Renderer.drawCustomSprite("bg_title_screen_new_line200", SwScrl_RippleData[(rippleShiftIndex + 23) % 66] / 3, 200, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line201", SwScrl_RippleData[(rippleShiftIndex + 22) % 66] / 3, 201, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line202", SwScrl_RippleData[(rippleShiftIndex + 21) % 66] / 3, 202, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line203", SwScrl_RippleData[(rippleShiftIndex + 20) % 66] / 3, 203, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line204", SwScrl_RippleData[(rippleShiftIndex + 19) % 66] / 3, 204, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line205", SwScrl_RippleData[(rippleShiftIndex + 18) % 66] / 3, 205, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line206", SwScrl_RippleData[(rippleShiftIndex + 17) % 66] / 3, 206, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line207", SwScrl_RippleData[(rippleShiftIndex + 16) % 66] / 3, 207, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line208", SwScrl_RippleData[(rippleShiftIndex + 15) % 66] / 3, 208, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line209", SwScrl_RippleData[(rippleShiftIndex + 14) % 66] / 3, 209, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line210", SwScrl_RippleData[(rippleShiftIndex + 13) % 66] / 3, 210, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line211", SwScrl_RippleData[(rippleShiftIndex + 12) % 66] / 3, 211, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line212", SwScrl_RippleData[(rippleShiftIndex + 11) % 66] / 3, 212, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line213", SwScrl_RippleData[(rippleShiftIndex + 10) % 66] / 3, 213, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line214", SwScrl_RippleData[(rippleShiftIndex +  9) % 66] / 3, 214, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line215", SwScrl_RippleData[(rippleShiftIndex +  8) % 66] / 3, 215, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line216", SwScrl_RippleData[(rippleShiftIndex +  7) % 66] / 3, 216, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line217", SwScrl_RippleData[(rippleShiftIndex +  6) % 66] / 3, 217, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line218", SwScrl_RippleData[(rippleShiftIndex +  5) % 66] / 3, 218, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line219", SwScrl_RippleData[(rippleShiftIndex +  4) % 66] / 3, 219, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line220", SwScrl_RippleData[(rippleShiftIndex +  3) % 66] / 3, 220, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line221", SwScrl_RippleData[(rippleShiftIndex +  2) % 66] / 3, 221, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line222", SwScrl_RippleData[(rippleShiftIndex +  1) % 66] / 3, 222, 0, 0, 0x1101)
		Renderer.drawCustomSprite("bg_title_screen_new_line223", SwScrl_RippleData[(rippleShiftIndex +  0) % 66] / 3, 223, 0, 0, 0x1101)
	}

	// Also draw the "Angel Island Revisited" text and others
	++airHighlightAnimationTimer
	s16 time = airHighlightAnimationTimer - 80

	u16 px = getScreenWidth() / 2
	u16 py = objA0.position.y.u16 - 48	// - 53
	if (palette_set >= 2)
		Renderer.drawCustomSprite("title_screen_air_new", px, py - 5, 0x00, SPRITE_FLAG_PRIO, 0xa000)
	else
		Renderer.drawCustomSprite("title_screen_air", px, py - 4, 0x00, SPRITE_FLAG_PRIO, 0xa000)	// Angel Island Revisited. Subtracted 4 from y position in DAGE.

	if (time > 0)
	{
		if (time < 65)
		{
			u8 alpha = (time < 20) ? (time * 255 / 20) : ((65 - time) * 255 / 45)
			if (palette_set >= 2)
				Renderer.drawCustomSprite("title_screen_air_new_h", px, py - 5, 0x00, SPRITE_FLAG_PRIO, 0xa001, 0, alpha)	// Angel Island Revisited flash. Subtracted 4 from y position in DAGE.
			else
				Renderer.drawCustomSprite("title_screen_air_h", px, py - 4, 0x00, SPRITE_FLAG_PRIO, 0xa001, 0, alpha)	// Angel Island Revisited flash. Subtracted 4 from y position in DAGE.
		}

	//	Renderer.drawCustomSprite("title_screen_start", getScreenWidth() / 2, 208 + max((50 - time) * 2, 0), 0x00, 0, 0x9f7e)	// don't draw START GAME in DAGE
	}

	Renderer.drawCustomSprite("title_screen_cr", getScreenWidth() - 88, 204, 0x00, 0, 0x9f7e)

	// Clear "Sonic The Hedgehog" text in VRAM
	for (u16 x = 0xb000; x < 0xb700; x += 0x80)
		for (u16 y = 0; y < 0x40; y += 2)
			setVRAM(x + y, 0)
#endif
}




// Reintroduce the title screen menu in DAGE.
// Functions taken from menus\titlescreen.lemon
//# address-hook(0x004a5c) end(0x004a82)
function void fn004a5c()
{
// #if GAMEAPP
//	// Leave this out in S3AIR
//	UnloadObject()
//	return
// #endif

	objA0.position.x.u16 = 0xf0 + getScreenExtend()
	objA0.position.y.u16 = 0x0140
	objA0.mapping_offset = 0x004c9c
	objA0.sprite_attributes = (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE2 | (TitleScreen.Menu.targetInVRAM >> 5))
	titlescreen.selection &= 0x01
	objA0.animation.sprite = titlescreen.selection

	objA0.update_address = 0x004a88
	fn004a88()
}

//# address-hook(0x004a88) end(0x004ade)
function void fn004a88()
{
	D2 = titlescreen.selection

	D0.u8 = (control.pad1.pressed | control.pad2.pressed)
	if ((D0 & CONTROL_UP) && !(Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R)))
	{
		--D2.u8
		if (D2.s8 < 0)
		{
			D2.u8 = (levelselect.unlocked) ? 2 : 1
		}
	}
	if ((D0 & CONTROL_DOWN) && !(Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R)))
	{
		++D2.u8
		if (levelselect.unlocked)
		{
			if (D2.u8 >= 3)
				D2 = 0
		}
		else
		{
			D2.u8 &= 0x01
		}
	}

	objA0.animation.sprite = D2.u8
	titlescreen.selection = D2.u8

	if ((D0.u8 & (CONTROL_UP | CONTROL_DOWN)) != 0 && !(Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R)))
	{
		playSound(SFX_CLICK)
	}
	DrawObject()
}



// Hide the SONIC and KNUCKLES menu options on the S&K title screen.
// This function handles how the menu options work.
// Function taken from menus\titlescreen_sk.lemon
//# address-hook(0x005b42) end(0x005c0a)
function void fn005b42()
{
	VDP.setupVRAMWrite(0x8c40)
	VDP.zeroVRAM(0x0a80)

	D2 = titlescreen.selection
	D0.u8 = objA0.value26 & 0x7f
	if (D0.u8 == 0)
	{
		D0.u8 = control.pad1.pressed
		if ((D0 & CONTROL_UP) && !(Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R)))
		{
			objA0.value26 -= 8
			s8[A0 + 0x27] = -8
			--D2.u8
			if (D2.u8 == 0xff)
			{
				D2.u8 = 1
			}
		}
		if ((D0 & CONTROL_DOWN) && !(Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R)))
		{
			objA0.value26 += 8
			s8[A0 + 0x27] = 8
			++D2.u8
			D2.u8 &= 0x01
			if (D2.u8 >= 3)
			{
				D2 = 0
			}
		}
		titlescreen.selection = D2.u8

		if ((D0.u8 & (CONTROL_UP | CONTROL_DOWN)) != 0 && !(Input.buttonDown(BUTTON_L) && Input.buttonDown(BUTTON_R)))
		{
			playSound(SFX_CLICK)
		}
	}

	if (objA0.value26 & 0x7f)
	{
		objA0.value26 += u8[A0 + 0x27]
	}

	D0.u8 = objA0.value26 + 0x98
	LookupSinCos()
	D1.s32 = s32(D1.s16) * 0x05
	D0.s32 = s32(D0.s16) * 0x05
	D1.s32 >>= 8
	D0.s32 >>= 8
	D3.u16 = u16[A0 + 0x44] - D1.s16
	D2.u16 = u16[A0 + 0x46] - D0.s16
	D1.u16 += u16[A0 + 0x44]
	D0.u16 += u16[A0 + 0x46]
	D4 = 0
	D5 = 2
	D6.u8 = objA0.value26 - 0xa0
	if (D6.s8 < 0)
	{
		u32 tmp
		tmp = D3
		D3 = D1
		D1 = tmp
		tmp = D2
		D2 = D0
		D0 = tmp
		tmp = D5
		D5 = D4
		D4 = tmp
	}
	++D5.u8

	A2 = A0 + 0x18
	u16[A2]   = D1.u16
	u16[A2+2] = D0.u16
	u16[A2+4] = D4.u16
	u16[A2+6] = D3.u16
	u16[A2+8] = D2.u16
	u8[A2+11] = D5.u8

	DrawObject()

	PrintVersionNumber()

	Renderer.drawCustomSprite(stringformat("sktitle_start_game_%d", titlescreen.selection), getScreenWidth()/2, getScreenHeight() - 24, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)
	Renderer.drawCustomSprite(stringformat("sktitle_air_menu_%d", titlescreen.selection), getScreenWidth()/2, getScreenHeight() - 12, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)
}


// Add future A.I.R. version fix to position Sonic properly at all screen widths in the S&K title screen.
// Function taken from menus\titlescreen_sk.lemon
//# address-hook(0x00565a) end(0x0056e2)
function void fn00565a()
{
#if STANDALONE
	// Fix for Sonic's position in widescreen, #contributed by TheMushrunt
	objA0.position.x.u16 = 0xe8 + getScreenExtend()
#endif
	if (objA0.position.y.u16 != 0xf0)
		++objA0.position.y.u16

	if (u16[0xffffeec0] == 0x03)
	{
		objA0.sprite_attributes |= sprite_attribute.PRIORITY
		if (camera.position.y.u16 >= 0xe0)
		{
			if (camera.position.y.u16 == 0xe0)
			{
			#if !STANDALONE
				set_status_register(0x2700)
			#endif
				copyRectToVRAM(0xffff8e40, 0xc000, 0x28, 0x1c)
			#if !STANDALONE
				set_status_register(0x2300)
			#endif

				objA0.animation.timer = 6
			}

			if (camera.position.y.u16 != 0x0100)
			{
				camera.position.y.u16 += 8
			}
			else
			{
				objA0.update_address = 0x0056e8
				fn0056e8()
			}
			return
		}

		camera.position.y.u16 += 8
	#if STANDALONE
		// Timing for standalone needs to be different, as it's loading the data faster
		if (camera.position.y.u16 == 0xd0)
	#else
		if (camera.position.y.u16 == 0xc8)
	#endif
		{
			Kosinski.addToDMAQueue(0x0d0e12, TitleScreenSK.Menu.targetInVRAM)		// This is actually the tiles for Sonic's landing animation, its just using the same VRAM location as the menu
		}

		A1 = 0xffff8580
		D0 = 0x40000003
		D1.u16 = camera.position.y.u16
		fn005ce8()
	}

	DrawObject()
}


// Loops SEGA logo and S&K title screen instead of starting demos
// Function taken from menus\titlescreen_sk.lemon
//# address-hook(0x005048) end(0x00552c)
function void TitleScreen_SK()
{
	/*
	if (original_mode)
		Renderer.setScreenSize(320, 224)
	else
		Renderer.setScreenSize(400, 224)
	*/

	original_mode = 0
	Renderer.setScreenSize(400, 224)

	Kosinski.decompress(0x0cca20, 0xffff0000)
	Kosinski.decompress(0x0cc6a0, A1)
	Kosinski.decompress(0x0d2504, A1)
	updateSpritePattern(0xffff0000, 0x0000, 0x0e20)
	updateSpritePattern(0xffff1c40, 0x9380, 0x1640)

	Kosinski.decompress(0x0d33e4, 0xffff4e00)
	updateSpritePattern(0xffff4e00, 0xd000, 0x0720)

	Kosinski.decompress(0x0d3a64, 0xffff5d00)
	updateSpritePattern(0xffff5d00, 0xf400, 0x0150)

	Enigma.decompress(0x0cba68, 0xffff7400, 0x849c)
	if ((global.region_code & 0x80) == 0)
	{
		D0.u16 = 0xa49c
		u16[0xffff775c] = D0.u16
		u16[0xffff775e] = D0.u16
		u16[0xffff7760] = D0.u16
		u16[0xffff77ac] = D0.u16
		u16[0xffff77ae] = D0.u16
		u16[0xffff77b0] = D0.u16
	}
	copyRectToVRAM(0xffff7400, 0xc000, 0x28, 0x1c)

	Enigma.decompress(0x0cc3aa, 0xffff7cc0, 0x0000)

	A1 = 0xffff7cc0
	D0 = 0x60000003
	fn005d24()

	Enigma.decompress(0x0cbb32, 0xffff8580, 0x80e2)
	Enigma.decompress(0x0cbce0, 0xffff8e40, 0x80e2)
	Enigma.decompress(0x0cbf3e, 0xffff9700, 0x80e2)
	Enigma.decompress(0x0cc1c4, 0xffff9fc0, 0x80e2)

	Kosinski.addToDecompressionQueue(0x0d4ba6, 0xffff4800)

	A1 = 0xfffffc80
	for (u8 i = 0; i < 4; ++i)
	{
		u16[A1] = 0
		fillMemory_u16(A1 + 2, 0x1e, 0x0eee)
		A1 += 0x20
	}
	copyMemory(0xfffffca0, 0x0055a8, 0x20)

	global.demo_countdown = (global.region_code & 0x40) ? 150 : 180

	VDP.Config.setActiveDisplay(true)

	Menu.FadeInAfterInit()
	playMusic(0xff)

	while (true)
	{
		while (true)
		{
		#if STANDALONE
			Renderer.resetSprites()
			Renderer.drawCustomSprite("original_game_by", getScreenWidth() / 2 - 85, 60, 0x00, 0, 0x2000, 0, min((180 - global.demo_countdown) * 8, 96))
		#endif

			global.frame_state = 0x14
			Kosinski.ProcessDecompressionQueue()
			waitForNextFrame()

			Kosinski.ProcessModules()
			if (kosinski.waiting_modules == 0)
				break
		}

		if ((control.pad1.pressed & CONTROL_START) || global.demo_countdown == 0)
			break
	}

	playMusic(0xfe)

	copyMemory(0xfffffc80, 0x005588, 0x80)

	Kosinski.addToDMAQueue(0x0cd910, 0x1c40)

	palette_fade.range = 0x3f
	global.fade_timer = 0x16
	u32[0xffffb000] = 0x5628
	u32[0xffffb04a] = 0x5770
	u32[0xffffb094] = 0x5856

	playMusic(0x25)

	lives_counter = 3
	global.demo_countdown = (global.region_code & 0x40) ? 900 : 1080

	while (true)
	{
		global.frame_state = 0x1a
		Kosinski.ProcessDecompressionQueue()
		waitForNextFrame()

		if (global.fade_timer != 0)
		{
			--global.fade_timer
			FadeInFromWhite()
		}

		UpdateGameObjects()
		RenderSprites()
		fn005d94()
		Kosinski.ProcessModules()

		if ((control.pad1.pressed & CONTROL_START) == 0)
		{
			if (u32[0xffffb0de] != 0)
				break
		}
		else
		{
			if (global.fade_timer == 0)
			{
				A0 = 0xffffb128
				fn005972()

				u32[0xffffb04a] = 0x005802
				u16[0xffffb04a + 0x2e] = 0x0140 + getScreenExtend() // Fix for the Death Egg not in the right position when skipping intro, #contributed by TheMushrunt
				u16[0xffffb07c] = 0x70
				u16[0xffffeec0] = 0x03

				camera.screenshake.state = 0
				D0.u16 = 0x0100
				scrolloffset.y.planeB = D0.u16
				scrolloffset.y.planeB = D0.u16
				camera.position.y.u16 = D0.u16
				u16[0xffffee64] = D0.u16

				A0 = 0x005608
				A2 = 0xfffffc20
				for (u8 i = 0; i < 8; ++i)
				{
					u32[A2] = u32[A0]
					u32[A2 + 0x80] = u32[A0]
					A0 += 4
					A2 += 4
				}

				fn005d94()
				global.frame_state = 0x1a
				waitForNextFrame()

				set_status_register(0x2700)
				copyRectToVRAM(0xffff7cc0, 0xe000, 0x28, 0x1c)

				A0 = 0xffffb000
				fn00571e()
				break
			}
		}
	}

	while (true)
	{
		while (true)
		{
			global.frame_state = 0x1a
			Kosinski.ProcessDecompressionQueue()
			waitForNextFrame()

			if (global.fade_timer != 0)
			{
				--global.fade_timer
				FadeInFromWhite()
			}

			UpdateGameObjects()
			RenderSprites()
			fn005d94()
			Kosinski.ProcessModules()

			if (u32[0xffffb172] != 0)
				break
		}

		if (global.demo_countdown == 0)
			break

		Titlescreen.EnterCheat()

		if (!(((control.pad1.pressed | control.player2.pressed) & 0xe0) && !(Input.buttonDown(BUTTON_L) || Input.buttonDown(BUTTON_R))))	// usually "& CONTROL_START", but switched to START, A, or C
			continue

		global.game_mode = 0x0c
		lives_counter = 3
		u8[0xfffffec6] = 3
		ring_counter = 0
		timer.alldata = 0
		player.score = 0
		u16[0xfffffed0] = 0
		u32[0xfffffed2] = 0
		u32[0xfffffed6] = 0
		continues_counter = 0
		player.next_life_score = 5000
		u32[0xffffffc4] = 5000

		playSound(MUSIC_CTRL_FADEOUT)

	#if !STANDALONE
		// Is this even possible...?
		if (u8[0xffffff86] >= 0x02)
		{
			// Level Select
			global.game_mode = 0x28
			return
		}
	#endif

		levelselect.characters = u8[0xffffff86] * 2 + 1
		D0.u16 = 0x0700
		global.zone_act = D0.u16
		global.zone_act.apparent = D0.u16
		checkpoint.zone_act = D0.u16
		u16[0xfffffe16] = 0
		u16[0xffffffb0] = 0
		u32[0xffffffb2] = 0
		u16[0xffffffb6] = 0
		u8[0xffffffb8] = 0
		level.giantrings_clear = 0
		global.active_saveslot = 0

	#if STANDALONE
		// Use character choice to say which menu to go to
		if (u8[0xffffff86] == 0)	// SONIC selected
			global.game_mode = 0x58
		else						// KNUCKLES selected
		{
			FadeOutScreenBlocking()
			exitGame = 1
		//	Game.returnToMainMenu()
			Audio.fadeOutChannel(0, 0x40)	// Do the rest of music fade out relatively quickly
		//	yieldExecution()
		}
	#else
		if (levelselect.unlocked && (control.pad1.state & CONTROL_A))
		{
			// Level Select
			global.game_mode = 0x28
		}
	#endif
		return
	}

	// Start rolling demo
	playSound(MUSIC_CTRL_FADEOUT)

	D0.u16 = max(u16[0xffffffd2], 3)
	u16[0xffffffd2] = D0.u16
	u16[0xffffef7a] = D0.u16
	D0.u16 = (D0.u16 & 0x07) * 2
	D0.u16 = u16[0x004344 + D0.u16]
	global.zone_act = D0.u16
	global.zone_act.apparent = D0.u16
	checkpoint.zone_act = D0.u16

	D1.u16 = u16[0xffffffd2] + 1
	if (D1.u16 >= 7)
		D1 = 3
	u16[0xffffffd2] = D1.u16

	if (D0.s16 < 0)
	{
//		global.game_mode = 0x34		// removed call to start special stage demo
		global.next_bluespheres = 1
		global.sk_bluespheres = 1
		global.zone = 0x07
		u16[0xffffffb0] = 0
		u32[0xffffffb2] = 0
		u16[0xffffffb6] = 0
		u8[0xffffffb8] = 0
	}
	else
	{
		if (D0.u16 == 0x0700)
		{
			fn00552e()
		}
//		global.game_mode = 0x08		// removed call to start standard demo
	}

	global.rolling_demo = 1
	lives_counter = 3
	u8[0xfffffec6] = 3
	ring_counter = 0
	timer.alldata = 0
	player.score = 0
	u16[0xfffffed0] = 0
	u32[0xfffffed2] = 0
	u32[0xfffffed6] = 0
	player.next_life_score = 5000
	u32[0xffffffc4] = 5000
}






// Set the appropriate screen resolution in Original Mode when entering Data Select
// or recolor and use new text in Redesigned Mode
// Functions taken from menus\dataselect.lemon
//# address-hook(0x00c570) end(0x00c860)
function void DataSelectScreen()
{
	FadeOutScreenBlocking()

	if (original_mode)
		Renderer.setScreenSize(320, 224)

#if STANDALONE
	InitSaveSlots()
#endif

	DataSelect.setup()

	Menu.FadeInAfterInit()

	DataSelect.update()
}







// Disable Knuckles & Tails in the data select in Original Mode
// Function taken from menus\dataselect.lemon
//# address-hook(0x00d6d0) end(0x00d70a)
function void fn00d6d0_Orig()
{
	// Character selection
	u8 character = D0.u8
	if (u16[0xffffb04a + 0x30] == 0)
	{
		u8 maxCharacterSelection = 3

		if (control.pad1.pressed & CONTROL_UP)
		{
			character = (character < maxCharacterSelection) ? (character + 1) : CHARS_SONIC_AND_TAILS
			playSound(SFX_CLICK)
		}
		else if (control.pad1.pressed & CONTROL_DOWN)
		{
			character = (character > CHARS_SONIC_AND_TAILS) ? (character - 1) : maxCharacterSelection
			playSound(SFX_CLICK)
		}
	}
	D0 = character
}







// Use classic time bonuses for Original Mode and create a copy of the collected giant rings array for the on-screen counter.
// Function taken from maingame\hud\levelresults.lemon
//# address-hook(0x02dae6) end(0x02dbc8)
function void fn02dae6()
{
	giantRingsCollected.array = level.giantrings_clear	// When Act 2's totaling finishes, the usual array is set to 0 while the counter is still on screen

	playMusic(MUSIC_CTRL_FADEOUT)

	Kosinski.addToDMAQueue(0x0d6a62, 0xa400)
	if (global.zone_act != 0x1600 && global.act.apparent == 0)
	{
		// Any Act 1
		A1 = 0x0d6d84
		D0 = 0
	}
	else
	{
		// Any Act 2, incl. Lava Reef Boss Act
		A1 = 0x0d6e46
		D0 = 0xffffffff
	}

	u16[A0 + 0x2c] = D0.u16
	Kosinski.addToDMAQueue(A1, 0xad00)

	if (isMainCharacter(CHARACTER_SONIC))
	{
		// Sonic
		A1 = 0x15b95c
	}
	else if (isMainCharacter(CHARACTER_TAILS))
	{
		// Tails - or Miles
		A1 = (global.region_code & 0x80) ? 0x39ab6a : 0x39aa18
	}
	else
	{
		// Knuckles
		A1 = 0x0d67f0
	}
	D2.u16 = (u16[A0 + 0x2c] != 0) ? 0xb400 : 0xaf00
	Kosinski.addToDMAQueue(A1, D2.u16)

	hud.dirty.timer = 0
	u32 seconds = timer.seconds + u32(timer.minutes) * 60
	if (seconds == 599)
	{
		// Special time bonus for 9:59
		results.time_bonus = 10000
	}
	else
	{
		// Time bonus		  Original	   S3AIR
		//  - 0:00 .. 0:59	-> 50.000	-> 50.000
		//  - 1:00 .. 1:29	-> 10.000	-> 10.000
		//  - 1:30 .. 1:59	->  5.000	-> 10.000
		//  - 2:00 .. 2:29	->  4.000	->  5.000
		//  - 2:30 .. 2:59	->  3.000	->  5.000
		//  - 3:00 .. 3:29	->  1.000	->  3.000
		//  - 3:30 .. 3:59	->    100	->  3.000
		//  - 4:00 .. 4:59	->    100	->  2.000
		//  - 5:00 .. 5:59	->    100	->  1.000
		//  - 6:00 .. 6:59	->    100	->    500
		//  - 7:00 .. 9:58	->    100	->      0
		if (!original_mode)
		{
			if (seconds < 60)
				results.time_bonus = 5000
			else if (seconds < 120)
				results.time_bonus = 1000
			else if (seconds < 180)
				results.time_bonus = 500
			else if (seconds < 240)
				results.time_bonus = 300
			else if (seconds < 300)
				results.time_bonus = 200
			else if (seconds < 360)
				results.time_bonus = 100
			else if (seconds < 420)
				results.time_bonus = 50
			else
				results.time_bonus = 0
		}
		else
		{
			u16 offset = min(seconds / 30, 7)
			results.time_bonus = u16[0x02deaa + offset * 2]
		}
	}

	results.ring_bonus = u32(ring_counter) * 10
	results.total_bonus = 0
	objA0.countdown_value = 360
	u16[A0 + 0x30] = 12
	objA0.base_state += 2
}









// Creates triggers for alternate start locations.
// A check for HCZ is added.
//# address-hook(0x085e3a) end(0x085e50)
function void TriggerNextZone()
{
#if STANDALONE
	Standalone.onLevelFinished()
	D0.u16 = (unlock_act) ? 0x0200 : Game.onTriggerNextZone(D0.u16)	// stay with MGZ zone/act ID when moving between unlockable acts

	// Decide on the next zone's start location -- either the default or an alternative one
	//  - 0 is the default
	//  - 1 is Sonic's and Tails' path
	//  - 2 is Knuckles's path
	level.start_location = 0
	if (D0.u16 == 0x0100 && !original_mode)
	{
		// AIZ -> HCZ
		level.start_location = (camera.position.x.u16 < 0x4580) ? 2 : 1
	}
	else if (D0.u16 == 0x0200 && !original_mode)
	{
		// HCZ -> MGZ
		level.start_location = (camera.position.x.u16 > 0x4500) ? 2 : 1
	}
	else if (D0.u16 == 0x0300 && !original_mode)
	{
		// MGZ -> CNZ
		level.start_location = (camera.position.y.u16 < 0x0600) ? 2 : 1
	}
	else if (D0.u16 == 0x0500 && !original_mode)
	{
		// CNZ -> ICZ
		level.start_location = (camera.position.y.u16 > 0x0300) ? 2 : 1
	}
	else if (D0.u16 == 0x0700 && !original_mode)
	{
		// LBZ -> MHZ
		level.start_location = (level.vertical_wrap == 0x0668) ? 1 : 2		// level.vertical_wrap = 0x0668 in Sonic/Tails boss area
	}
	else if (D0.u16 == 0x1601 && !original_mode)
	{
		if (global.zone_act == 0x0901)	// actual LRZ2, not the boss act
		{
			// LRZ -> HPZ specifically for Knuckles' exit
			level.start_location = (camera.position.y.u16 < 0x0120) ? 3 : 2
		}
		else	// LRZ2 boss act
			level.start_location = 1
	}

	if (Game.getSetting(SETTING_MAINTAIN_SHIELDS) && !original_mode)
	{
		global.shields_backup_1 = u8[0xffffb02b] & 0x71
	}
#endif

	// Trigger the fade out and loading of next zone
	global.zone_act = D0.u16
	global.zone_act.apparent = D0.u16
	level.restart = 1
	checkpoint.number = 0
	global.stage_type = 0

#if STANDALONE
	Standalone.onLevelStart()
#endif
}








constant array<u16> UnlockAct_StartPositionsSonicTails =
{
	0x0060, 0x0294,		// EHZ
	0x0060, 0x01ec		// CPZ
}
constant array<u16> UnlockAct_StartPositionsKnuckles =
{
	0x0060, 0x0534,		// EHZ
	0x0060, 0x01ec		// CPZ
}



// Start location checks
// Force Knuckles to use Tails' start in ICZ1,
// move AIZ1 Knux intro, and adjust CNZ1 starts.
//# address-hook(0x01be46) end(0x01bfae)
function void SetupCharacterAtStartPosition()
{
	if (original_mode && global.zone_act == 0x0300 && checkpoint.number == 0)		// Don't use CNZ's rearranged intros in Original Mode
	{
		base.SetupCharacterAtStartPosition()
		if isMainCharacter(CHARACTER_KNUCKLES)	// base S3&K start Knuckles too low for the original ROM Hack, so adjust here.
		{
			D0 = 0x09ac
			u16[0xffffb014] = D0.u16
			D0.s16 = clamp(D0.s16 - 96, 0, s16(move_area.bottom.current))
			camera.position.y.u16 = D0.u16
			u16[0xffffee64] = D0.u16
		}
		return
	}

	if (checkpoint.number != 0)
	{
		SetupCharacterAtLastCheckpoint()
		D1.u16 = u16[0xffffb010]
		D0.u16 = u16[0xffffb014]
	}
	else
	{
		A1 = isMainCharacter(CHARACTER_KNUCKLES) ? 0x1e3cd8 : 0x1e3c18
		if (global.zone_act == 0x0700 || global.zone_act.apparent == 0x0001)
		{
			if (level.start_location == 2)
				A1 = 0x1e3cd8
			else if (level.start_location == 1)
				A1 = 0x1e3c18
		}
		A1 += global.zone * 8 + global.act * 4
		D1 = u16[A1]
		D0 = u16[A1+2]
		if (global.zone_act == 0x0300)		// hardcode CNZ1 start locations so Original Mode can access the ROM hack locations
		{
			D1 = isMainCharacter(CHARACTER_KNUCKLES) ? 0x0020 : 0x0010
			D0 = isMainCharacter(CHARACTER_KNUCKLES) ? 0x0920 : 0x06ac
		}
		if (unlock_act)
		{
			D1 = UnlockAct_StartPositionsSonicTails[(unlock_act - 1) * 2]
			D0 = UnlockAct_StartPositionsSonicTails[(unlock_act - 1) * 2 + 1]
			if (isMainCharacter(CHARACTER_KNUCKLES) && eggrobos_knuckles)	// in Sonic 2 acts, the Eggrobos flag instead sets harder Knuckles paths
			{
				D1 = UnlockAct_StartPositionsKnuckles[(unlock_act - 1) * 2]
				D0 = UnlockAct_StartPositionsKnuckles[(unlock_act - 1) * 2 + 1]
			}
		}
		u16[0xffffb010] = D1.u16
		u16[0xffffb014] = D0.u16

		if (unlock_act)
		{
			layout.part = 0		// if we needed to look up start positions, then we are starting an act fresh
			SetupCharacterAtStartPosition.unlockAct()
		}

		else if (global.zone_act == 0x0000)
		{
			if (isSonicIntro())
			{
				D1.u16 = 0
				D0.u16 = 0x420
				u16[0xffffb010] = 0x0040
				u16[0xffffb014] = 0x0420
				move_area.left = 0
				u16[0xffffee0c] = 0
				u16[0xffffee1c] = 0
			}
		#if STANDALONE
			// else if (isMainCharacter(CHARACTER_KNUCKLES) || (global.characters == CHARS_TAILS_ALONE && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02)))
			else if (isMainCharacter(CHARACTER_KNUCKLES) && (Game.getSetting(SETTING_AIZ_INTRO_KNUCKLES) != 0) && !original_mode) // && !time_attack
			{ //  altered else if check to remove check for location of Knux intro and to look for Chaos the Imposter mod on Chaos or Knux path
				// First set the desired camera position, then character position gets calculated after the if-else-blocks
				//  -> Camera positions here should be the same as in "fn0634ca"
		//		if (Game.getSetting(SETTING_LEVELLAYOUTS) == 2)	// AIR layouts set
		//		{
					u16[0xffffb010] = 0x03b0	// usually 0x1830
					u16[0xffffb014] = 0x0219	// usually 0x0119
					D1.u16 = 0x02e8	// usually 0x1768
					D0.u16 = 0x0190 // usually 0x0090	// New lines to prepare the camera for the new layout section.
					move_area.left = 0x0200	// new line added for Chaos mod.
					move_area.bottom.current = D0.u16
					move_area.bottom.target = D0.u16
					if (global.characters == CHARS_TAILS_ALONE && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02))	// Chaos the Imposter checks
					{
						checkpoint.number = 1
						checkpoint.x = 0x03b0	// usually 0x1830
						checkpoint.y = 0x0219	// usually 0x0119
					}
		//		}
		//		else	// S3 or S3&K layouts set
		//		{
		//			D1.u16 = 0x1390
		//			D0.u16 = 0x0380
		//		}
				D1.u16 += getScreenWidth() / 2
				D0.u16 += 96
			}
		#endif
		}

		else if (global.zone_act == 0x0001)
		{
			if (original_mode && camera.position.y.u16 < 0x0400)	// upper AIZ2 start in Original Mode
			{
				// Move back just a bit to line up with the original ROM hack
				u16[0xffffb010] -= 0xb8
				u16[0xffffb05a] -= 0xb8
				camera.position.x.u16 -= 0xb8
				u16[0xffffee0c] -= 0xb8
				u16[0xffffee1c] -= 0xb8
				D1.u16 = u16[0xffffb010]
				D0.u16 = u16[0xffffb014]
			}
		}

		else if (global.zone_act == 0x0100)
		{
			if (level.start_location == 1 && isMainCharacter(CHARACTER_KNUCKLES))
			{
				// Use Sonic's start 0x0980 to the right
				u16[0xffffb010] += 0x0980
				u16[0xffffb05a] += 0x0980
				camera.position.x.u16 += 0x0980
				u16[0xffffee0c] += 0x0980
				u16[0xffffee1c] += 0x0980
				D1.u16 = u16[0xffffb010]
				D0.u16 = u16[0xffffb014]
			}
			else if (level.start_location == 2 && !isMainCharacter(CHARACTER_KNUCKLES))
			{
				// Use Knuckles' start 0x0980 to the left
				u16[0xffffb010] -= 0x0980
				u16[0xffffb05a] -= 0x0980
				camera.position.x.u16 -= 0x0980
				u16[0xffffee0c] -= 0x0980
				u16[0xffffee1c] -= 0x0980
				D1.u16 = u16[0xffffb010]
				D0.u16 = u16[0xffffb014]
			}
		}

		else if (global.zone_act == 0x0200)
		{
			if (isMainCharacter(CHARACTER_KNUCKLES))
			{
				if (level.start_location == 1)
				{
					u16[0xffffb010] -= 0x47
					u16[0xffffb014] += 0x06fc
					if (u32[A2] != 0)
					{
						u16[0xffffb05a] -= 0x47
						u16[0xffffb05e] += 0x06fc
					}
					D1.u16 = u16[0xffffb010]
					D0.u16 = u16[0xffffb014]
				}
			}
			else if (level.start_location == 2)
			{
				u16[0xffffb010] += 0x47
				u16[0xffffb014] -= 0x06fc
				if (u32[A2] != 0)
				{
					u16[0xffffb05a] += 0x47
					u16[0xffffb05e] -= 0x06fc
				}
				D1.u16 = u16[0xffffb010]
				D0.u16 = u16[0xffffb014]
			}
		}


		else if (global.zone_act == 0x0300)
		{
			if (isMainCharacter(CHARACTER_KNUCKLES))
			{
			#if STANDALONE
				if (level.start_location == 0)
				{
					level.start_location = 1
				}
			#endif
			}
			else if (level.start_location == 0)	// not Knuckles in this check
			{
			#if STANDALONE
				{
					level.start_location = 2
				}
			#endif
			}
			if (level.start_location == 1)
			{
					u16[0xffffb010] = 0x0018
					u16[0xffffb014] = 0x0900
					D1.u16 = 0x0018
					D0.u16 = 0x0900
			}
			else
			{
					if (isMainCharacter(CHARACTER_KNUCKLES)) // Knux's start if coming from
					{										 // MGZ2's not-flying boss
						D0.u16 = 0x06ac						 // needs a correction
						u16[0xffffb014] = 0x6ac
					}
					D1.u16 += 0xb0
			}
		}
		else if (global.zone_act == 0x0500)
		{
			if (isMainCharacter(CHARACTER_TAILS) || (isMainCharacter(CHARACTER_SONIC) && time_attack))	// last check originally (time_attack == 1 || time_attack == 2)
			{
				u16[0xffffb010] = 0x3780
				u16[0xffffb014] = 0x01e0
				camera.position.x.u16 = 0x36f0
				camera.position.y.u16 = 0x0200
				move_area.left  = 0x35a0
				u16[0xffffee0c] = 0x35a0
				u16[0xffffee1c] = 0x35a0
				level.vertical_wrap = 0x0200
				u16[0xffffee10] = 0x0200
				u16[0xffffee20] = 0x0200
				u16[0xffffee60] = 0x36f0
				u16[0xffffee64] = 0x0200
				return
			}
		#if STANDALONE
			else if (isMainCharacter(CHARACTER_KNUCKLES))
			{
				if (!original_mode)		// (level.start_location == 1)
				{
					// Use Tails' start
					level.start_location = 1
					u16[0xffffb010] = 0x3780
					u16[0xffffb014] = 0x01e0
					camera.position.x.u16 = 0x36f0
					camera.position.y.u16 = 0x0200
					move_area.left  = 0x35a0
					u16[0xffffee0c] = 0x35a0
					u16[0xffffee1c] = 0x35a0
					level.vertical_wrap = 0x0200
					u16[0xffffee10] = 0x0200
					u16[0xffffee20] = 0x0200
					u16[0xffffee60] = 0x36f0
					u16[0xffffee64] = 0x0200
					return
				}
			}
		#endif
		}
//	#if STANDALONE
//		else if (global.zone_act == 0x0601)
//		{
//			if (isMainCharacter(CHARACTER_KNUCKLES) && getNumPlayers() == 2)
//			{
//				// Move Knuckles a bit to the right in LBZ 2 to make space for Tails
//				u16[0xffffb010] += 0x10
//				D1.u16 += 0x10
//			}
//		}
//	#endif
		else if (global.zone_act == 0x0700)
		{
			if ((level.start_location == 1 || (!isMainCharacter(CHARACTER_KNUCKLES) && original_mode)) && global.lock_on_state == 0 || (level.start_location == 0 && !isMainCharacter(CHARACTER_KNUCKLES)))	// !isMainCharacter(CHARACTER_KNUCKLES) instead of level.start_location in base game
			{
				move_area.left  = 0x00c0
				u16[0xffffee0c] = 0x00c0
				u16[0xffffee1c] = 0x00c0
				D1.u16 = 0x0160
			}
		}
		else if (global.zone_act == 0x0900)
		{
			if (isMainCharacter(CHARACTER_KNUCKLES))
			{
				D1.u16 += 0xb0
			}
		}
		else if (global.zone_act == 0x0b00 || global.zone_act == 0x1601)
		{
			D1.u16 += 0xb0 + getScreenExtend()
			if (global.zone_act == 0x1601 && level.start_location == 3)
			{
				u16 startPositionYShift = isMainCharacter(CHARACTER_KNUCKLES) ? 0x0180 : 0x0980
				D0.u16 -= startPositionYShift
				u16[0xffffb014] -= startPositionYShift
				if (u32[A2] != 0)
				{
					u16[0xffffb05e] -= startPositionYShift
				}
			}
			else if (global.zone_act == 0x1601 && level.start_location == 2 && !isMainCharacter(CHARACTER_KNUCKLES))
			{
				D0.u16 -= 0x0800
				u16[0xffffb014] -= 0x0800
				if (u32[A2] != 0)
				{
					u16[0xffffb05e] -= 0x0800
				}
			}
			else if (global.zone_act == 0x1601 && level.start_location == 1 && isMainCharacter(CHARACTER_KNUCKLES))
			{
				D0.u16 += 0x0800
				u16[0xffffb014] += 0x0800
				if (u32[A2] != 0)
				{
					u16[0xffffb05e] += 0x0800
				}
			}
		}
	#if STANDALONE
		else if (global.zone == 0x13)
		{
			// Gumball Machine:
			// Do not allow for jumping in first frame
			u8[0xffffb000 + 0x20] = char.state.STANDING
			u8[0xffffb000 + 0x2a] |= char.flag.IN_AIR
			u8[0xffffb04a + 0x20] = char.state.STANDING
			u8[0xffffb04a + 0x2a] |= char.flag.IN_AIR
		}
		else if (global.zone == 0x15)
		{
			// Slot Machine
			D1.u16 -= getScreenExtend()
		}
	#endif
	}

	D1.s16 = max(D1.s16 - getScreenWidth() / 2, 0)
	if (competition_mode.active == 0)
	{
	#if STANDALONE
		// Avoid exact tile edges
		//  -> This was particularly added in to avoid glitches in first pixel row after exiting first Giant Ring in AIZ 2
		//     (There's probably a better solution, that generally solves this type of glitches when going left in AIZ 2)
		if ((D1.u16 & 0x0f) == 0 && !original_mode)
			++D1.u16
	#endif
		D1.u16 = min(D1.u16, move_area.right)
	}

	camera.position.x.u16 = D1.u16
	u16[0xffffee60] = D1.u16

	D0.s16 = clamp(D0.s16 - 96, 0, s16(move_area.bottom.current))
	camera.position.y.u16 = D0.u16
	u16[0xffffee64] = D0.u16
}


function void SetupCharacterAtStartPosition.unlockAct()
{
	// This function does return to the last five lines of the prior function.
	// For now, it is a completely empty function to prevent any special level starts.
}



// Alter Tails AI for the CNZ entrance if a run-in entrance should be used.
//# address-hook(0x013a10) end(0x013b24)
function void Character.TailsAI.Init()
{
	if (original_mode)
	{
		base.Character.TailsAI.Init()
		return
	}

	if (u8[0xfffff746] == 0)	// This is some checkpoint number backup for Tails
	{
		if (global.zone_act == 0x0100 || global.zone_act == 0x0200 || global.zone_act == 0x0600 || global.zone_act == 0x0900 || global.zone_act == 0x1600)
		{
			tails.respawn_counter = 0
			tails.ai_routine = 0x06
			char.control_flags = 0
			return
		}
		else if (global.zone_act == 0x0800 || global.zone == 0x17)
		{
			tails.respawn_counter = 0
			tails.ai_routine = 0x06
			return
		}
		else if (global.zone_act == 0x0000)		// AIZ 1
		{
		#if STANDALONE
			// We want Tails to appear right from the start in Knuckles & Tails mode, unless using Knuckles intro
			if (!time_attack && (isMainCharacter(CHARACTER_SONIC) || Game.getSetting(SETTING_AIZ_INTRO_KNUCKLES) && !original_mode))
		#endif
			{
				Character.CheckDiedStateEnd()
				tails.ai_routine = 0x0a
				char.control_flags = 0x83
				return
			}
		}
		else if (global.zone_act == 0x0300)		// CNZ 1
		{
		#if STANDALONE
			if (level.start_location == 1)
		#endif
			{
				char.position.x.u16 = 0x18
				char.position.y.u16 = 0x900
				char.flags = char.flag.IN_AIR
				tails.control_counter = 0
				tails.respawn_counter = 0
				tails.ai_routine = 0x0c
				return
			}
			
		}
		else if (global.zone_act == 0x0500 || global.zone_act == 0x0a00)	// ICZ 1 or SSZ (S/T)
		{
		#if STANDALONE
			if (isMainCharacter(CHARACTER_KNUCKLES) && global.zone_act == 0x0500)
			{
				// For Knuckles & Tails in ICZ 1, make Tails fly in after a short time
				tails.respawn_counter = 0
				tails.ai_routine = 0x02
				char.control_flags = 0x81
				char.flags = char.flag.IN_AIR
				char.position.x.u16 = 0
				char.position.y.u16 = 0
				tails.flight_countdown = 0xf0
				return
			}
		#endif

			// Disable Tails
			RespawnTails()
			tails.ai_routine = 0x0a
			char.control_flags = 0x83
			return
		}
		else if (global.zone_act == 0x0700 && global.lock_on_state == 0)
		{
			// MHZ 1
			char.flags = char.flag.IN_AIR
			tails.control_counter = 0
			tails.respawn_counter = 0
			tails.ai_routine = 0x0c

		#if STANDALONE
			if (level.start_location == 2 || (isMainCharacter(CHARACTER_KNUCKLES) && (original_mode || level.start_location == 0)))	// isMainCharacter(CHARACTER_KNUCKLES) instead of level.start_location in base game
			{
				char.position.x.u16 += 0x10
				char.position.y.u16 -= 0x10
				char.render_flags &= ~render_flag.FLIP_X
				char.state = char.state.FALLING_PANIC
				char.velocity.x = 0
				char.velocity.y = 0
				char.groundspeed = 0
				char.control_flags = 0
				tails.ai_routine = 0x06
				return
			}
		#endif

			char.position.x.u16 = 0xd8
			char.position.y.u16 = 0x500
			return
		}
	}

	char.state = char.state.RUNNING
	char.velocity.x = 0
	char.velocity.y = 0
	char.groundspeed = 0
	char.flags = 0
	char.control_flags = 0
	tails.respawn_counter = 0
	tails.ai_routine = 0x06
}







// Yet more start location settings: this function actually enacts those starts
// and has been edited for CNZ1 starts
//# address-hook(0x0067ee) end(0x0069b6)
function void fn0067ee()
{
	if (original_mode && global.zone_act == 0x0300)		// Don't use CNZ's rearranged intros in Original Mode
	{
		base.fn0067ee()
		return
	}
	
	u32[0xffffb094] = 0x006c2c
	InitializeGameCharacters()
	RestoreShield()
	if (checkpoint.number != 0 || global.stage_type != 0)
		return

	A1 = 0xffffb000
	A2 = 0xffffb04a

	if (unlock_act)
		fn0067ee.unlockAct()

	else if (global.zone_act == 0x0000)
	{
		// Angel Island Zone
		if (isSonicIntro())
		{
			// Trigger intro
			u32[0xffffb172] = 0x067472
			global.level_started = 0
		}
	#if STANDALONE
		// else if (isMainCharacter(CHARACTER_KNUCKLES) || (global.characters == CHARS_TAILS_ALONE && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02)))
		else if (isMainCharacter(CHARACTER_KNUCKLES) && Game.getSetting(SETTING_AIZ_INTRO_KNUCKLES) != 0 && !time_attack && !original_mode)
		{
			u32[0xffffb172] = 0x063446
		}
	#endif
	}
	else if (global.zone_act == 0x0100)
	{
		// Hydrocity Zone
		objA1.state = char.state.FALLING_PANIC
		if (global.characters == CHARS_KNUCKLES_ALONE)
		{
			u16[A1 + 0x20] = 0x2121
			u8[A1 + 0x23] = 1
			objA1.animation.timer = 0	// This is A0 instead of A1 in original, thanks to Clownacy (https://forums.sonicretro.org/index.php?showtopic=30778&view=findpost&p=893997)
		}
		objA1.flags2a |= char.flag.IN_AIR
		if (global.characters == CHARS_TAILS_ALONE)
		{
			u8[A1 + 0x40] = 0x01
		}
		if (u32[A2] != 0)
		{
			u8[A2 + 0x20] = char.state.FALLING_PANIC
			u8[A2 + 0x2a] |= char.flag.IN_AIR
			u8[A2 + 0x40] = 0x01
		}
	}
	else if (global.zone_act == 0x0200)
	{
		// Marble Garden Zone
		objA1.state = char.state.FALLING_PANIC
		objA1.flags2a |= char.flag.IN_AIR
		if (u32[A2] != 0)
		{
			u8[A2 + 0x20] = char.state.FALLING_PANIC
			u8[A2 + 0x2a] |= char.flag.IN_AIR
		}

//		if (isMainCharacter(CHARACTER_KNUCKLES))
//		{
			if (level.start_location == 2 || (isMainCharacter(CHARACTER_KNUCKLES) && level.start_location == 0) && !original_mode)
			{
				objA1.velocity.y = -0x1000
				if (u32[A2] != 0)
				{
					u16[A2 + 0x1a] = -0x1000
				}
			}		
//		}
	}
	else if (global.zone_act == 0x0300)
	{
		// Carnival Night Zone
		// bool spawnAITails = (global.characters == CHARS_SONIC_ALONE)	// Excluding Sonic & Tails
	// #if STANDALONE
		// if (level.start_location == 1 && isMainCharacter(CHARACTER_KNUCKLES)) // 
		// {
		//	spawnAITails = true
		// }
	// #endif

		if (level.start_location == 1 && !isMainCharacter(CHARACTER_TAILS))
		{
			u32[0xffffb04a] = 0x01365c		// load Tails into the player 2 position of the object status table
			u16[0xffffb05a] = u16[0xffffb010]		// copy x position
			u16[0xffffb05e] = u16[0xffffb014]		// copy y position
			tails.ai_routine = 0x00	// originally 0
		}
		else if (level.start_location == 1 && isMainCharacter(CHARACTER_TAILS))
		{
			tails.ai_routine = 0x20
		}
		else // if (isMainCharacter(CHARACTER_KNUCKLES))
		{
			u32[0xffffb172] = 0x044a0c // load Obj_LevelIntro_PlayerRun
		}
	}
	else if (global.zone_act == 0x0500)
	{
		// IceCap Zone
		if (isMainCharacter(CHARACTER_SONIC) && !time_attack)	// time attack check originally time_attack != 1 && time_attack != 2
		{
			u32[0xffffb172] = 0x0396e4
		}
		else if (isMainCharacter(CHARACTER_TAILS) || (isMainCharacter(CHARACTER_SONIC)))		// && time_attack used to be in Sonic check, but it shouldn't be necessary now
		{
			u32[0xffffb172] = 0x039b66
		}
	#if STANDALONE
		else if (isMainCharacter(CHARACTER_KNUCKLES))
		{
			if (level.start_location == 1)
			{
				// Use Tails' start
				u32[0xffffb172] = 0x039b66
			}
		}
	#endif
	}
	else if (global.zone_act == 0x0600)
	{
		// Launch Base Zone
		u32[0xffffb172] = 0x039a40
	}
	else if (global.zone_act == 0x0700)
	{
		// Mushroom Hill Zone
		if (level.start_location == 2 || (isMainCharacter(CHARACTER_KNUCKLES) && (original_mode || level.start_location == 0)))
		{
			objA1.state = char.state.FALLING_PANIC
			objA1.flags2a |= char.flag.IN_AIR
		}
		else if (global.lock_on_state == 0)
		{
			// Add Tails
			if ((level.start_location == 1 && !isMainCharacter(CHARACTER_TAILS)) || (global.characters == CHARS_SONIC_ALONE && original_mode) || (level.start_location == 0 && isMainCharacter(CHARACTER_SONIC)))
			{
				u32[0xffffb04a] = 0x01365c
				u16[0xffffb05a] = u16[0xffffb010]
				u16[0xffffb05e] = u16[0xffffb014]
				tails.ai_routine = 0
			}
			else if (isMainCharacter(CHARACTER_TAILS))
			{
				tails.ai_routine = 0x20
			}
		}
	}
	else if (global.zone_act == 0x0800)
	{
		// Sandopolis Zone
		u32[0xffffb172] = 0x041fee
		objA1.state = char.state.ROLLING
		objA1.flags2a |= char.flag.IN_AIR
		if (u32[A2] != 0)
		{
			u8[A2 + 0x20] = char.state.ROLLING
			u8[A2 + 0x2a] |= char.flag.IN_AIR
		}
	}
	else if (global.zone_act == 0x0900)
	{
		// Lava Reef Zone
		if (global.characters != CHARS_KNUCKLES_ALONE)
		{
			objA1.state = char.state.FALLING_PANIC
			objA1.flags2a |= char.flag.IN_AIR
			if (u32[A2] != 0)
			{
				u8[A2 + 0x20] = char.state.FALLING_PANIC
				u8[A2 + 0x2a] |= char.flag.IN_AIR
			}
		}
		else
		{
			u32[0xffffb172] = 0x044a0c
		}
	}
	else if (global.zone_act == 0x0b00)
	{
		// Death Egg Zone
		u32[0xffffb172] = 0x044a0c
	}
	else if (global.zone_act == 0x1600)
	{
		// Lava Reef boss act
		objA1.state = char.state.FALLING_PANIC
		objA1.flags2a |= char.flag.IN_AIR
		if (u32[A2] != 0)
		{
			u8[A2 + 0x20] = char.state.FALLING_PANIC
			u8[A2 + 0x2a] |= char.flag.IN_AIR
		}
	}
	else if (global.zone_act == 0x1601)
	{
		// Hidden Palace Zone
		u32[0xffffb172] = 0x044a0c
	}
}


function void fn0067ee.unlockAct()
{
	// This function does return to the last five lines of the prior function.
	// For now, it is a completely empty function to prevent any special level starts.
}




// Do not draw a ghost image for an offscreen, player-controlled sidekick Tails in Original Mode
// Function taken from standalone\enginecallbacks.lemon
//# post-update-hook
function void PostFrameUpdate()
{
	if (Game.getSetting(SETTING_PLAYER2_OFFSCREEN) && global.game_mode == 0x0c && !competition_mode.active && !original_mode)
	{
		// Draw off-screen Tails (only when controlled by a player)
		A0 = 0xffffb04a
		if (objA0.update_address != 0 && tails.control_counter > 0)
		{
			s32 halfx = getScreenWidth() / 2
			s32 halfy = getScreenHeight() / 2
			s32 px = s32(char.position.x.u16) - camera.foreground.x.u16 - halfx
			s32 py = s32(char.position.y.u16) - camera.foreground.y.u16 - halfy

			if (level.vertical_wrap == 0xff00)
			{
				// Consider vertical level wrap
				py &= level.height.bitmask
				if (py > level.height.bitmask / 2)
					py -= (level.height.bitmask + 1)
			}

			if (abs(px) >= halfx || abs(py) >= halfy)
			{
				s32 maxX = halfx * 19/20
				s32 maxY = halfy * 19/20
				if (abs(px) > maxX)
				{
					py = py * maxX / abs(px)
					px = (px > 0 ? maxX : -maxX)
				}
				if (abs(py) > maxY)
				{
					px = px * maxY / abs(py)
					py = (py > 0 ? maxY : -maxY)
				}

				px += halfx
				py += halfy
				Standalone.drawCharacterSprite(char.character, 1, px, py, true)

				// Tails' tails
				if (u16[0xffffcc0a + 0x30] != 0)
				{
					A0 = 0xffffcc0a
					Standalone.drawCharacterSprite(CHARACTER_TAILS, 2, px, py, true)
				}
			}
		}
	}

	// Time Attack update
	Standalone.checkTimeAttackFinish()

	// Debug output
	Debugging.debugDraw()
	setWorldSpaceOffset(s32(s16(camera.position.x.u16)), s32(s16(camera.position.y.u16)))

	showDebugText()
	endOfFrame()
}





// Revert AIR's Tails AI behavior changes in Original mode
// Functions comes from maingame\character\tails_ai.lemon
//# address-hook(0x013b26) end(0x013bf6)
function void fn013b26()
{
#if STANDALONE
	// Wait for an additional delay (used in AIZ intro)
	if (tails.respawn_counter > 0 && !original_mode)
	{
		--tails.respawn_counter
		return
	}
#endif

	if ((control.tails.state & (CONTROL_START | CONTROL_ABC)) == 0)	// Check buttons, but not D-pad
	{
		// Check only every 64 frames
		if ((level.framecounter & 0x3f) != 0)
			return
		if (u8[A1 + 0x2e] & 0x80)	// control_flags
			return
		if (u8[A1 + 0x2a] & 0x80)	// flags
			return
	}

	tails.ai_routine = 0x04

	// Spawn above player 1
	u16 px = objA1.position.x.u16
	u16 py = objA1.position.y.u16
	char.position.x.u16 = px
	char.position.y.u16 = py + (global.inv_gravity ? 0xc0 : -0xc0)
	tails.flight_target.x = px
	tails.flight_target.y = py

	char.sprite_attributes |= sprite_attribute.PRIORITY
	char.sprite_priority = 0x100
	char.velocity.x = 0
	char.velocity.y = 0
	char.groundspeed = 0
	u8[A0 + 0x2d] = 0
	char.double_jump_state = 0
	char.flags = char.flag.IN_AIR
	char.drown_countdown = 30
	char.control_flags = 0x81
	u8[A0 + 0x30] = 0
	u8[A0 + 0x31] = 0
	char.hlock_countdown = 0
	char.invuln.countdown = 0
	char.invinc.countdown = 0
	char.speedup.countdown = 0
	char.protection_flag = 0
	char.look_up_down_timer = 0
	char.angle_sensor_1 = 0
	char.angle_sensor_2 = 0
	u8[A0 + 0x3c] = 0
	char.spindash = 0
	char.spindash_charge = 0
	char.jumping = 0

#if STANDALONE
	// Fix for Tails' speed caps not corrected when he despawned underwater
	if (!original_mode)
		setSpeedCapProperties(A4, false)
#endif

	u8[A0 + 0x41] = 0
	tails.flight_countdown = 0xf0
	UpdateTailsFlight_innerB()
}

//# address-hook(0x013bf8) end(0x013d48)
function void fn013bf8()
{
	// Tails AI flying in after respawn
	if (objA0.render_flags & render_flag.VISIBLE)
	{
		tails.flight_countdown = 0xf0
		char.flags |= char.flag.IN_AIR
		UpdateTailsFlight_innerB()
		tails.respawn_counter = 0
	}
	else
	{
		++tails.respawn_counter
		bool respawnCondition = (tails.respawn_counter >= 300)
		if (!original_mode)
			respawnCondition = (tails.respawn_counter >= 300 || (Input.buttonPressed(BUTTON_Y | BUTTON_PAD2) && tails.ai_routine == 0x06))
		if (respawnCondition)
		{
			tails.respawn_counter = 0
			tails.ai_routine = 0x02
			char.control_flags = 0x81
			char.flags = char.flag.IN_AIR
			char.position.x.u16 = 0
			char.position.y.u16 = 0
			tails.flight_countdown = 0xf0
			UpdateTailsFlight_innerB()
			return
		}
	}

	D3.u8 = posbackup.offset.player1 - 0x44
	tails.flight_target.x = u16[0xffffe500 + D3.u8]
	tails.flight_target.y = u16[0xffffe500 + D3.u8 + 2]

	s16 dx = char.position.x.u16 - tails.flight_target.x
	if (dx != 0)
	{
		s16 moveX = min(abs(dx) >> 4, 12)
		moveX += abs(objA1.velocity.x) + 1
		if (dx >= 0)
		{
			char.flags |= char.flag.FACING_LEFT
			if (moveX >= dx)
			{
				moveX = dx
				dx = 0
			}
			char.position.x.u16 -= moveX
		}
		else
		{
			char.flags &= ~char.flag.FACING_LEFT
			dx = -dx
			if (moveX >= dx)
			{
				moveX = dx
				dx = 0
			}
			char.position.x.u16 += moveX
		}
	}

	s16 dy = char.position.y.u16 - tails.flight_target.y
	if (dy != 0)
	{
	#if STANDALONE
		// Consider vertical level wrap
		if (level.vertical_wrap == 0xff00 && !original_mode)
		{
			dy &= level.height.bitmask
			if (dy > level.height.bitmask / 2)
				dy -= (level.height.bitmask + 1)
		}
	#endif
		char.position.y.u16 += (dy > 0) ? -1 : 1
	}

	D2.u8 = u8[0xffffe400 + D3.u8 + 2] & 0x80
	if (D2.u8 == 0 && u8[0xffffb000 + 0x05] < 0x06)
	{
		bool gainControlNow = (dx == 0 && dy == 0)
		if (!original_mode)
		{
			gainControlNow = (abs(dx) <= 4 && abs(dy) <= 4)
			gainControlNow = gainControlNow || (abs(objA1.position.x.u16 - char.position.x.u16) <= 4 && abs(objA1.position.y.u16 - char.position.y.u16) <= 4)

			// Allow for pressing a jump button to gain control over Tails at once
			gainControlNow = gainControlNow || (control.tails.pressed & CONTROL_ABC)
		}
		if (gainControlNow)
		{
			tails.ai_routine = 0x06
			char.control_flags = 0
			char.state = char.state.RUNNING
			char.velocity.x = 0
			char.velocity.y = 0
			char.groundspeed = 0
			char.flags &= char.flag.UNDERWATER
			char.flags |= char.flag.IN_AIR
			char.hlock_countdown = 0
			char.sprite_attributes = (char.sprite_attributes & ~sprite_attribute.PRIORITY) | (objA1.sprite_attributes & sprite_attribute.PRIORITY)
			char.layer_flags1 = u8[A1 + 0x46]
			char.layer_flags2 = u8[A1 + 0x47]

			if (gainControlNow)
			{
				// Roll instead
				char.state = char.state.ROLLING
			}
			return
		}
	}
	char.control_flags = 0x81
}

//# address-hook(0x013d4a) end(0x013ec8)
function void fn013d4a()
{
	if (u8[0xffffb000 + 0x05] >= 0x06)
	{
		tails.ai_routine = 0x04
		char.spindash = 0
		char.spindash_charge = 0
		char.control_flags = 0x81
		char.flags = char.flag.IN_AIR
		char.state = char.state.TAILS_FLYDOWN
		return
	}

	fn013efc()

	if (tails.control_counter == 0 && (u8[A0 + 0x2e] & 0x80) == 0 && (u8[A1 + 0x37] & 0x80) == 0)
	{
		if (char.hlock_countdown != 0 && char.groundspeed == 0)
		{
			tails.ai_routine = 0x08
		}

		D0.u8 = posbackup.offset.player1 - 0x44
		u16 targetPosX = u16[0xffffe500 + D0.u8]
		u16 targetPosY = u16[0xffffe500 + D0.u8 + 2]
		u16 controlBackup = u16[0xffffe400 + D0.u8]
		u8 flagsBackup = u8[0xffffe400 + D0.u8 + 2]
		if (!original_mode)
		{
			// Make Tails account for Sonic's speed just enough he won't fall behind in AIZ 2 bombing section
			targetPosX += (objA1.velocity.x >> 7)
		}

		if ((objA1.flags2a & char.flag.ON_OBJECT) == 0 && objA1.groundspeed < 0x400)
		{
			// Prefer to stand left, not directly behind main character
			targetPosX -= 0x20
		}
		s16 relativeTargetPosX = targetPosX - char.position.x.u16

		control.tails = controlBackup
		if ((char.flags & char.flag.PUSHING) && ((flagsBackup & char.flag.PUSHING) == 0))
		{
			// Jump over obstacle
		#if STANDALONE
			// Do not jump if target position is close anyways
			if (abs(relativeTargetPosX) >= 0x30 || original_mode)
		#endif
			if ((level.framecounter.low & 0x3f) == 0 && char.state != char.state.COWERING)
			{
				control.tails |= 0x7070		// CONTROL_ABC, CONTROL_ABC
				tails.ai_jumping = 1
			}
		}
		else
		{
			if (relativeTargetPosX == 0)
			{
				char.flags = (char.flags & ~char.flag.FACING_LEFT) | (flagsBackup & char.flag.FACING_LEFT)
			}
			else
			{
				if (relativeTargetPosX < 0)
				{
					if (relativeTargetPosX <= -0x30)
					{
						control.tails = (control.tails & ~0x0c0c) | 0x0404		// Move left
					}

					if (char.groundspeed != 0 && (char.flags & char.flag.FACING_LEFT) != 0 && (char.control_flags & 0x01) == 0)
					{
						--char.position.x.u16
					}
				}
				else
				{
					if (relativeTargetPosX >= 0x30)
					{
						control.tails = (control.tails & ~0x0c0c) | 0x0808		// Move right
					}

					if (char.groundspeed != 0 && (char.flags & char.flag.FACING_LEFT) == 0 && (char.control_flags & 0x01) == 0)
					{
						++char.position.x.u16
					}
				}
			}

			if (tails.ai_jumping != 0)
			{
				control.tails |= 0x7000		// CONTROL_ABC, 0
				if (char.flags & char.flag.IN_AIR)
					return

				tails.ai_jumping = 0
			}

			if ((level.framecounter & 0xff) == 0 || abs(relativeTargetPosX) < 0x40)
			{
				s16 relativeTargetPosY = targetPosY - char.position.y.u16
				if (relativeTargetPosY <= -0x20)
				{
					if (((level.framecounter.low & 0x3f) == 0) && (char.state != char.state.COWERING))
					{
						control.tails |= 0x7070		// CONTROL_ABC, CONTROL_ABC
						tails.ai_jumping = 1
					}
				}
			}

			if (!original_mode)
			{
				// If both are standing still horizontally... (which includes spindash charging)
				if (char.velocity.x == 0 && objA1.velocity.x == 0)
				{
					// Make sure Tails looks into the same direction as the main player
					if ((objA0.flags2a & char.flag.FACING_LEFT) != (objA1.flags2a & char.flag.FACING_LEFT))
					{
						objA0.flags2a = (objA0.flags2a & ~char.flag.FACING_LEFT) | (objA1.flags2a & char.flag.FACING_LEFT)
					}

					// Start charging a spindash if the main player does so as well
					if (char.spindash == 0 && u8[A1 + 0x3d] != 0 && char.state == char.state.COWERING)
					{
						control.tails |= 0x0020		// 0, CONTROL_C
					}
				}
			}
		}
	}
	else if (tails.control_counter != 0)
	{
		--tails.control_counter
	}
}

//# address-hook(0x013efc) end(0x013f3e)
function void fn013efc()
{
	if (objA0.render_flags & render_flag.VISIBLE)
	{
		tails.respawn_counter = 0
	}
	else
	{
		if (char.flags & char.flag.ON_OBJECT)
		{
			A3 = 0xffff0000 + u16[A0 + 0x42]
			D0 = u16[0xfffff700]
			if (D0.u16 != u16[A3])
			{
				RespawnTails()
				return
			}
		}

		++tails.respawn_counter
		bool respawnCondition = (tails.respawn_counter >= 300)
		if (!original_mode)
			respawnCondition = (tails.respawn_counter >= 300 || (Input.buttonPressed(BUTTON_Y | BUTTON_PAD2) && tails.ai_routine == 0x06))
		if (respawnCondition)
		{
			RespawnTails()
			return
		}
	}

	if (char.flags & char.flag.ON_OBJECT)
	{
		A3 = 0xffff0000 + u16[A0 + 0x42]
		u16[0xfffff700] = u16[A3]
	}
}



// Control what to do after an unlockable act finishes its level results tally.
// Empty function taken from standalone\gamecallbacks.lemon
function void Standalone.onLevelFinished()
{
	if (!unlock_act)
	{
		base.Standalone.onLevelFinished()
		return
	}

	if (unlock_act == 1 && total_stars >= unlock.level.cpz)		// in EHZ with enough stars to play CPZ
	{
		++unlock_act
		// Trigger the fade out and loading of next zone
		global.zone_act = 0x0200			// Don't change from the MGZ IDs. Actually set it, as other functions may try to change it.
		global.zone_act.apparent = 0x0200	// Don't change from the MGZ IDs. Actually set it, as other functions may try to change it.
		if (Game.getSetting(SETTING_MAINTAIN_SHIELDS) && !original_mode)
		{
			global.shields_backup_1 = u8[0xffffb02b] & 0x71
		}
		level.restart = 1
		checkpoint.number = 0
		global.stage_type = 0
		return
	}

	// Truncated copy of code used for moving from DAGE pause menu to DAGE main menu
	restart_timer = 0
	exit_timer = 0
	checkpoint.number = 0
	checkpoint.time = 0
	global.zone_act = global.zone_act.apparent	// this prevents the endings of AIZ1 and ICZ1 from exhibiting undesirable behavior
	global.stage_type = 0
	global.in_extra_stage = 0

	camera.background.x = 0		// From function void restartLevel(), which Euka uses as the
	camera.background.y = 0		// fix for the AIZ1 background issue.
	u8[0x818080] = 0			// Clear the flag for the extended vertical scroll buffer.
	zeroMemory(0xfffff100, 0x500)	// Clear out data used when loading level patterns, else the main game may try to access special stage data or vice versa.
	global.game_mode = 0x54
}

// Function taken from maingame\hud\levelresults.lemon
//# address-hook(0x02dcca)
function void LevelResults.AdvanceToNextAct()
{
	if (!unlock_act)
	{
		base.LevelResults.AdvanceToNextAct()
		// Special handling for AIZ, when Knuckles uses Sonic's path
		if (global.zone == 0x00 && (isMainCharacter(CHARACTER_KNUCKLES) ||(Mods.isModActive("Chaos The Impostor") && global.characters == 2))  && camera.position.y.u16 < 0x400)
		{
			checkpoint.number = 4		// Used in AIZ1, but should not interfere with Act 2
			level.start_location = 1	// Mark Sonic's path start for level restarts
			checkpoint.x = 0x1240
			checkpoint.y = 0x0358
			Checkpoint.SaveCurrentState()
			checkpoint.move_area.bottom = 0x0590	// Overwrite move_area.bottom.* backup accordingly
		}
		return
	}

#if STANDALONE
	if (level.restart)
	{
		// Fix "frame-perfect reset" bug, but only for highest level of glitch fix setting
		if (Game.getSetting(SETTING_FIX_GLITCHES) >= 2)
		{
			UnloadObject()
			return
		}
	}
#endif

	if (objA0.countdown_value != 0)
	{
		--objA0.countdown_value
		return
	}

	if (u16[A0 + 0x30] != 0)
	{
		++objA0.value32
		return
	}

	level.wait_for_results = 0

#if STANDALONE
	Standalone.onLevelFinished()
#endif
/*
	// Sky Sanctuary, Lava Reef Boss, Hidden Palace, or any Act 2?
	if (global.zone == 0x0a || global.zone == 0x16 || global.act.apparent != 0)
	{
		level.results_done = 0xff
		UnloadObject()
		return
	}

	global.act.apparent = 1
*/
	checkpoint.number = 0
	global.stage_type = 0

/*
	// Sandopolis, Death Egg use a small cutscene before showing the title card
	if (global.zone == 0x08 || global.zone == 0x0b)
	{
		UnloadObject()
		return
	}
	// Show title card for Act 2
	objA0.update_address = addressof(TitleCard.Update)
	objA0.base_state = 0
	u8[A0 + 0x3e] = 0xff
*/

#if STANDALONE
	Standalone.onLevelStart()

/*
	// Special handling for AIZ, when Knuckles uses Sonic's path
	if (global.zone == 0x00 && isMainCharacter(CHARACTER_KNUCKLES) && camera.position.y.u16 < 0x400)
	{
		checkpoint.number = 4		// That number seems to be unused otherwise in whole AIZ
		checkpoint.x = 0x1240
		checkpoint.y = 0x0358
		Checkpoint.SaveCurrentState()
		checkpoint.move_area.bottom = 0x0590	// Overwrite move_area.bottom.* backup accordingly
	}
*/
#endif
}


// Add ROM manipulations to support correct AIZ1 Knuckles intro animals
// These will be provided in future AIR versions but are needed for compatibility with older versions
// Functions taken from standalone\rom_manipulations.lemon
function void ApplyROMManipulations()
{
	if (original_mode)
	{
		ApplyROMManipulations_Original()
		return
	}
	
	ROMManipulation.RepairSpriteMappings()
	#if GAMEAPP <= 0x22091000
	// Fix checkpoint stars loading incorrect tiles. Covered in ROMManipulation.RepairSpriteMappings() in later A.I.R. builds.
	u16[0x187b8a] = 0xc0
	u16[0x187bec] = 0xc0
	u16[0x187c4e] = 0xc0
	#endif

	#if GAMEAPP <= 0x24020200
	// Fix for offset in Sonic's first ending pose sprite (after credits roll), #contributed by mrgrassman14. Covered in ROMManipulation.RepairSpriteMappings() in later A.I.R. builds.
	u16[0x0607f2] = 0xdc0f
	u16[0x0607f6] = 0xfff0
	u16[0x0607f8] = 0xe401
	u16[0x0607fc] = 0x0010
	u16[0x0607fe] = 0xe402
	u16[0x060802] = 0xffe8
	u16[0x060804] = 0xfc0e
	u16[0x060808] = 0xffe8
	u16[0x06080a] = 0xfc01
	u16[0x06080e] = 0x0008
	u16[0x060810] = 0x1405
	u16[0x060814] = 0xfff0

	// Apply changes to Super Sonic's idle and balancing animations to make the hair flow as it did in Sonic 2, #contributed by Veenee (idle animation) and mrgrassman14 (balancing animation).
	// Covered in ROMManipulation.RepairAnimations() in later A.I.R. builds.
//	u8[0x012c45] = 0x5a			// Shift the idle animation pointer back a bit to an otherwise empty area
//	u8[0x012c47] = 0x60			// Shift the balance animation pointer back to our newly created space
//	u32[0x012c94] = 0x07babbbc	// Add additional frames (idle speed + first three idle frames)
//	u32[0x012c98] = 0xbbff07a1  // Add additional frames (4th idle frame + balance speed + first balance frame)
//	u32[0x012c9c] = 0xa2a3a2ff  // Add additional frames (last 3 balance frames)
	#endif

	ROMManipulation.RepairAnimations()
	ROMManipulation.CutsceneKnucklesPalette()	// Euka claims this is no longer needed in AIR, but its changes would still alter Classic Mode
	ROMManipulation.AIZ1.KnucklesIntroCritters()
	ROMManipulation.AIZ2.StartPosition()
	ROMManipulation.AIZ2.BlimpSequenceBombs()
	ROMManipulation.BonusSM.Probabilities()
	ROMManipulation.ALZ.MusicFix()
	ROMManipulation.DPZ.LoopBugFix()
	ROMManipulation.RollingDemoFix()
}

function void ROMManipulation.AIZ1.KnucklesIntroCritters()
{
	// Use AIZ critters and not the MHZ critters in Knuckles' intro, #contributed by iCloudius
	//  -> Also requires some additional initialization code, search for the comment above to find that one
	s16[0x06370f] = 0x5000
	s16[0x063713] = -0x45fb
}







// Move Knuckles' intro and set Sonic 2 title card variables
// Functions come from level\07_mhz\intro_knuckles.lemon
//# address-hook(0x0634ca) end(0x063524)
function void fn0634ca()
{
	// New lines to prepare the camera for the new layout section.
	move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
	move_area.bottom.target = 0x0190
	move_area.bottom.current = move_area.bottom.target

	A1 = 0x0663de
	if (fn084fa4())
		return

	objA0.countdown_value = 0xef
	u8[0xffffb02e] = 0x83

#if STANDALONE
	Game.startSkippableCutscene()

	if (global.zone_act == 0x0000)
	{
//		if (Game.getSetting(SETTING_LEVELLAYOUTS) == 2)
		if (!original_mode)
		{
			objA0.position.x.u16 = 0x0361	// normally 0x17e1
			objA0.position.y.u16 = 0x0225	// normally 0x0125

			camera.position.x.u16 = 0x02e8	// normally 0x1768
			camera.position.y.u16 = 0x0190	// normally 0x0290
		}
		else
		{
			objA0.position.x.u16 = 0x13f0
			objA0.position.y.u16 = 0x0425

			camera.position.x.u16 = 0x1390
			camera.position.y.u16 = 0x0380
		}
	}
	else
#endif
	{
		camera.position.x.u16 = max(0x0540, 0x0560 - getScreenExtend())
		camera.position.y.u16 = 0x0948
	}
	player1.camera_lock = 0xff
	global.random.seed = global.framecounter
	global.level_started = 0

	if (allocDynamicObjectStd())
	{
		u32[A1] = 0x063682
	}

	// Spawn the 8 critters (with update routine 0x063694)
	spawnSimpleChildObjects(0x066656)

	copyMemory(0xfffffca0, 0x066a32, 0x20)
}

//# address-hook(0x06364e) end(0x06367c)
function void fn06364e()
{
	checkpoint.number = 1
	checkpoint.x = 0x06f4
	checkpoint.y = 0x09ec
#if STANDALONE
	if (global.zone_act == 0x0000)
	{
//		if (Game.getSetting(SETTING_LEVELLAYOUTS) == 2)
		if (!original_mode)
		{
			checkpoint.x = 0x03b0	// usually 0x1830
			checkpoint.y = 0x0219	// usually 0x0119
		}
		else
		{
			checkpoint.x = 0x1460
			checkpoint.y = 0x041a
		}
	}
#endif
	Checkpoint.SaveCurrentState()
	checkpoint.time = 0

#if !STANDALONE
	// This should already have been set to exactly this value...
	D0.u16 = 0x0700
	global.zone_act = D0.u16
	global.zone_act.apparent = D0.u16
#endif

#if STANDALONE
	Game.endSkippableCutscene()

	// Use this code for a direct start without fade to black (along with the "pointToReach" change above)
	bool manualCutsceneSkip = ((control.pad1.pressed & CONTROL_START) || (control.player2.pressed & CONTROL_START))
	if (global.zone_act == 0x0000 && !manualCutsceneSkip)
	{
		// Three new lines to prepare the camera for the new layout section.
		move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
		move_area.bottom.target = 0x0190
		move_area.bottom.current = move_area.bottom.target

		u32 backupA0 = A0

		u16[0xffffb010] = objA0.position.x.u16
		u16[0xffffb014] = objA0.position.y.u16
		s16[0xffffb018] = objA0.velocity.x
		s16[0xffffb01c] = objA0.velocity.x
		u8[0xffffb02e] = 0

		// Give Knuckles another update, to make sure he's rendered this frame at all
		A0 = 0xffffb000
		call objA0.update_address
		A0 = backupA0

		// Remove the critters, and the object that listens to CONTROL_START
		for (u32 address = 0xffffb128; address < 0xffffcfcb; address += 0x4a)
		{
			A1 = address
			if (objA1.update_address == 0x063682) // originally includes "objA1.update_address == 0x063720 || objA1.update_address == 0x063750 ||" to remove animals
			{
				unloadObjectAt(A1)
			}
		}

		// Load palette line 1 for enemies
		copyMemory(0xfffffc20, 0x0a8b7c, 0x20)

		player1.control_override = 0
		player1.camera_lock = 0
		fn0851e4()

		if (allocDynamicObjectStd())
		{
			// Show title card
			S2TitleCard.disappear = false
			S2TitleCard.loaded = false
			S2TitleCard.full = false
			objA1.update_address = 0x02d690
		}

		global.level_started = -0x6f	// Let HUD fly in
		hud.dirty.timer = 0x80
		timer.alldata = 0
		hud.dirty.lives = 0x01

		UnloadObject()

		// Spawn Tails
		if (getNumPlayers() > 1)
		{
			tails.respawn_counter = 60
			tails.ai_routine = 0x02
		}
	}
	else
#endif
	{
		S2TitleCard.disappear = false
		S2TitleCard.loaded = false
		S2TitleCard.full = true
		level.restart = 1
		Object.TriggerUnloading()
	}
}



// Adjust Sonic 2 title card variables in the AIZ intros
// Function taken from level\01_aiz\intro_sonic.lemon
//# address-hook(0x061f10) end(0x061f5a)
function void fn061f10()
{
	if (objA0.render_flags & render_flag.VISIBLE)
	{
		Object.AnimationProgressByLocalA1()
		UpdateMovementStraightSimple()
		return
	}

	u8[0xfffff650] = 0
	player1.control_override = 0
	fn083c06()
	fn0851e4()

	if (allocDynamicObjectStd())
	{
		// Show title card
		S2TitleCard.disappear = false
		S2TitleCard.loaded = false
		S2TitleCard.full = false
		objA1.update_address = 0x02d690
	}

	global.level_started = -0x6f	// Let HUD fly in
	hud.dirty.timer = 0x80
	timer.alldata = 0
	hud.dirty.lives = 0x01
	Object.TriggerUnloading()

#if STANDALONE
	Game.endSkippableCutscene()
#endif
}







// Select which color is rendered on the palm tree's background at the miniboss cutscene
// and set the camera boundaries to accommodate Knuckles' new path.
//# address-hook(0x01c550) end(0x01c5c4)
function void fn01c550()
{
	if (original_mode)
	{
		fn01c550_Orig()
		return
	}

	A1 = 0x01c60a
	fn01caae()

	level.vertical_wrap = 0
	u16[0xfffffcde] = (palette_set >= 2 && !original_mode) ? 0x42c : 0x020e
	if ((global.game_mode & 0x80) == 0 && global.fade_timer == 0)
	{
		u16[0xfffffc5e] = (palette_set >= 2  && !original_mode) ? 0x42c : 0x020e	// this sets the red color used on some types of flowers
	}														 	// once the level fade-in is over (originally 0x020e)
	if (camera.position.x.u16 >= 0x2b00)
	{
		u16[0xfffffc5e] = 0x0004 // this changes the color again in the area of the hollow tree
	}
	if (camera.position.x.u16 >= 0x2c00)
	{
		level.vertical_wrap = 0x2e0
	}
	if (camera.position.x.u16 >= 0x2d80)
	{
		u16[0xfffffc5e] = u16[0xfffffc76] // u16[0xfffffc5e] = (isMainCharacter(CHARACTER_KNUCKLES)) ? u16[0x04faea] : u16[0xfffffc76]	// second result was originally simply 0x0c02
													// this sets the color to use alongside the palm tree's leaves
		move_area.left = 0x2d80
		requestLoadingPatterns(0x5a)
		camera.update_routine += 2
	}

#if STANDALONE
	// Handling for Knuckles' new path
	if (objA0.position.x.u16 < 0x1880)
	{
//		if (isMainCharacter(CHARACTER_KNUCKLES))
//		{
			move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
			move_area.bottom.target = (objA0.position.x.u16 < 0x04e0) ? 0x0190 : 0x02a0
			if (camera.position.x.u16 >= 0x1080)
				move_area.bottom.target = 0x01a0
			level.vertical_wrap = 0x0000 // this is essentially move_area.top; Euka named it for 0xff00 allowing vertical wrapping
			if (camera.position.x.u16 >= 0x12e0 && camera.position.y.u16 >= 0x0280)
			{
				move_area.left = 0x12e0
				level.vertical_wrap = 0x0280 // this is essentially move_area.top; Euka named it for 0xff00 allowing vertical wrapping
				move_area.bottom.target = (camera.position.x.u16 < 0x1620) ? 0x0390 : 0x03b0
			}
		//	move_area.bottom.current = move_area.bottom.target
//		}
//		else
//		{
//			move_area.left = 0x12e0
//			level.vertical_wrap = 0x0280 // this is essentially move_area.top; Euka named it for 0xff00 allowing vertical wrapping
//		}
	}
#endif
}

function void fn01c550_Orig()
{
	A1 = 0x01c60a
	fn01caae()

	level.vertical_wrap = 0
	u16[0xfffffcde] = 0x20e
	if ((global.game_mode & 0x80) == 0 && global.fade_timer == 0)
	{
		u16[0xfffffc5e] = 0x020e
	}

	if (camera.position.x.u16 >= 0x2b00)
	{
		u16[0xfffffc5e] = 0x0004
	}
	if (camera.position.x.u16 >= 0x2c00)
	{
		level.vertical_wrap = 0x2e0
	}
	if (camera.position.x.u16 >= 0x2d80)
	{
		u16[0xfffffc5e] = isMainCharacter(CHARACTER_KNUCKLES) ? u16[0x04faea] : 0x0c02
		move_area.left = 0x2d80
		requestLoadingPatterns(0x5a)
		camera.update_routine += 2
	}

// #if STANDALONE
//	// Handling for Knuckles' new path
//	if (objA0.position.x.u16 < 0x1a00)
//	{
//		if (objA0.position.y.u16 < 0x0180)
//		{
//			move_area.left = 0x1680
//			move_area.bottom.target = (objA0.position.x.u16 < 0x1960) ? 0x0090 : 0x0390
//			move_area.bottom.current = move_area.bottom.target
//		}
//		else
//		{
//			move_area.left = 0x13a8
//		}
//	}
// #endif
}



// Smooth out a rough camera transition at the start of AIZ1.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01caae) end(0x01caca)
function void fn01caae()
{
	D0.u16 = camera.position.x.u16 + getScreenExtend()
	while (true)
	{
		D1 = u32[(A1+=4)-4]
		if (D0.u16 <= D1.u16)
		{
		#if STANDALONE
			// Additional check for the area at the first Giant Ring
			//  -> Required for extended camera
			if (A1 == 0x01c612 && u16[0xffffb000 + 0x10] >= 0x1b80)
				continue
		#endif
			break
		}
	}
	D1 = (D1 << 16) + (D1 >> 16)
	if (D1.s16 < 0)
	{
		D1.u16 &= 0x7fff
		if (original_mode)
			move_area.bottom.current = D1.u16
	}
	move_area.bottom.target = D1.u16
}




// Remove AIR's behavior that adjusts chunks near the AIZ1 start.
//# address-hook(0x04f906) end(0x04f90e)
function void InitLevelTiles.AIZ1()
{
	AIZ1.ChangeBackgroundForKnuckles()
	
	// new if statement alters the camera settings for Knuckles' layout
	if (!original_mode && (isMainCharacter(CHARACTER_KNUCKLES)  || (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02))) && checkpoint.number == 0)
	{
		move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
		move_area.bottom.target = (objA0.position.x.u16 < 0x04e0) ? 0x0190 : 0x02a0
		move_area.bottom.current = move_area.bottom.target
	}

	Level.GetCameraPosition()
	Level.InitialTilesFill()

// #if STANDALONE
	// Update some chunks on the left of the start area that look broken
	// due with the border being a bit further left in S3AIR (see "fn01c4d0()")
//	for (u32 i = 0; i < 7; ++i)
//		u16[0xffff80ac + i * 0x61] = 0x64
// #endif
}





// Force tile loading for AIZ1 for Knuckles to ignore intro code.
//# address-hook(0x04faec) end(0x04fb42)
function void InitLevelScrolling.AIZ1()
{
	if (camera.position.x.u16 < 0x1300 - getScreenExtend() && camera.position.y.u16 > 0x0350 && checkpoint.number == 0 )
	{
		zeroMemory(0xffffa800, 40)

		fn23afd2()
		fn04f2f6()
		Level.InitialTilesFill()

		A4 = 0x23b20a
		A5 = 0xffffa828
		fn04f0ce()
	}
	else
	{
		level.scrolling_routine = 8
		UpdateBackgroundScrolling.AIZ1()
		fn04f2f6()

		u32[0xffffa800] = 0
		u16[0xffffa806] = D2.u16
		A4 = 0x23b254
		A5 = 0xffffa800
		fn04ecec()

		UpdateForegroundScrolling.AIZ1()
	}
}









function void AIZ1.ChangeBackgroundForKnuckles()
{
	// This function changes the AIZ1 background so no horizon is visible when playing as Knuckles
	if (isMainCharacter(CHARACTER_KNUCKLES) || (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02)))
	{
		fn04fa4c()
	}
}







// Adjust the AIZ1 camera boundaries for Knuckles.
// The AIZ1 Knux palette patch and the level palette for Sonic as his intro ends are also loaded here.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01c46e) end(0x01c4ce)
function void fn01c46e()
{
	if (original_mode)
	{
		base.fn01c46e()
		return
	}

	// new if statement for Knuckles
	if (isMainCharacter(CHARACTER_KNUCKLES) || (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02)))
	{
		move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
		move_area.bottom.target = (objA0.position.x.u16 < 0x04e0) ? 0x0190 : 0x02a0
		if (camera.position.x.u16 >= 0x1080)
			move_area.bottom.target = 0x01a0
		move_area.bottom.current = move_area.bottom.target
		// Change how palettes are loaded for Knuckles based on player palette choice
		if (palette_set < 2 || original_mode)
			Level.loadPaletteData(0x2a)
		else
			System.loadExternalRawData("Palette0000", 0xfffffca0)
	
		// Here is where the palette is patched for Knuckles.
		// A1 = 0xfffffc70
		// A2 = 0x04fae4	// load the palette patch
		// u32[(A1+=4)-4] = u32[(A2+=4)-4]
		// u32[A1] = u32[A2]
		
		#if STANDALONE
			// This serves as a small delay before Tails actually spawns
			tails.respawn_counter = 60
		#endif
		tails.ai_routine = 0x02

		camera.update_routine += 2
		return
	}
	
	u8[0xfffff72e] = 1
	if (camera.position.x.u16 >= 0x1000)
	{
		u8[0xfffff72e] = 0
		move_area.left = camera.position.x.u16
		if (u16[0xffffb010] == 0x13a0)	// AIZ1 start position for Sonic and Tails
			move_area.left = max(camera.position.x.u16, 0x12e0)		// max function and set value added to prevent ultrawide resolutions from showing garbage graphics to left.
		if (camera.position.x.u16 >= 0x1308 - getScreenExtend())	// Not exact, but works for 416px
		{
			if (checkpoint.number == 0 && isMainCharacter(CHARACTER_SONIC))
			{
				requestLoadingPatterns(0x0b)
			}
			
			Level.loadPaletteData(0x2a)

			// Make Tails fly in
			{
			#if STANDALONE
				// This serves as a small delay before Tails actually spawns
				tails.respawn_counter = 60
			#endif
				tails.ai_routine = 0x02
			}

			camera.update_routine += 2
		}
	}
}

//# address-hook(0x01c4d0) end(0x01c54e)
function void fn01c4d0()
{
	if (original_mode)
	{
		base.fn01c4d0()
		return
	}

//	move_area.left = 0x1308
//#if STANDALONE
	// Show a bit more to the left, that looks better in widescreen
	move_area.left = max(0x12e0, move_area.left - getScreenExtend())

	// new if statement for Knuckles
	if (isMainCharacter(CHARACTER_KNUCKLES))	// || (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02))
	{
		move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
		move_area.bottom.target = (objA0.position.x.u16 < 0x04e0) ? 0x0190 : 0x02a0
		if (camera.position.x.u16 >= 0x1080)
			move_area.bottom.target = 0x01a0
		move_area.bottom.current = move_area.bottom.target

//		if (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02))
//		{
//			checkpoint.number = 1
//			checkpoint.x = 0x03b0	// usually 0x1830
//			checkpoint.y = 0x0219	// usually 0x0119
//		}
	}

// #endif

	if (camera.position.x.u16 >= 0x12e0)	// usually 0x1400
	{
	#if STANDALONE
		// This additional check here is just one of many changes to make the Sonic intro being skipped correctly in Time Attack
		if (!time_attack)
	#endif
		if (checkpoint.number == 0 && isMainCharacter(CHARACTER_SONIC))
		{
			Kosinski.addToDecompressionQueue(0x3a458a, 0xffff9268)
			Kosinski.addToDMAQueue(0x3a944e, 0x17c0)

			u8[0xffffeec6] = 0xff
			u16[0xfffff7f0] = 0x500
			u16[0xfffff7f2] = 0x500
			u16[0xfffff7f4] = 0x500
		}

		// Switch to new checkpoint -- mainly for Sonic, so his intro gets skipped after death
		if (!isMainCharacter(CHARACTER_KNUCKLES)) // && !(isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] != 0xDA00 || u16[0xffffef7c] != 0xDA02))
		{
			checkpoint.number = 1
			checkpoint.x = 0x13a0
			checkpoint.y = 0x041a
			Checkpoint.SaveCurrentState()

		checkpoint.time = 0
		}
		requestLoadingPatterns(0x08)
		camera.update_routine += 2
	}
}







// From maingame\maingame.lemon, a function that corrects AIZ 1 needs to be altered for Knux's path.
// This function sets level sizes by calling a level size array at 0x01bcc6.
function void fn01bc60()
{
	Level.SetupLevelSize()
}

//# address-hook(0x01bc60) end(0x01bcc2)
//# alias(fn01bc60) deprecated
function void Level.SetupLevelSize()
{
	u8[0xffffee30] = 0
	u8[0xffffee08] = 0
	player1.camera_lock = 0
	player2.camera_lock = 0
	u8[0xffffee39] = 0
	camera.update_routine = 0
	outro.wait_time = 0
	u16[0xfffff662] = 0

	A0 = 0x01bcc6 + global.zone * 16 + global.act * 8
	u16 minX = u16[A0]
	u16 maxX = u16[A0+2]
	u16 minY = u16[A0+4]
	u16 maxY = u16[A0+6]
#if STANDALONE
	// Some corrections
	if (global.zone_act == 0x0000 && !unlock_act)	// AIZ 1
	{
		minX = 0x12e0
		if (u16[0xffffb010] < 0x1000 && !original_mode) //  || (isMainCharacter(CHARACTER_TAILS) && u8[0xffffef7c] == 0xDA && (u16[0xffffef7c] != 0xDA00 || u16[0xffffef7c] != 0xDA02))
		{
			minX = 0x0200
		}
	}
	else if (global.zone == 0x13)	// Gumball Machine bonus stage
	{
		minX -= getScreenExtend()
		maxX -= getScreenExtend()
	}
#endif

	if (unlock_act)
	{
		minX = UnlockAct.LevelSizes[(unlock_act) * 4 - 4]
		maxX = UnlockAct.LevelSizes[(unlock_act) * 4 - 3]
		minY = UnlockAct.LevelSizes[(unlock_act) * 4 - 2]
		maxY = UnlockAct.LevelSizes[(unlock_act) * 4 - 1]
	}

	move_area.left = minX
	move_area.right = maxX
	move_area.left.target = minX
	move_area.right.target = maxX
	move_area.left.player2 = minX
	move_area.right.player2 = maxX

	level.vertical_wrap = minY
	move_area.bottom.current = maxY
	move_area.top.target = minY
	move_area.bottom.target = maxY
	level.vertical_wrap.player2 = minY
	move_area.bottom.current.player2 = maxY

	camera.yoffset.player = 0x60
	camera.yoffset.tails = 0x60
	level.width.bitmask = 0xffff
	level.height.bitmask = 0xffff
	SetupCharacterAtStartPosition()
}

constant array<u16> UnlockAct.LevelSizes =
{
	0x0000, 0x7fff, 0x0000, 0x04c0,		// EHZ
	0x0000, 0x7fff, 0x0000, 0x0720		// CPZ
}




// Use original timing for AIZ1 Sonic intro in Original Mode.
// Functions taken from level\01_aiz\intro_sonic.lemon
//# address-hook(0x061e24) end(0x061e62)
function void fn061e24()
{
	Object.animationProgress(0x0666af)
	UpdateMovementSimple()
	if (D0.s32 >= 0)
	{
		CheckGroundCollision()
		if (D1.s16 < 0)
		{
			objA0.base_state = 0x06
			objA0.position.y.u16 += D1.u16
			objA0.animation.sprite = 0x16
			objA0.countdown_value = (original_mode) ? 127 : 63	// Don't wait that long, both Sonic and Knuckles just stands there doing nothing for quite some time...
			objA0.countdown_callback = 0x061e6a
		}
	}
}





// Do not apply an AIR palette fix to Monkey Dude's coconuts in Original Mode.
// Function taken from enemies\aiz_monkeydude.lemon
//# address-hook(0x08744c) end(0x08745e)
function void fn08744c()
{
	fn087518()

#if STANDALONE
	if (!original_mode)
	{
		// Fix for the coconut palette before it's thrown, #contributed by Legobouwer
		objA0.sprite_attributes = 0x0548
		if (objA0.animation.sprite != 6)
			objA0.sprite_attributes |= sprite_attribute.PALETTE.LINE1
	}
#endif

	// Targets:
	//  - 0x087468	-> objA0.base_state = 0x00
	//  - 0x087472	-> objA0.base_state = 0x02
	call tableLookupAddress(0x087462, objA0.base_state)

	fn084920()
}

//# address-hook(0x08756a) end(0x087590)
function void fn08756a()
{
	A1 = 0xffff0000 + u16[A0 + 0x46]
	if (u8[A1 + 0x38] & 0x02)
	{
		objA0.base_state = D1.u8
		objA0.flags38 |= 0x02
		if (!original_mode)
			objA0.value3a = objA0.value3a >> 1
		D0.u8 = objA0.value3a >> 1
		objA0.value3a = D0.u8
		objA0.value3b = 1
	}
}




// Correct an issue with A.I.R.'s widescreen settings for the AIZ1 hollow tree in Classic Mode / low
// screen widths in which going too fast would make the player crash into a wall and fall down.
// Also remove rolling flag in hollow tree to prevent running out of speed and falling down.
// Functions taken from objects\01_aiz\aiz_hollowtree.lemon
//# address-hook(0x01f752)
function void fn01f752()
{
	fn01f7b8()

	if ((objA0.flags2a & (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT)) == 0 && u16[A0 + 0x38] != 0)
	{
		--u16[A0 + 0x38]
		if (u16[A0 + 0x38] == 0)
		{
			move_area.left = 0x1300
			move_area.right = 0x4000
		}
		else
		{
			if (move_area.left != 0x1300)
			{
				if (u16[0xffffb000 + 0x10] >= 0x2d00)
				{
					move_area.left = 0x1300
				}
				else
				{
					move_area.left -= 4
				}
			}
			if (move_area.right != 0x4000)
			{
				if (u16[0xffffb000 + 0x10] < 0x2d00)
				{
					move_area.right = 0x4000
				}
				else
				{
					move_area.right += 4
				}
			}
		}
	}
	else if (!original_mode && getScreenWidth() > 320)
	{
		if (camera.position.x.u16 < 0x2c00 && camera.position.y.u16 >= 0x0360)
		{
			move_area.right = 0x2c54 + getScreenExtend()
		}
		else if (camera.position.y.u16 < 0x0320)
		{
			move_area.right = 0x4000
		}
	}

	// Dirty hack to refresh parts of the screen and avoid visual glitches
	if (!original_mode)
		fillPlaneA_Default(0x2d80, 0x02e0, 512, 512)

	CheckForUnloadObject()
}

function void fn01f7ce()
{
#if STANDALONE
	if (debug_mode.state)
		return
#endif

	u8 bit = (1 << D6.u8)

	if ((objA0.flags2a & bit) == 0)
	{
		if ((u8[A1 + 0x2a] & char.flag.IN_AIR) == 0)
		{
			s16 dx = objA1.position.x.u16 - objA0.position.x.u16 + 0x10
			s16 dy = objA1.position.y.u16 - objA0.position.y.u16
			if (dx >= 0 && dx < 0x40 && dy >= -0x5a && dy <= 0xa0)
			{
				if (objA1.velocity.x >= 0x600 && u8[A1 + 0x2e] == 0)
				{
					LetSonicClimbOnObject()

					u32[A2] = 0
					u8[A1 + 0x20] = char.state.RUNNING
					if (!original_mode)
						objA1.flags2a &= ~char.flag.ROLLING
					u8[A1 + 0x2e] |= 0x42
					if (A1 == 0xffffb000)
					{
						if (allocDynamicObjectAfterA0())
						{
							objA1.update_address = 0x04fa0c
						}

						move_area.left = 0x2c60 - getScreenExtend()
						move_area.right = 0x2c60 + getScreenExtend()
						u16[A0 + 0x38] = 0x3c
					}
				}
			}
		}
	}
	else
	{
		D0.u16 = abs(s16[A1 + 0x1c])
		if (D0.u16 >= 0x600)
		{
			if ((u8[A1 + 0x2a] & char.flag.IN_AIR) == 0)
			{
				D0.u16 = objA1.position.y.u16 - objA0.position.y.u16 + 0x90
				s16 minDiff = 12
				if (original_mode)
					minDiff = 0		// For a slightly faster exit at the top
				if (D0.s16 >= minDiff && D0.u16 <= 0x130)
				{
					fn01f914()
					return
				}
			}
			else
			{
				if (objA1.position.x.u16 < 0x2c99)
				{
					objA1.position.x.u16 = 0x2c99
					objA1.velocity.x = 0x400
				}
				if (objA1.position.x.u16 >= 0x2d66)
				{
					objA1.position.x.u16 = 0x2d66
					objA1.velocity.x = -0x400
				}
			}
		}
		else
		{
			if (u16[A2] < 0x400)
			{
				u32 backupA1 = A1
				u32 backupD6 = D6
				fn01f914()
				A1 = backupA1
				D6 = backupD6
			}
		}

		fn01f8b4()
	}
}

//# address-hook(0x01f8b4)
function void fn01f8b4()
{
	u8 bit = (1 << D6.u8)
	if (original_mode) // unlock horizontal speed in AIR / Revisited Mode, but not in Original Mode
		objA1.velocity.x >>= 1
	objA1.velocity.y >>= 1
	u8[A1 + 0x1e] = 19
	u8[A1 + 0x1f] = 9
	u16[A1 + 0x20] = 1
	objA1.flags2a |= char.flag.IN_AIR
	objA1.flags2a &= ~(char.flag.ROLLING | char.flag.ON_OBJECT)
	u8[A1 + 0x2e] &= ~0x42
	u8[A1 + 0x30] = 0
	u8[A1 + 0x31] = 4
	objA0.flags2a &= ~bit
}




// Add a call in AIZ1 to draw the sprite to cover up the tree trunk to the right of the miniboss cutscene
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x04f912) end(0x04fa0a)
function void UpdateLevelTiles.AIZ1()
{
	AIZ1_CustomSprites()
	base.UpdateLevelTiles.AIZ1()
}

function void AIZ1_CustomSprites()
{
	if (!original_mode && palette_set < 2)
		Renderer.drawCustomSprite("knuckles_intro_rocks_orig", 0x04d0 - camera.foreground.x.u16, 0x01f8 - camera.foreground.y.u16, 0, 0, 0x9dff)
	else if (!original_mode)
		Renderer.drawCustomSprite("knuckles_intro_rocks", 0x04d0 - camera.foreground.x.u16, 0x01f8 - camera.foreground.y.u16, 0, 0, 0x9dff)

	Renderer.drawCustomSprite("tree_base_cover", 0x30f0 - camera.foreground.x.u16, 0x0380 - camera.foreground.y.u16, 0, 0, 0x4001)
}




// Implement future A.I.R. fix to fix sprite culling on AIZ swinging vines.
// Function taken from objects\01_aiz\aiz_swingingvine.lemon
//# address-hook(0x02241a) end(0x022440)
function void fn02241a()
{
	objA1.render_flags = render_flag.WORLD
	objA1.box_size.y = 8
	if (!original_mode)
	{
		// Increase visual bounding box to avoid too early clipping
		objA1.box_size.x = 16
		objA1.box_size.y = 16
	}
	else
	{
		objA1.box_size.x = 8
		objA1.box_size.y = 8
	}
	objA1.sprite_priority = 0x0200
	objA1.sprite_attributes = 0x041b
	objA1.mapping_offset = 0x022b9e
}





// Load tiles, blocks, and chunks as the fire wall moves the character from AIZ1 to AIZ2
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x04fc46) end(0x04fd28)
function void fn04fc46()
{
	if (u16[0xffffeed4] == 0)
	{
		if (u8[0xffffb000 + 0x05] < 0x06)
		{
			D0 = s32((u32(level.display_routine) << 16) - camera.background.y) >> 5
			camera.background.y += D0
			if (D0 < 0x1400)
			{
				fn23b152()
			}
		}
	}
	else
	{
		fn23b152()
	}

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1.u16 = 0x1000
	D6 = 0x20
	LoadTileContentInDirY()

	if (camera.background.y.u16 >= 0x0190)
	{
		// Called as soon as transition fire wall effect completely covered the screen
		push(A3)
		push(A2)
		push(A0)
		push(D7)

	//	Kosinski.addToDecompressionQueue(0x3b51e8, 0xffff0000)	// Act 2 chunks
		System.loadExternalRawData(stringformat("aiz2_chunks_s", global.act + 1), KosinskiRawdataBuffer)		// copy Secondary chunks to shared memory
		Kosinski.addToDecompressionQueue(KosinskiRawdataBuffer, 0xffff0000)									// decompress them to their proper RAM (see above)

		Kosinski.addToDecompressionQueue(0x3b0052, 0xffff9000)
		Kosinski.addToDecompressionQueue(0x3b08f2, 0xffff9ab8)

		Kosinski.addToDMAQueue(0x3b15d2, 0x0000)
		Kosinski.addToDMAQueue(0x3b3784, 0x3f80)

		addPatternLoadingCue(0x08399a)

		D7 = pop()
		A0 = pop()
		A2 = pop()
		A3 = pop()

		if (allocDynamicObjectStd())
		{
			objA1.update_address = 0x04fe38
			objA1.position.x.u16 = 0x2fb0
			objA1.position.y.u16 = 0x03a0
		}
		u16[0xffffeec8] = 0xf0
		u16[0xffffeeca] = 0x0f
		level.scrolling_routine += 4
		fn04fd32()
	}
	else
	{
		fn23b17a()
		WriteScrollOffsets()
	}
}








// Correct the camera x minimum in AIZ2 on the Sonic path outside of Original Mode.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01c664) end(0x01c68e)
function void fn01c664()
{
	if (camera.position.x.u16 >= 0x02e0 - getScreenExtend())
	{
		move_area.bottom.current = 0x0590
		move_area.bottom.target = 0x0590
		camera.update_routine += 2

		if (global.zone_act.apparent == 1)
		{
			if (!original_mode)
				move_area.left = 0x1178
			else
				move_area.left = 0x0f50
			camera.update_routine += 2
		}
	}
}

// Correct the camera x minimum in AIZ2 on the Knuckles path outside of Original Mode.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01c78c) end(0x01c7b6)
function void fn01c78c()
{
	if (camera.position.x.u16 >= 0x02e0 - getScreenExtend())
	{
		move_area.bottom.current = 0x0590
		move_area.bottom.target = 0x0590
		camera.update_routine += 2

		if (global.zone_act.apparent == 1)
		{
			move_area.left = 0x10a8
			if (original_mode)
				move_area.left = 0x1040
			camera.update_routine += 2
		}
	}
}

// Correct the camera x minimum in AIZ2 on the Sonic path when playing as Knuckles outside of Original Mode.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01c64e) end(0x01c660)
function void fn01c64e()
{
	if (isMainCharacter(CHARACTER_KNUCKLES) && (original_mode || level.start_location != 1))
	{
		camera.update_routine = 0x12
		fn01c78c()
	}
	else
	{
		camera.update_routine = 0x02
		fn01c664()
	}
}



// Stops water from entering AIZ2 if Knux dies at the boss and restarts from a checkpoint.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x04ff0a) end(0x04ff12)
function void InitLevelTiles.AIZ2()
{
	AIZ2.LevelInitSpecialty()

	Level.GetCameraPosition()
	Level.InitialTilesFill()
	// new code
	if (move_area.bottom.current > 0x0630)	// if the camera maximum y position stretches down to Knuckles' path
	{
		level.water_present = 0				// then remove water from level
	}
}




// Change AIZ2's water to be path-dependent rather than character-dependent
// to better support future mods.
// Chaos the Imposter does not need this; it handles it on its own.
// Function taken from level\level_water.lemon
//# address-hook(0x006dde) end(0x006e6c)
function void UpdateWaterSurfaceLevel.AIZ2()
{
	if (camera.position.y.u16 < 0x0f80) // (isMainCharacter(CHARACTER_KNUCKLES))
	{
		if (move_area.bottom.target == 0x0820 || camera.position.x.u16 >= 0x3b60)
			return
	}

	// Somewhere in here:
	//  - Lower water level
	//  - Cause screen shake to start

	if (camera.position.x.u16 < 0x2440)
	{
		if (water.height.target == 0x0618)
		{
			water.height.target = 0x0528
			water.height.changerate = 2
		}
	}
	else
	{
		if (level.trigger00 == 0)
		{
			if (camera.position.x.u16 < 0x2850)
				return

			level.trigger00 = 1
		}

		if (water.height.target != 0x0618)
		{
			if (camera.position.x.u16 < 0x2900)
			{
				camera.screenshake.state = 0xffff
				if (allocDynamicObjectStd())
				{
					objA1.update_address = 0x006e6e
					u8[A1 + 0x24] = 0xb4
				}
			}

			A3 = 0xffff8024
			D1 = 4
			while (D1 > 0)
			{
				A1 = 0xffff0000 + u16[A3]
				u8[A1 + 0x4e] = 0
				A3 += 4
				--D1
			}
			water.height.target = 0x0618
			// Enforce a full screen refresh of plane A to get rid of wrong waterfall tiles possibly being shown
			fillPlaneA_Default(camera.position.x.u16, camera.position.y.u16, getScreenWidth(), getScreenHeight())
		}
	}
}




// In Original Mode, stop the AIZ background and plants from moving when the Act 1 boss starts
// to align with the original ROM hack and base S3&K.
// Function taken from level\level_animation.lemon
//# address-hook(0x02784a) end(0x02787e)
function void LevelTilesAnim.AIZ()
{
	if (level.boss_encounter && original_mode)
		return
	else
	{
		A3 = 0xfffff7f0
		if (camera.position.x.u16 >= 0x1c0)
		{
			fn0286e8()
		}
		else
		{
			D6 = 0
			A2 += 2
			fn0286ee()

			u32[A3] = 0
			updateSpritePattern(0x2a5880, 0x1940, 0x230)
		}
	}
}




// In Original Mode, use original ROM hack AIZ zipline behaviors.
// Slight exception: after inputting the level select code properly, head directly to the level select.
// There is only one vine in the Original Mode / ROM hack: AIZ 2 Knux's zipline, and it stops after 48 frames.
// Thus, entering this code is *incredibly* hard!
// Functions taken from objects\01_aiz\aiz_zipline.lemon
//# address-hook(0x02219e) end(0x0221e0)
function void fn02219e()
{
	if (A1 != 0xffffb000 || D0.u8 == 0)
		return

	D1 = u8[A0 + 0x25]
	if (D0.u8 == u8[0x0221e2 + D1.s16])
	{
		++u8[A0 + 0x25]
		D1.u8 = u8[0x0221e3 + D1.s16]
		if (D1.u8 != 0)
			return

		// Code successfuly input
		if (!original_mode)
			u8[0x02219e] = 0x14
		else
		{
			levelselect.unlocked = 1
			pausecheats.unlocked = 1
			global.active_saveslot = 0			// do not allow a save slot to be active
			global.game_mode = 0x28
		}

		D1.u16 = D0.u16
		playSound(SFX_RING)
		D0.u16 = D1.u16
	}
	u8[A0 + 0x25] = 0
}


//# address-hook(0x022258) end(0x0222d0)
function void fn022258()
{
	A3 = 0xffff0000 + u16[A0 + 0x3c]
	u8 angle = u8[A3 + 0x26]
	if (u8[A1 + 0x2a] & char.flag.FACING_LEFT)
		angle = -angle

	objA1.state = char.state.RUNNING
	A3 = 0xffff0000 + u16[A0 + 0x3c]

	u16 offset = (u8(angle + 0x10) >> 5) * 2
	u8[A1 + 0x22] = u8[0x0222d4 + offset]

	s16 dx
	s16 dy

	if (!original_mode)
	{
		// Using smooth rotation
		u8[A1 + 0x26] = u8[A3 + 0x26]	// Apply rotation for the character

		dx = lookupSin(angle) * 5/32
		dy = lookupCos(angle) * 5/32
		if (!(u8[A1 + 0x2a] & char.flag.FACING_LEFT))
			dx = -dx
	}
	else
	{
		dx = s8[0x0222e4 + offset]
		dy = s8[0x0222e5 + offset]
		if (u8[A1 + 0x2a] & char.flag.FACING_LEFT)
			dx = -dx

		angle = (angle + 4) & 0xf8
		dx += (8 - lookupSin(angle)) >> 4
		dy += (8 + lookupCos(angle)) >> 4
	}

	objA1.position.x.u16 = u16[A3 + 0x10] + dx
	objA1.position.y.u16 = u16[A3 + 0x14] + dy

	fn022224()
}

//# address-hook(0x0222f4) end(0x02237c)
function void fn0222f4()
{
	if (!original_mode)
	{
		base.fn0222f4()
		return
	}

	if (u8[A2 + 2] != 0)
	{
		--u8[A2 + 2]
		if (u8[A2 + 2] != 0)
		{
			return
		}
	}

	u16 dx = objA1.position.x.u16 - objA0.position.x.u16 + 0x10
	u16 dy = objA1.position.y.u16 - objA0.position.y.u16
	if (dx < 0x20 && dy < 0x18)
	{
		if (u8[A1 + 0x2e] == 0 && u8[A1 + 0x05] < 0x04 && debug_mode.state == 0)
		{
			objA1.render_flags &= ~render_flag.FLIP_Y
			objA1.position.x.u16 = objA0.position.x.u16
			objA1.position.y.u16 = objA0.position.y.u16 + 0x14
			objA1.velocity.x = 0
			objA1.velocity.y = 0
			u16[A1 + 0x1c] = 0
			objA1.state = char.state.HANGING
			u8[A1 + 0x2e] = 3
			u8[A1 + 0x3d] = 0

			u8[A2] = 1
			playSound(SFX_GRAB)
		}
	}
}






// Don't delete underwater AIZ flames in Original Mode.
//# address-hook(0x02bf5a) end(0x02bf66)
function void GenericObject.Update()
{
#if STANDALONE
	// Check if it's an underwater flame in AIZ
	if (objA0.sprite_attributes == (sprite_attribute.PALETTE.LINE3 | 0x02e9) && objA0.mapping_offset == 0x02bfda && !original_mode)
	{
		if (objA0.position.y.u16 >= water.height.current - 10)
		{
			UnloadObject()
			return
		}
	}
#endif

	Object.animationUpdate(0x02bf9c)
	DrawOrUnloadObject()
}




// When the AIZ waterfall log spawner first loads, create more logs underneath as if the logs had always been falling.
// This makes climbing the logs from below more useful and apparent, as there is no waiting for the spawner to drop the logs.
// This must be coupled with loading the spawner at all y positions in Object Pos data.
// Function taken from objects\01_aiz\aiz_waterfallwood.lemon
//# address-hook(0x02b586) end(0x02b5ce)
function void AIZWaterfall.Init()
{
	if (objA0.position.x.u16 == 0x1c40 && u16[0xffffb014] > 0x0610)		// on Knux AIZ2 path heading under falling logs on S/T path
	{
	//	UnloadObject()													// Now that we load falling logs at all y positions, we need this safety check. Commented out full unload so if we debug move to S/T path, it functions.
		return															// The falling logs above the AIZ1 Sonic intro don't fall into the intro area quickly enough to cause an issue.
	}

	base.AIZWaterfall.Init()
	if (original_mode)
		return

	// Spawn more platforms underneath to make the waterfall climb accessible right away from below
	u16 backupYpos = objA0.position.y.u16
	objA0.position.y.u16 -= 0x80 - (level.framecounter.low & 0x7f)		// the spawner in DAGE levels spawns a log every 0x80 frames per the level framecounter, with each log moving downward at 1 pixel per second.
	u8 waterfallHeight = (objA0.position.x.u16 == 0x1c40) ? 2 : 3		// number of logs that fit between the source and the water. Only 2 for the S/T route waterfall in Act 2.
	for (u8 i = 0; i <= waterfallHeight; ++i)
	{
		objA0.position.y.u16 += 0x80
		if (objA0.position.y.u16 < (water.height.current - 1))	// use -1 because the object moves down one pixel *before* checking for deletion
			AIZWaterfall.spawnPlatform()
	}
	objA0.position.y.u16 = backupYpos
}




// Adjust where the camera vertically locks for the blimp sequence based on screen resolution.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01c746) end(0x01c75e)
function void fn01c746()
{
	if (original_mode)
	{
		base.fn01c746()
		return
	}
	if (u16[0xffffb010] >= 0x3fce && u16[0xffffb014] < 0x01c0)
	{
		D0.u16 = 0x015a
		level.vertical_wrap = D0.u16
		move_area.top.target = D0.u16
		camera.update_routine += 2
	}
}




// Force Original Mode to use the base S3&K AIZ2 blimp sequence.
// Functions taken from level\01_aiz\aiz2_blimp_sequence.lemon
//# address-hook(0x05034a) end(0x05038c)
function void fn05034a()
{
	objA0.update_address = 0x050390
	u32[A0 + 0x2e] = 0x23c0a6
	s16[A0 + 0x32] = 0x01a4		// Time until first bomb drop
#if STANDALONE
	if ((time_attack >= 3 || (Game.getSetting(SETTING_AIZ_BLIMPSEQUENCE)) && !original_mode))
	{
		s16[A0 + 0x32] = 0x0120 - 0x50
	}
#endif

	D1.u16 = 0x3fbc
	D2 = 1
	while (D2.s16 >= 0)
	{
		// Spawn blimp propellers
		if (!allocDynamicObjectAfterA0())
			break

		objA1.update_address = 0x050426
		u16[A1 + 0x2e] = D1.u16
		D1.u16 = 0x3dcc
		--D2.s16
	}

	// Loads palette colors 0x10 .. 0x1f
	copyMemory(0xfffffc20, 0x23c05a, 0x20)

	fn050390()
}


//# address-hook(0x050390) end(0x050424)
function void fn050390()
{
	// Blimp movement
#if STANDALONE
	if (time_attack >= 3 || (Game.getSetting(SETTING_AIZ_BLIMPSEQUENCE) && !original_mode))
	{
		u32[0xffffee98] -= 0x10000
	}
	else
	{
		u32[0xffffee98] -= 0x8800 + ((getScreenExtend() / 4) << 8)
	}
#else
	u32[0xffffee98] -= 0x8800
#endif

	if (u16[0xffffee98] < 0x3cdc)
	{
		objA0.update_address = 0x0506be
		u8[0xffffeec4] = 0xff
		if (allocDynamicObjectAfterA0())
		{
			// Spawn the tree spawner
			objA1.update_address = 0x050614
		}
		return
	}

	D1.u16 = u16[0xffffee98]
	D0.u16 = u16[0xffffee98] - 0x3d5c
	if (D0.s16 < 0)
	{
		u16[0xffffee9c] = u16[0xffffeea2] + ((-D0.s16) >> 1)
	}
	else
	{
		D1.u16 = (D1.u16 >> 2) & 0x0f
		u16[0xffffee9c] = u16[0xffffeea2] + u8[0x23c096 + D1.s16]
	}

	D0.u16 = (level.framecounter - 1) & 0x0f
	if (D0.u16 == 0)
	{
		playSound(0xbd)
	}

	--s16[A0 + 0x32]
	if (s16[A0 + 0x32] == -1)	// Do not check for (s16[A0 + 0x32] < 0) here, as this would lead to different behaviour
	{
		// Table with bomb spawn data from 0x23c0a6 on;
		// consists of 21 entries with the following 2 words each:
		//  - Frames until next bomb drop (0x20 or 0x40)
		//  - Position offset, e.g. 0x3f5c
		A2 = u32[A0 + 0x2e]
		objA0.value32 = u16[A2]

		if (s16[A0 + 0x32] >= 0)
		{
			if (allocDynamicObjectAfterA0() && u16[A0 + 0x30] != 0x7fff)
			{
				// Spawn bomb
				objA1.update_address = 0x05047c
				u16[A1 + 0x2e] = u16[A2+2]

				u32[A0 + 0x2e] += 4
			}
		}
	}
}





// Force Original Mode to use the base S3&K AIZ2 blimp sequence.
// Revisited Mode uses a simplified version of the A.I.R. sequence that is traversable with the same jumps:
// bombs spawning at "dummy" position 0x7fff are immediately deleted.
// Function taken from standalone\rom_manipulations.lemon
function void ROMManipulation.AIZ2.BlimpSequenceBombs()
{
	A0 = 0x23c0a6

	if (time_attack >= 3 || (Game.getSetting(SETTING_AIZ_BLIMPSEQUENCE)))
	{
		// New sequence
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x3f5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x4e, 0x7fff)

		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x3f5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x12, 0x7fff)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x3edc)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x30, 0x3eac)

		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x3f5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x12, 0x7fff)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x3edc)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x12, 0x7fff)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x3e5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x16, 0x3e2c)

		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x7fff)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x12, 0x3f2c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x3edc)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x12, 0x3eac)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x0c, 0x7fff)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x12, 0x3e2c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x40, 0x3dec)

		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x40, 0x7fff)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x04, 0x3dec)
	}
	else
	{
		// Original values
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3f5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3f2c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3f5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3f2c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3f5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x38, 0x3f2c)

		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3edc)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3eac)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3edc)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3eac)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3edc)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x38, 0x3eac)

		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3e5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3e2c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3e5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3e2c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x20, 0x3e5c)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x38, 0x3e2c)

		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x40, 0x3dec)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x40, 0x3dec)
		ROMManipulation.AIZ2.BlimpSequenceBombs.addBlimpSequenceBomb(0x40, 0x3dec)
	}
}




// Bombs that are given "dummy" positions in the bomb drop location table above should be unloaded.
//# address-hook(0x0504dc) end(0x0504e8)
function void fn0504dc()
{
	if (objA0.position.x.u16 > 0x5000)	// dummy entry in the sequence
		UnloadObject()
	else
		base.fn0504dc()
}





// When Eggman flies behind the trees at the end of AIZ2, adjust some chunks at the horizontal loop point
// to prevent a rendering issue with the loop.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x0500e6) end(0x0500e6)
function void fn0500e6()
{
	if (camera.position.x.u16 >= 0x4600)
	{
		u8[0xffff8243] = 0xea
		u8[0xffff82db] = 0xe9
		u8[0xffff8373] = 0xe8
	}

	base.fn0500e6()
}








// Undo AIR's adjustments for the camera position in the AIZ2 boss in Original Mode,
// as they prevent the right-side pit from being on screen.
//# address-hook(0x069456) end(0x069466)
function void fn069456()
{
	D0.u16 = move_area.left + 2
	if (D0.u16 <= u16[0xfffffa84])
		move_area.left = D0.u16

	move_area.right += 2
	if (!original_mode)
	{
		if (camera.position.y.u16 < 0x300)
		{
			// Sonic/Tails route boss
			move_area.right = min(move_area.right, 0x4990)
		}
		else
		{
			// Knuckles route boss
			move_area.right = min(move_area.right, 0x4240)
		}
	}

	fn06946a()
}





// Add to the end of AIZ2 Knux's camera lock to lock the y position in place.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01c81e) end(0x01c868)
function void fn01c81e()
{
	if (camera.position.x.u16 >= 0x3b80 && kosinski.waiting_modules == 0)
	{
		Kosinski.addToDecompressionQueue(0x3b1372, 0xffff9ab8)
		Kosinski.addToDMAQueue(0x3b48c6, 0x3f80)

		Level.loadPaletteData(0x30)

		move_area.left = 0x3b80
		move_area.bottom.target = 0x05da
		if (!original_mode)
			level.vertical_wrap = 0x05da	// new line here disallows upward camera movement
		u8[0xffffeec6] = 0xff
		camera.update_routine += 2
	}
}







// Allow the AIZ2 ending cutscene to play at either boss
// to better support future mods.
// Only a partial fix is in place right now. Chaos the Imposter does not need this as it uses the Knux "jump from bridge" scene instead.
// Functions taken from level\01_aiz\aiz2_post_boss_cutscene.lemon

// //# address-hook(0x065bd4) end(0x065bf6)
// function void fn065bd4()	// This function is the main function for the switch in some Knuckles cutscenes.
// {
	// This is also used in CNZ 2

//	if (isMainCharacter(CHARACTER_KNUCKLES))
//	{
//		UnloadObject()
//		return
//	}

// #if STANDALONE
	// Also unload for other characters in Time Attack, which skips Knuckles cutscenes anyway
//	if (time_attack)
//	{
//		UnloadObject()
//		return
//	}
// #endif

//	setupObjectAttributesFull(0x066402)
//	objA0.update_address = 0x065c04
//	objA0.position.y.u16 += 4
//	if (global.zone_act == 0x0001 && u16[0xffffb014] > 0x0400)	// if AIZ2 and character y position is on Knux's lower path
//	{
//		objA0.position.x.u16 -= 0x0780	// adjust x coordinates of cutscene
//		objA0.position.y.u16 += 0x0480	// adjust y coordinates of cutscene
//	}

//	addPatternLoadingCue(0x065bfc)
// }

//# address-hook(0x061fc2) end(0x062012)
function void fn061fc2()	// This function loads cutscene Knuckles in AIZ2.
{
	A1 = 0x0663ba
	if (fn084fa4())
		return

	objA0.position.x.u16 = 0x4b8e
	objA0.position.y.u16 = 0x017d
	if (u16[0xffffb014] > 0x0400)	// if character y position is on Knux's lower path
	{
		objA0.position.x.u16 -= 0x07c8	// adjust x coordinates of cutscene // should be 0x0780	// this is Knux's position
		objA0.position.y.u16 += 0x0480	// adjust y coordinates of cutscene
	}
	objA0.render_flags |= render_flag.FLIP_X
	fn065dd6()

	objA0.countdown_value = 119
	objA0.countdown_callback = 0x06201a

	CutsceneKnuckles.loadPalette()

	spawnSimpleChildObjects(0x06655a)

	if (_equal())
	{
		objA1.position.x.u16 = 0x4b08
		objA1.position.y.u16 = 0x0178
		if (u16[0xffffb014] > 0x0400)	// if character y position is on Knux's lower path
		{
			objA1.position.x.u16 -= 0x0780	// adjust x coordinates of cutscene // should be 0x0780
			objA1.position.y.u16 += 0x0480	// adjust y coordinates of cutscene
		}
	}
}




// Remove a sidekick Tails position fix from Original Mode
// Function taken from bosses\boss_aiz2.lemon
//# address-hook(0x069588) end(0x0695a6)
function void fn069588()
{
	tails.catch_timeout = 5
	if (player1.control_override)
	{
	#if STANDALONE
		if (getNumPlayers() >= 2 && !original_mode)
		{
			// Make Tails stop next to Sonic
			if (u16[0xffffb04a + 0x10] > u16[0xffffb000 + 0x10] + 0x10)
			{
				u16[0xffffb04a + 0x18] = 0
				u16[0xffffb04a + 0x1c] = 0
			}
		}
	#endif

		control.player1 = 0x0101		// CONTROL_UP, CONTROL_UP
		control.tails = 0
	}
	else
	{
		objA0.update_address = 0x0695a8
	}
}





// Do not change the player control override flag when a bridge collapses in Original Mode
// Function taken from maingame\cutscene_knuckles.lemon

// AIZ 2 button reaction

//# address-hook(0x065c56) end(0x065c6c)
function void fn065c56()
{
	if (!Game.getSetting(SETTING_FIX_GLITCHES) || original_mode)
	{
		// In standalone, this is done in "fn02b452", so player can't jump and avoid falling down
		player1.control_override = 0
	}

	D0.u16 = 0x1000
	screenmover_target.bottom = D0.u16
	move_area.bottom.target = D0.u16

	// "spawnSimpleChildObjects(0x084b12)" replaced by:
	spawnSimpleChildObjects(0x084ad2, 1)		// Screen mover for the lower border
}




// If sidekick Tails touches a bubble, do not let him pop it.
// Function taken from objects\level\airbubbles.lemon
//# address-hook(0x02fbb2)
function void fn02fbb2()
{
	// New: decrement sidekick Tails interaction blocking timer if set.
	if (u8[A0 + 0x42] && A1 == 0xffffb04a)
	{
		--u8[A0 + 0x42]
		return
	}

	if (u8[A1 + 0x2e] & control_flag.DISABLE_INTERACTION)
		return

	D0.u16 = objA1.position.x.u16
	D1.u16 = objA0.position.x.u16
	if (D0.u16 <= D1.u16 - 0x10 || D0.u16 > D1.u16 + 0x10)
		return

	D0.u16 = objA1.position.y.u16
	D1.u16 = objA0.position.y.u16
	if (D0.u16 <= D1.u16 || D0.u16 > D1.u16 + 0x10)
		return

	if (u8[A1 + 0x2b] & char.bonus.SHIELD_BUBBLE)
		return	// Ignore if player has a bubble shield

	// Collect bubble
	UpdateMusicOnWaterTransition()

	playSound(0x38)

	objA1.velocity.x = 0
	objA1.velocity.y = 0
	objA1.groundspeed = 0
	objA1.state = char.state.BREATHE
	u16[A1 + 0x32] = 0x23
	u8[A1 + 0x40] = 0
	objA1.flags2a &= ~(char.flag.CONTROL_LOCK | char.flag.PUSHING)

	if (u8[A1 + 0x2a] & char.flag.ROLLING)
	{
		if (objA1.update_address == addressof(Character.BaseUpdate.Sonic))		// Checking for Sonic, might be clearer to check `u8[A1 + 0x38] == CHARACTER_SONIC` instead
		{
			u8[A1 + 0x2a] &= ~char.flag.ROLLING
			objA1.hitbox_extends.y = char.hitbox.y.UPRIGHT
			objA1.hitbox_extends.x = char.hitbox.x.UPRIGHT
			objA1.position.y.u16 -= 0x05
		}
		else
		{
			objA1.hitbox_extends.y = char.hitbox.y.UPRIGHT_TAILS
			objA1.hitbox_extends.x = char.hitbox.x.UPRIGHT
			--objA1.position.y.u16
		}
	}
	if (objA0.base_state != 0x06)
	{
		if (!original_mode && A1 == 0xffffb04a && objA1.state == char.state.BREATHE && !u8[A0 + 0x42])	// do not pop the bubble if sidekick Tails touches it outside of Original Mode
		{
			u8[A0 + 0x42] = 60	// instead, set a timer that says Tails cannot interact with this bubble for one second
			return
		}

		objA0.base_state = 0x06
		objA0.state += 0x04
	}
}








// Removes special check for HCZ1's first water pool.
//# address-hook(0x006c34) end(0x006ca0)
function void UpdateWater()
{
	if (!level.water_present)
	{
		fn00714e()
		return
	}

	if (u8[0xffffee30] == 0 && u8[0xffffb005] < 0x06)
	{
		fn006f4a()
		UpdateWaterSurfaceLevel()
	}

	water.fullscreen = 0
	water.height.current = water.height.next

// #if STANDALONE
	// This fixes an occasional palette glitch
//	if (global.zone_act == 0x0100 && camera.position.x.u16 <= 0x900)
// #else
//	if (global.zone_act == 0x0100 && camera.position.x.u16 < 0x900)
// #endif
//	{
		// Special handling for HCZ 1 first part
		// h_int.line = 0xff
		// return
//	}

	s16 waterScreenPositionY = water.height.current - camera.position.y.u16
	if (waterScreenPositionY > 0)
	{
	#if STANDALONE
		if (waterScreenPositionY >= getScreenHeight())
			waterScreenPositionY = 0xff
	#else
		if (waterScreenPositionY >= getScreenHeight() - 1)
			waterScreenPositionY = 0xff
	#endif

		h_int.line = waterScreenPositionY
		fn00714e()
	}
	else
	{
		water.fullscreen = 1
		h_int.line = 0xff
	}
}






// Remove the palette change that is used for the first pool in HCZ1
// //# address-hook(0x01c892) end(0x01c8b6)
// function void fn01c892()
// {
//	if (camera.position.x.u16 < 0x0360 && camera.position.y.u16 >= 0x03e0)
//	{
//		A1 = 0xfffffc70
//		u16[(A1+=2)-2] = 0x0b80	// originally 0x0b80 but should be 0x0680; this typo is documented in S3Unlocked
//		u16[(A1+=2)-2] = 0x0240
//		u16[(A1+=2)-2] = 0x0220
//		camera.update_routine += 2
//	}
// }





// Changes the water level in HCZ1 once the player is far enough away from the initial pool, add water tint,
// and adds water level, turbine imagery, and screen boundary checks to the boss area for time attack modes.
// Function taken from level\level_water.lemon
//# address-hook(0x006e82) end(0x006e88)
function void UpdateWaterSurfaceLevel.HCZ1()
{
	if (camera.position.x.u16 < 0x0480)	// start of Knuckles' path
	{
		water.height.current = 0x0500
		water.height.target = 0x0500
		water.height.next = 0x0500
	}
	else if (camera.position.x.u16 < 0x3600) // most of level
	{
		water.height.current = 0x0680
		water.height.target = 0x0680
		water.height.next = 0x0680
	}
	else								// boss area
	{
		water.height.current = (time_attack == 1 || time_attack == 2) ? 0x070c : 0x06a0
		water.height.target = water.height.current
		water.height.next = water.height.current

		if (time_attack == 1 || time_attack == 2)
		{
			// Code from fn069eda() in boss_hcz1.lemon that sets screen boundaries
			D0.u16 = 0x0638
			if (D0.u16 <= camera.position.y.u16)
			{
				level.vertical_wrap = D0.u16
				move_area.bottom.current = D0.u16
				move_area.bottom.target = D0.u16
			}
			move_area.left = camera.position.x.u16
			D0.u16 = 0x3680 - getScreenExtend()
			if (camera.position.x.u16 >= D0.u16)
			{
				move_area.left = D0.u16
				move_area.right = 0x3680 + getScreenExtend()
			}
			screenmover_target.right = move_area.right
		}
	}
}



// Do not implement certain bug fixes for HCZ hand launchers in original mode.
// Function taken from objects\02_hcz\hcz_handlauncher.lemon.
// Function does not have an address hook.
function void fn030cf8()
{
	u8 bit = (1 << D6.u8)

#if STANDALONE
	// Bug fix: If character gets hurt, don't launch him
	if (u8[A1 + 0x05] != 0x02 && !original_mode)
	{
		u8[A0 + 0x35] &= ~bit
		if (u8[A0 + 0x35] == 0)
		{
			u8[A0 + 0x34] = 0
		}
	}
#endif

	if (u8[A0 + 0x35] & bit)
	{
		// Check if jump button pressed
		if (D0.u8 & CONTROL_ABC)
		{
			u8[A0 + 0x35] &= ~bit
			objA0.flags2a &= ~bit
			objA1.velocity.x = (objA0.flags2a & 0x01) ? -0x800 : 0x800
			objA1.velocity.y = -0x400
			s16[A1 + 0x1c] = objA1.velocity.x
			u8[A1 + 0x2e] = 0
			u8[A1 + 0x2a] &= ~char.flag.ON_OBJECT
			u8[A1 + 0x2a] |= char.flag.IN_AIR
			if (u8[A0 + 0x35] == 0)
			{
				u8[A0 + 0x34] = 0
			}
		}
		return
	}

	if (objA0.flags2a & bit)
	{
		if (u8[A0 + 0x34] == 0)
		{
			D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + 8
			if (D0.u16 >= 0x10)
				return
		}

		if (u8[A1 + 0x2e] == 0 && debug_mode.state == 0)
		{
			u8[A0 + 0x35] |= bit

			playSound(SFX_ROLL)

			u8[A1 + 0x20] = 0
			u8[A1 + 0x1e] = (objA1.update_address == 0x01365c) ? 0x0f : 0x13
			u8[A1 + 0x1f] = 0x09
			objA1.flags2a &= ~char.flag.FACING_LEFT
			objA1.flags2a &= ~char.flag.ROLLING
			objA1.flags2a &= ~char.flag.PUSHING
			if (!original_mode)
				objA1.flags2a &= ~char.flag.IN_AIR	// Fix for wrong placement of the character if bubble-bouncing onto the hand launcher, #contributed by iCloudius
			u8[A1 + 0x2e] = 1
			objA1.position.x.u16 = objA0.position.x.u16 - 2
			u16[A1 + 0x1c] = 0x1000
			if (objA0.flags2a & 0x01)
			{
				objA1.position.x.u16 += 4
				s16[A1 + 0x1c] = -s16[A1 + 0x1c]
				objA1.flags2a |= char.flag.FACING_LEFT
			}
			u8[A0 + 0x34] = 1
		}
	}
}

// Function taken from level\level_water.lemon
//# address-hook(0x006d6c) end(0x006d9a)
function void UpdateWaterSurfaceLevel()
{
	if (unlock_act == 2 && layout.part >= 1)
		UpdateWaterSurfaceLevel.CPZ()
	else
		base.UpdateWaterSurfaceLevel()
}

function void UpdateWaterSurfaceLevel.CPZ()	// make the water level oscillate
{
	bool KnuxHard = (layout.part == 2)
	u16 baseWaterHeight = (water.height.target < 0x0580) ? 0x0510 : 0x0710
	if (KnuxHard)
	{
		// Hard layout
		baseWaterHeight = 0x0590
		water.height.current = 0x0590
//		water.height.next = 0x0590
//		water.height.target = 0x0590

		if (u16[0xffffb010] > 0x4380 && u16[0xffffb014] > 0x0500)
			baseWaterHeight = 0x0720

		if (u16[0xffffb010] >= 0x470a || (u16[0xffffb010] >= 0x46e0 && u16[0xffffb014] <= 0x0680))
		{
			baseWaterHeight = 0x0290
		}
	}
	else if (layout.part == 1  && camera.position.x.u16 >= 0x1de0 + 0x0700 - getScreenExtend() && water.height.current > 0x0600)	// added 0x0700 in x before original Act 2
	{
		// Normal layout
		baseWaterHeight = 0x0510
		if (u16[0xffffb014] < 0x0380)		// if the player character is well above the water,
		{
			water.height.current = baseWaterHeight	// move it instantly
			water.height.next = baseWaterHeight
		}
	}
	// Update changing water surface height
	water.height.target = baseWaterHeight + (u8[0xfffffe70] >> 1)
	if (water.height.next != water.height.target)
	{
		if (water.height.next < water.height.target)
			water.height.next += water.height.changerate
		else
			water.height.next -= water.height.changerate
	}
}



// Allow the original S3&K's one-pixel character shift on rotating pillars in Original Mode.
// Function taken from objects\02_hcz\hcz_rotatingpillar.lemon
//# address-hook(0x032784) end(0x0328c2)
function void fn032784()
{
#if STANDALONE
	if (debug_mode.state)
		return
#endif

	u8 bit = (1 << D6.u8)
	D0.u8 = u8[A2]
	if (D0.u8 == 0)
	{
		if (objA0.flags2a & bit)
		{
			u8[A2 + 0x01] = 0
			D0.u16 = objA1.position.x.u16 - objA0.position.x.u16
			if (D0.s16 < 0)
			{
				D0.s16 = -D0.s16
				u8[A2 + 0x01] = 0x80
			}
			u8[A2 + 0x02] = D0.u8

			objA1.velocity.x = 0
			objA1.velocity.y = 0
			u16[A1 + 0x1c] = 0
			u8[A1 + 0x1e] = u8[A1 + 0x44]
			u8[A1 + 0x1f] = u8[A1 + 0x45]
			u8[A1 + 0x20] = 0
			objA1.flags2a &= ~(char.flag.IN_AIR | char.flag.ROLLING | char.flag.CONTROL_LOCK | char.flag.PUSHING)
			u8[A1 + 0x2e] = 0x03
			u8[A1 + 0x40] = 0

			u8[A2] = 1
			fn03260a()
		}
		return
	}

	if ((objA1.render_flags & render_flag.VISIBLE) && u8[A1 + 0x05] < 0x04)
	{
		if ((objA0.flags2a & bit) == 0)
		{
			u8[A2] = 0
			return
		}

		if (u8[A2 + 0x02] != 0)
		{
			--u8[A2 + 0x02]
		}

		D0 = u8[A2 + 0x01]
		LookupSinCos()
		D0.u16 = (D0.s16 + 0x0100) >> 2
		u8[A2 + 0x03] = D0.u8

		D2 = u16[A2 + 0x02]
		D1.s32 = s32(D1.s16) * D2.s16
		if (!original_mode)
		{
			bool negative = D1.s32 < 0 				// Prevents the game from shifting the characters over a pixel
			D1.s32 = (negative) ? -D1.s32 : D1.s32	// everytime the game mirrors the rotation animation; #contributed by iCloudius
			D1 >>= 16
			D1.u16 = (negative) ? -D1.u16 : D1.u16
		}
		else
		{
			D1 = (D1 << 16) + (D1 >> 16)
		}
		D1.u16 += objA0.position.x.u16
		objA1.position.x.u16 = D1.u16
		u8[A2 + 0x01] += 2
		u16[A1 + 0x1c] = 0
		D0.u16 = objA0.velocity.y
		if (D0.s16 < 0)
			D0.s16 = -D0.s16

		if ((u8[A1 + 0x2a] & char.flag.IN_AIR) == 0)
		{
			if (D0.u16 >= 0x0480)
			{
				u16[A1 + 0x1c] = 0x0800
			}
		}

		// Check if jump button pressed
		D5.u8 &= CONTROL_ABC
		if (D5.u8 == 0)
		{
			fn03260a()
			return
		}

		u8[A1 + 0x40] = 0x01
		u8[A1 + 0x1e] = 0x0e
		u8[A1 + 0x1f] = 0x07
		u8[A1 + 0x20] = char.state.ROLLING
		u8[A1 + 0x2a] |= char.flag.ROLLING
		objA1.velocity.y = objA0.velocity.y - 0x680
		objA1.velocity.x = 0
		u16[A1 + 0x1c] = 0
	}

	u8[A1 + 0x2a] |= char.flag.IN_AIR
	objA1.sprite_priority = 0x0100
	u8[A1 + 0x2e] = 0
	u8[A2] = 0
}




// In Original Mode, force characters to disappear in transparent water pipes.
// Functions taken from objects\02_hcz\hcz_waterpipe.lemon
//# address-hook(0x0302e6) end(0x030332)
function void fn0302e6()
{
	if (kosinski.waiting_modules != 0)
	{
		u16[0xffffb000 + 0x14] -= 8
		u16[0xffffb04a + 0x14] -= 8
		return
	}

	objA0.render_flags |= render_flag.WORLD
	objA0.sprite_priority = 0x0300
	objA0.mapping_offset = 0x22ee10
	objA0.sprite_attributes = (sprite_attribute.PALETTE.LINE2 | 0x0500)
	objA0.box_size.x = 0x20
	objA0.box_size.y = 0x60
	u16[A0 + 0x30] = 0x60

	// Removed unnecessary hiding while moving through the transparent tube
	// Thank to Fred Bronze for pointing out that this is not needed at all! (https://s3unlocked.blogspot.de/2017/12/sonic-eraser.html)
	if (!Game.getSetting(SETTING_HCZ_WATERPIPE) || original_mode)
	{
		u8[0xffffb000 + 0x20] = char.state.DISAPPEARED
		u8[0xffffb04a + 0x20] = char.state.DISAPPEARED
	}

	objA0.update_address = 0x030338
	fn030338()
}

//# address-hook(0x030338) end(0x0303e8)
function void fn030338()
{
	if (Game.getSetting(SETTING_HCZ_WATERPIPE) && !original_mode)
	{
		// Move characters to the center, to avoid otherwise possible clipping at the border
		for (u32 i = 0xffffb000 + 0x10; i <= 0xffffb04a + 0x10; i += 0x4a)
		{
			s16 dx = s16(u16[i] - objA0.position.x.u16)
			if (dx < -8)
				++u16[i]
			else if (dx > 8)
				--u16[i]
		}
	}

	if (u16[A0 + 0x30] != 0)
	{
		--u16[A0 + 0x30]
		objA0.position.y.u16 -= 8
	}

	u16[0xffffb000 + 0x14] -= 8
	u16[0xffffb04a + 0x14] -= 8
	if (u16[A0 + 0x30] <= 0x28)
	{
		u8[0xffffb000 + 0x20] = char.state.GOT_HURT
		u8[0xffffb04a + 0x20] = char.state.GOT_HURT
		objA0.update_address = 0x03041a

		playSound(0x57)
		u8[0xfffff650] = 1

		A3 = 0x0303ea
		D2.u16 = objA0.position.x.u16
		D3.u16 = objA0.position.y.u16 - 0x80
		D1 = 0x07
		while (D1.s16 >= 0)
		{
			if (!allocDynamicObjectAfterA0())
				break

			objA1.update_address = 0x03011a
			objA1.mapping_offset = 0x22ef0e
			objA1.sprite_attributes = (sprite_attribute.PALETTE.LINE2 | 0x0558)
			objA1.render_flags = (render_flag.WORLD | render_flag.VISIBLE)
			objA1.position.x.u16 = D2.u16 + s8[(A3+=1)-1]
			objA1.position.y.u16 = D3.u16 + s8[(A3+=1)-1]
			objA1.sprite_priority = 0x0280
			objA1.box_size.x = 0x18
			objA1.box_size.y = 0x18
			objA1.velocity.x = u16[(A3+=2)-2]
			objA1.velocity.y = u16[(A3+=2)-2]
			u8[A1 + 0x22] = D1.u8

			--D1.s16
		}
	}
}




// For the door at the start of HCZ1 Sonic/Tails (end of Knux's area), do not allow off-screen Tails to open it.
// Function taken from objects\04_cnz\cnz_trapdoor.lemon
//# address-hook(0x030f58) end(0x030f84)
function void fn030f58()
{
	D0.u16 = objA1.position.x.u16
	if (D0.s16 >= D2.s16 && D0.u16 < D3.u16)
	{
		D0.u16 = objA1.position.y.u16
		if (D0.u16 >= D4.u16 && D0.u16 < D5.u16 && s8[A1 + 0x2e] >= 0)
		{
			objA0.flags38 = 1
		}
	}
	// This specific door in HCZ1 should not open if Knuckles is not the main character, or else Sonic + Tails can get a Knuckles-only giant ring.
	if (global.zone_act == 0x0100 && objA0.position.x.u16 == 0x0af0 && objA0.position.y.u16 == 0x0660 && !isMainCharacter(CHARACTER_KNUCKLES))
		objA0.flags38 = 0
}





// After the HCZ1 boss, don't let the waves disappear for one frame.
// This fix is imported from the first AIR version after v22.09.10.00.
// Function taken from level\02_hcz\level_hcz.lemon
//# address-hook(0x050c4c) end(0x050cfa)
function void fn050c4c()
{
	if (kosinski.waiting_modules == 0)
	{
		global.zone_act = 0x0101
		camera.update_routine = 0
		dynobjects.routine = 0
		rings.update_routine = 0
		level.boss_encounter = 0
		global.in_extra_stage = 0
		fn04f8f8()

		u32[0xffffb172] = 0x0383bc		// HCZ run-on-water handler
		u8[0xffffb172 + 0x2c] = 0x01

		u32 backupD7 = D7
		u32 backupA0 = A0
		u32 backupA2 = A2
		u32 backupA3 = A3

		fn01c362()
		fn0076a6()
		Level.InitializeWater()

		D0.u16 = 0x06a0
		water.height.current = D0.u16
		water.height.next = D0.u16
		water.height.target = D0.u16

		Level.loadPaletteData(0x0d)

		D7 = backupD7
		A0 = backupA0
		A2 = backupA2
		A3 = backupA3

		D0.u16 = 0x3600	// offsetX
		D1 = 0
		u16[0xffffb000 + 0x10] -= D0.u16
		u16[0xffffb04a + 0x10] -= D0.u16
		fn04f3b0()

		camera.position.x.u16 -= D0.u16
		camera.foreground.x.u16 -= D0.u16
		move_area.left -= D0.u16
		move_area.right -= D0.u16
		Level.GetCameraPosition()

		level.scrolling_routine = 0

	#if STANDALONE
		// Move the waves effect as well, to avoid a one-frame glitch here
		if (u32[0xffffcf82] == 0x01f244 && !original_mode)
		{
			u16[0xffffcf82 + 0x10] -= D0.u16	// offsetX replaces the D0.u16 variables in this function in future AIR
		}
	#endif
	}

	UpdateBackground.HCZ1()

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x23c590
	A5 = 0xffffa800
	fn04f0ce()
}



// Load HCZ chunks from rawdata instead of ROM.
// Function taken from level\02_hcz\level_hcz.lemon
//# address-hook(0x050bce) end(0x050c48)
function void fn050bce()
{
	if (u16[0xffffeec6] != 0)
	{
		u16[0xffffeec6] = 0

		u32 backupD7 = D7
		u32 backupA0 = A0
		u32 backupA2 = A2
		u32 backupA3 = A3

	//	Kosinski.addToDecompressionQueue(0x3c18ee, 0xffff0a00)	// Act 2 chunks
		System.loadExternalRawData(stringformat("hcz2_chunks_s", global.act + 1), KosinskiRawdataBuffer)		// copy Secondary chunks to shared memory
		Kosinski.addToDecompressionQueue(KosinskiRawdataBuffer, 0xffff0a00)									// decompress them to their proper RAM (see above)

		Kosinski.addToDecompressionQueue(0x3bf17c, 0xffff9558)

		Kosinski.addToDMAQueue(0x3bfa6c, 0x2360)

		requestLoadingPatterns(0x10)
		requestLoadingPatterns(0x11)

		D7 = backupD7
		A0 = backupA0
		A2 = backupA2
		A3 = backupA3

		u8[0xffffeee8] = 0xff
		level.scrolling_routine += 4
	}

	UpdateBackground.HCZ1()

	A6 = 0xffffee90		// Address of camera.background.y
	A5 = 0xffffee96		// Address of camera.background.y.old
	D1 = 0
	D6 = 0x20
	LoadTileContentInDirY()

	A4 = 0x23c590
	A5 = 0xffffa800
	fn04f0ce()
}




function void HCZ1_CustomSprites()
{
	if (time_attack == 1 || time_attack == 2)
		Renderer.drawCustomSprite("hcz1_turbine", 0x370c - camera.foreground.x.u16, 0x06a0 - camera.foreground.y.u16, 0, 0x00, 0x9800)
	if (!original_mode)
	{
		Renderer.drawCustomSprite("hcz_ceilingshadow", 0x3720 - camera.foreground.x.u16, 0x0500 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2100)
		Renderer.drawCustomSprite("hcz_brick", 0x3620 - camera.foreground.x.u16, 0x0670 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4001)
		Renderer.drawCustomSprite("hcz_brick", 0x3620 - camera.foreground.x.u16, 0x06f0 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4001)
		Renderer.drawCustomSprite("hcz_brick", 0x3630 - camera.foreground.x.u16, 0x0700 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4001)
		Renderer.drawCustomSprite("hcz_brick", 0x3810 - camera.foreground.x.u16, 0x0640 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4001)
		if (palette_set >= 2)
			Renderer.drawCustomSprite("hcz_watertint", 0, max(camera.foreground.y.u16, water.height.current + 1) - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xdfe0, 0, hcz_murkiness)
	}
}

function void HCZ2_CustomSprites()
{
	if (!original_mode)
	{
		Renderer.drawCustomSprite("hcz_brick", 0x0020 - camera.foreground.x.u16, 0x0670 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4001)
		Renderer.drawCustomSprite("hcz_brick", 0x0020 - camera.foreground.x.u16, 0x06f0 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4001)
		Renderer.drawCustomSprite("hcz_brick", 0x0030 - camera.foreground.x.u16, 0x0700 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4001)
		Renderer.drawCustomSprite("hcz_brick", 0x0210 - camera.foreground.x.u16, 0x0640 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4001)
		Renderer.drawCustomSprite("hcz_backgroundballpillarsection", 0x458c - camera.foreground.x.u16, 0x0320 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
		Renderer.drawCustomSprite("hcz_backgroundballpillarsection", 0x458c - camera.foreground.x.u16, 0x0340 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
		Renderer.drawCustomSprite("hcz_backgroundballpillarsection", 0x468c - camera.foreground.x.u16, 0x0320 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
		Renderer.drawCustomSprite("hcz_backgroundballpillarsection", 0x468c - camera.foreground.x.u16, 0x0340 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
		Renderer.drawCustomSprite("hcz_backgroundballpillarsection", 0x478c - camera.foreground.x.u16, 0x0320 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
		Renderer.drawCustomSprite("hcz_backgroundballpillarsection", 0x478c - camera.foreground.x.u16, 0x0340 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
		if (palette_set >= 2)
		{
			u16 renderQueue = 0xdfe0
			for (u8 i = 0; i <= 0x6d; i++)
			{
				if (u32[0xffffb000 + (i * 0x4a)] == 0x02d8e2)
				{
					renderQueue = 0x9fe1	// when in act transition area, do not cover Angel theme zone name, act number, or red bar
					break
				}
			}
			Renderer.drawCustomSprite("hcz_watertint", 0, max(camera.foreground.y.u16, water.height.current + 1) - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, renderQueue, 0, hcz_murkiness)
		}
	}
}


// In Original Mode, don't apply an HCZ1 conveyor belt length change.
// Functions taken from objects\02_hcz\hcz_conveyorbelt.lemon
//# address-hook(0x031164) end(0x0311be)
function void fn031164()
{
	A1 = 0xffffcfe0
	D0 = objA0.subtype2c
	if (u8[A1 + D0.s16] != 0)
	{
		if (objA0.respawn_entry)
		{
			A2 = 0xffff0000 + objA0.respawn_entry
			u8[A2] &= ~0x80
		}
		UnloadObject()
		return
	}

	u8[A1 + D0.s16] = 1
	A1 = 0x031124 + (D0.u16 & 0x0f) * 4

	D0.u16 = u16[(A1+=2)-2]
	// Any changes to leftmost position of conveyors would go here using an if statement to exclude Original Mode while changing D0.u16.
	u16[A0 + 0x3c] = D0.u16
	if ((objA0.flags2a & 0x01) == 0)
	{
		D0.u16 -= 8
	}
	u16[A0 + 0x40] = D0.u16

	D0.u16 = u16[(A1+=2)-2]
	// Rightmost position changes go here.
	if (!original_mode && (objA0.subtype2c & 0x0f) == 0x0a)
		D0.u16 = 0x2658		// 0x2658 in original ROM hack and S3&K
	objA0.value3e = D0.u16
	if (objA0.flags2a & 0x01)
	{
		D0.u16 += 8
	}
	objA0.value42 = D0.u16

	objA0.update_address = 0x0311c4
	fn0311c4()
}

//# address-hook(0x031502) end(0x03157a)
function void fn031502()
{
	A1 = 0x031124 + (objA0.subtype2c & 0x0f) * 4
	u16[A0 + 0x3c] = u16[(A1+=2)-2]
	// Any changes to leftmost position of conveyors would go here using an if statement to exclude Original Mode while changing u16[A0 + 0x3c].
	objA0.value3e = u16[(A1+=2)-2]
	// Rightmost position changes go here, changing obja0.value3e.
	if (!original_mode && (objA0.subtype2c & 0x0f) == 0x0a)
		objA0.value3e = 0x2658		// 0x2658 in original ROM hack and S3&K
	objA0.mapping_offset = 0x23035e
	objA0.sprite_attributes = (sprite_attribute.PALETTE.LINE1 | 0x043e)
	objA0.render_flags |= render_flag.WORLD
	objA0.sprite_priority = 0x0280
	objA0.box_size.x = 0x0c
	objA0.box_size.y = 0x0c
	objA0.collision_attributes = (collision.flag.THREAT | collision.size.8x8)
	u16[A0 + 0x30] = objA0.position.x.u16
	objA0.value32 = objA0.position.y.u16

	if (objA0.flags2a & 0x01)
	{
		objA0.position.y.u16 += 0x18

		objA0.update_address = 0x0315d2
		fn0315d2()
	}
	else
	{
		objA0.position.y.u16 -= 0x18
		u16[A0 + 0x26] = 0x40

		objA0.update_address = 0x031580
		fn031580()
	}
}





// Remove Tails assist glitch fix from HCZ fans in Original Mode.
// Function taken from objects\02_hcz\hcz_fan.lemon
//# address-hook(0x03077e) end(0x030832)
function void fn03077e()
{
#if STANDALONE
	if (debug_mode.state != 0 && !original_mode)
		return
#endif

	if (u8[A1 + 0x05] >= 0x04)
		return

	D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + 0x18
	if (D0.u16 < 0x30)
	{
		D1 = objA1.position.y.u16 + u16[A0 + 0x36] + u8[0xfffffe84] - objA0.position.y.u16
		if (D1.s16 >= 0 && D1.u16 < u16[A0 + 0x38])
		{
			if (u8[A1 + 0x2e] == 0)
			{
				D1.u16 -= u16[A0 + 0x36]
				if (D1.s16 >= 0)
				{
					D1.u16 ^= 0xffff
					D1.u16 *= 2
				}

				D1.u16 += u16[A0 + 0x36]
				D1.s16 = (-D1.s16) >> 6
				objA1.position.y.u16 += D1.u16
				objA1.velocity.y = 0
				objA1.flags2a |= char.flag.IN_AIR
				objA1.flags2a &= ~char.flag.CONTROL_LOCK
				u8[A1 + 0x2f] = 0
				u8[A1 + 0x40] = 0

				if (objA0.subtype2c & 0x40)
				{
					// Underwater fan
					objA1.state = char.state.LIFTED
				}
				else if (u8[A1 + 0x27] == 0)
				{
					objA1.state = char.state.RUNNING
					u8[A1 + 0x27] = 1
					u8[A1 + 0x30] = 0x7f
					u8[A1 + 0x31] = 0x08
				}

			#if STANDALONE
				// Fix for bug when Tails carries other player and gets caught by the fan
				if (u8[A1 + 0x38] == CHARACTER_TAILS && tails.carrying && !original_mode)
				{
					u8[0xffffb000 + 0x2a] |= char.flag.IN_AIR
					u8[0xffffb000 + 0x2e] = 0
				}
			#endif
			}

			u16[A1 + 0x1c] = 1
		}
	}
}




// Use original fan bubble despawning behaviors in Original Mode.
// Also implement bubbles disappearing when off screen on the sides as well, not just above the screen.
// Function taken from objects\02_hcz\hcz_fan.lemon
//# address-hook(0x030834) end(0x03084a)
function void fn030834()
{
	bool shouldDespawn = (objA0.position.y.u16 <= water.height.current)
	if (!original_mode)
	{
		// Also despawn when far enough off screen in any direction except below the screen
		//  -> Without this, there's kind of a spam of bubbles in HCZ 1 (around X=0x1f40, Y=0x08c0) that can prevent regular object spawn
		shouldDespawn = shouldDespawn || (objA0.position.y.u16 < camera.position.y.u16 - 0x10) || (objA0.position.x.u16 < camera.position.x.u16 - 0x10) || (objA0.position.x.u16 > camera.position.x.u16 + getScreenWidth() + 0x10)
	}
	if (shouldDespawn)
	{
		UnloadObject()
		return
	}

	UpdateMovementStraightSimple()
	DrawObject()
}




// If below the square HCZ blocks that hold fans after coming up from underneath them, don't make the blocks solid.
// This helps with floor collision oddities and with ensuring Knuckles can climb the walls they touch.
// Function taken from objects\02_hcz\hcz_fan.lemon
//# address-hook(0x030850) end(0x0308f4)
function void fn030850()
{
	A1 = 0xffff0000 + u16[A0 + 0x3c]
	D0.u16 = u16[0xffffb000 + 0x14] - objA0.position.y.u16

	if (D0.s16 >= 0x20)
	{
		if (u8[A1 + 0x42] == 0)
		{
			u8[A1 + 0x42] = 0x01
			u16[A1 + 0x34] = 0
			playSound(0x58)
		}

		D1.u16 = u16[A0 + 0x3a]
		if (D1.u16 != u16[A0 + 0x30])
		{
			u16[A0 + 0x30] += 8
		}
	}
	else if (D0.s16 < -0x30)
	{
		if (u8[A1 + 0x42] != 0)
		{
			u8[A1 + 0x42] = 0
			u8[A1 + 0x24] = 0
			playSound(0x58)
		}

		if (u16[A0 + 0x30] != 0)
		{
			u16[A0 + 0x30] -= 8
		}
	}

	D0.u16 = u16[A0 + 0x30]
	if (objA0.flags2a & 0x01)
		D0.s16 = -D0.s16
	D0.u16 += u16[A0 + 0x40]
	objA0.position.x.u16 = D0.u16
	objA1.position.x.u16 = D0.u16

	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	if (!(objA0.subtype2c == 0xa4 && u16[A0 + 0x30] == 0x40) || original_mode)	// subtype of sealing bridge floor, and offset 30 is the distance away from extended position (retracted is usually 0x40)
		fn01dc56()							// SolidObjectFull routine, which is always called in the original object code

	D0.u16 = u16[A0 + 0x40]
	DrawOrUnloadObjectByD0()
}







// Changes the water level and upper screen boundary in HCZ2 if Knuckles approaches Sonic's boss or in time attack modes
// Also adds water tint and fixes a potential camera issue. A commented-out function scrolls the camera to reveal the character path split.
// Function taken from level\level_water.lemon
//# address-hook(0x006e9c) end(0x006eb8)
function void UpdateWaterSurfaceLevel.HCZ2()
{
	if (timer.alldata == 0x00000418 && move_area.right == 0x00a8)	// at end of whirlpool level transition and right camera boundary screenmover failed to load (should be 0x00a9 now as move starts)
		move_area.right = 0x6000									// force the target camera boundary

// These lines create a natural camera scroll to reveal the paths at the character path split
// and removes the new camera position when outside of the relevant area.
// The effect is fully functional, but I'm not keen on the look; it feels unnatural to run so low on the screen
// without being at the level's bottom or approaching a boss/cutscene.
/*
	if (u16[0xffffb010] >= 0x0c6c && u16[0xffffb010] <= 0x10e0)
	{
		if (move_area.bottom.target != 0x05c0)
			move_area.bottom.current = (camera.position.y.u16 + 4) & 0xfffc	// set to next lowest multiple of 4 in case of camera scroll glitches
		move_area.bottom.target = 0x05c0
	}
	else if (u16[0xffffb010] < 0x1200)	// arbitrary value above 0x10e0 that a player will necessarily pass through, to reset the camera
	{
		move_area.bottom.target = 0x1000
		move_area.bottom.current = 0x1000
	}
*/
	if (u8[0xfffffaa2] != 0)
	{
		return
	}

	if (!isMainCharacter(CHARACTER_KNUCKLES))
	{
		A1 = 0x006eba
		fn006f2c()
	}
	else
	{
		if (camera.position.x.u16 > 0x3e00 && camera.position.x.u16 <= 0x4500)
		{
			if (u16[0xffffb014] > 0x0400)
			{
				water.height.target = 0x07e0
				if (level.boss_encounter == 0)
				{
					u16[0xffffee18] = 0x0480	// set camera upper y boundary
				}
			}
			else
			{
				A1 = 0x006ec2
				fn006f2c()
			}
		}
		else
		{
			A1 = 0x006ec2
			fn006f2c()
		}
	}

	if ((time_attack == 1 || time_attack == 2) && (water.height.target == 0x07e0 || water.height.target == 0x0360))	// in time attack modes, move the water down below the floor level
	{
		water.height.target += 0x2c
		if (water.height.target == 0x038c)
		{
			water.height.current = water.height.target
			water.height.next = water.height.target
		}
	}
}


// Shift the background in HCZ2 to accomodate raising the level's upper boundary.
// Function taken from level\02_hcz\level_hcz.lemon
// //# address-hook(0x051070) end(0x0510d8)
/*
function void UpdateBackground.HCZ2()
{
	if (original_mode)
	{
		base.UpdateBackground.HCZ2()
		return
	}

	camera.foreground.y.u16 += 0x80
	base.UpdateBackground.HCZ2()
	camera.foreground.y.u16 -= 0x80
}
*/



// Sets which HCZ2 boss to use
//# address-hook(0x06aeb6) end(0x06aef8)
function void fn06aeb6()
{
	#if STANDALONE
		if (time_attack == 1 || time_attack == 2)
		{
			UnloadObject()
			return
		}
	#endif

	// New code that uses character vertical position instead of character for boss selection
	// This code does NOT spawn the Egg Prison; that is the following function.
	//	A1 = (!isMainCharacter(CHARACTER_KNUCKLES)) ? 0x06ae96 : 0x06aea6

	if (u16[0xffffb014] > 0x0480)
	{
		A1 = 0x06ae96
	}
	else
	{
		A1 = 0x06aea6
	}


	if (InitBoss(0x06aecc))
		return

	objA0.value26 = 0x19
	StartBossFight()

	#if STANDALONE
		// Expand the boss area to the right if needed
		level.bossarea.right = max(level.bossarea.right, level.bossarea.left + getScreenExtend() * 2)
	#endif

	objA0.update_address = 0x06aefe
	objA0.countdown_callback = 0x06af04

	requestLoadingPatterns(0x6c)

	u16[0xfffffc1e] = 0

	loadPaletteLine1(0x06bf0a)
}






// In Original Mode, the blast from a bomb should lift up a hurt character.
// Function taken from bosses\boss_hcz2.lemon
function void fn06bb5c()
{
	if (u8[A2 + 0x2e] != 0)
		return

	// Ignore if character is not in normal state, but e.g. in got hurt state
	if (u8[A2 + 0x05] != 0x02 && !original_mode)
		return

	// Check if character is inside the bomb's water fountain
	u16 px = u16[A2 + 0x10]
	u16 py = u16[A2 + 0x14]
	D0.u16 = objA0.position.x.u16 + u16[A1]
	if (px >= D0.u16 && px < D0.u16 + u16[A1+2])
	{
		D0.u16 = objA0.position.y.u16 + u16[A1+4]
		if (py >= D0.u16 && py < D0.u16 + u16[A1+6])
		{
			s16[A2 + 0x1a] = -0x800
		}
	}
}






// Sets where the Egg Prison spawns after the HCZ2 boss
//# address-hook(0x06b0e8) end(0x06b152)
function void fn06b0e8()
{
	if (original_mode)
	{
		base.fn06b0e8()
		return
	}

	objA0.update_address = 0x06b154
	objA0.render_flags &= ~render_flag.VISIBLE
	level.wait_for_results = 0xff
	level.boss_encounter = 0
	screenmover_target.right = level.bossarea.left + 0x0180 + getScreenExtend() // * 2	// We always want the following subtraction with our Egg Prison placement, so just don't add it in.

	#if STANDALONE
		if u16[0xffffb014] < 0x0480 // previously (isMainCharacter(CHARACTER_KNUCKLES))
		{
	//		screenmover_target.right -= getScreenExtend()

			// Correct some chunks to the right that are visible in widescreen
			u8[0xffff81a8] = 0
			u8[0xffff8238] = 0
			u8[0xffff82c8] = 0
			u8[0xffff8358] = 0
			u8[0xffff83e8] = 0
			u8[0xffff8478] = 0
			u8[0xffff8508] = 0x1f
		}
	#endif

	// "spawnSimpleChildObjects(0x084b00)" replaced by:
	spawnSimpleChildObjects(0x084a48, 1)		// Screen mover for the right border

	if (allocDynamicObjectStd())
	{
		// Spawn capsule
		objA1.update_address = 0x086540
		if (u16[0xffffb014] > 0x0480)	// Sonic's boss area
		{
			objA1.position.x.u16 = 0x4220	// 0x4250 in original game, adjusted for widescreen
			objA1.position.y.u16 = 0x07e0
		}
		else
		{
			objA1.position.x.u16 = 0x4760
			objA1.position.y.u16 = 0x0360
		}
	}
}





function void MGZ1_CustomSprites()
{
	#if STANDALONE
	if (rain_intensity && !isMainCharacter(CHARACTER_KNUCKLES) && palette_set >= 2 && !original_mode)	// only if this isn't set to None in the mod settings, not Knuckles, and with a proper palette
	{
		D0.u8 = (level.framecounter.low & 0x3F) * 4	// rain is 64 by 64 (0x3F by 0x3F), position is moved by 4 pixels down and left each frame
		{
		if (rain_intensity == 1)
			Renderer.drawCustomSprite("rain0_light", getScreenExtend() - 80 - D0.u8, D0.u8, 0x00, 0, 0x1100)
		else if (rain_intensity == 2)
			Renderer.drawCustomSprite("rain0", getScreenExtend() - 80 - D0.u8, D0.u8, 0x00, 0, 0x1100)
		else
			Renderer.drawCustomSprite("rain0_heavy", getScreenExtend() - 80 - D0.u8, D0.u8, 0x00, 0, 0x1100)
		}																								// Different values for the first nybble make the rain render above low plane foreground and above sprites,
	}																									// as stated in the Oxygen handbook.
	#endif
}

function void MGZ2_CustomSprites()
{
	#if STANDALONE
	if (rain_intensity && isMainCharacter(CHARACTER_KNUCKLES) && (level.boss_encounter || (u16[0xffffb010] > 0x37A0 && u16[0xffffb014] > 0x0600 && u16[0xffffb014] < 0x0820)) && palette_set >= 2 && !original_mode)
		// Only if this isn't set to None in the mod settings and Knuckles is near or actually at his boss.
		// Perhaps this could be done more easily by checking what level resize routine is in place, since the camera adjusts near here?
	{
		D0.u8 = (level.framecounter.low & 0x3F) * 4	// rain is 64 by 64 (0x3F by 0x3F), position is moved by 4 pixels down and left each frame
		{
		if (rain_intensity == 1)
			Renderer.drawCustomSprite("rain0_light", getScreenExtend() - 80 - D0.u8, D0.u8, 0x00, 0, 0x1100)
		else if (rain_intensity == 2)
			Renderer.drawCustomSprite("rain0", getScreenExtend() - 80 - D0.u8, D0.u8, 0x00, 0, 0x1100)
		else
			Renderer.drawCustomSprite("rain0_heavy", getScreenExtend() - 80 - D0.u8, D0.u8, 0x00, 0, 0x1100)
		}																								// Different values for the first nybble make the rain render above low plane foreground and above sprites,
	}																									// as stated in the Oxygen handbook.
	#endif
}



// Change priority of MGZ trigger platforms to appear in front of springs.
// Function taken from objects\03_mgz\mgz_triggeredplatform.lemon.
//# address-hook(0x034574) end(0x0345fa)
function void fn034574()
{
	D1.u16 = (objA0.subtype2c & 0xf0) >> 2
	A1 = 0x034568 + D1.s16
	objA0.box_size.x = u8[(A1+=1)-1]
	objA0.box_size.y = u8[(A1+=1)-1]
	objA0.animation.sprite = u8[(A1+=1)-1]
	u16[A0 + 0x30] = u8[(A1+=1)-1]
	D1.u16 >>= 2
	u16[A0 + 0x34] = D1.u16
	objA0.mapping_offset = 0x2339b2
	objA0.sprite_attributes = 0x4001
	objA0.render_flags |= 0x04
	objA0.sprite_priority = 0x0180 // previously 0x0280
	u16[A0 + 0x36] = objA0.position.x.u16

	if (D1.u16 != 0)
	{
		D0.u16 = objA0.subtype2c & 0x0f
		A3 = 0xfffff7e0
		if (u8[A3 + D0.s16] != 0)
		{
			D0.u16 = u16[A0 + 0x34]
			if (objA0.flags2a & 0x01)
			{
				D0.s16 = -D0.s16
			}

			while (true)
			{
				objA0.position.y.u16 += D0.u16

				--u16[A0 + 0x30]
				if (u16[A0 + 0x30] == 0)
					break
			}
			u8[A0 + 0x32] = 0xff
		}

		objA0.update_address = 0x03466e
		fn03466e()
	}
	else
	{
		objA0.update_address = 0x034600
		fn034600()
	}
}




// Implement future A.I.R. feature by iCloudius to allow drop dash to trigger MGZ spin wheels (matching Origins).
// Also add Origins activation sound effect 0x5a.
// Functions taken from objects\03_mgz\mgz_spinwheeltrigger.lemon
//# address-hook(0x025d9c) end(0x025ea0)
function void fn025d9c()
{
	D1.u16 = 0x1b
	D2.u16 = 0x10
	D4.u16 = objA0.position.x.u16
	A2 = 0x025f0e
	fn01dd0e()

	D6 = (D6 << 16) + (D6 >> 16)
	D6.u16 &= 0x33
	if (D6.u16 != 0)
	{
		D0.u8 = D6.u8 & 0x11
		if (D0.u8 != 0)
		{
			A1 = 0xffffb000
		#if STANDALONE
			// Also allow for drop-dashing on the spin wheel, #contributed by iCloudius
			if (objA1.state == char.state.SPINDASH || (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state.former == char.state.SONIC_DROPDASH))
		#else
			if (objA1.state == char.state.SPINDASH)
		#endif
			{
				if (!u16[A0 + 0x30] && !original_mode)
					playSound(0x5a)		// add Origins whirring sound if the wheel is not already spinning
				u16[A0 + 0x30] = 0x3c
				u8[A0 + 0x32] = 1
				D0.u8 = (u8[A1 + 0x2a] + objA0.flags2a) & 0x01
				if (D0.u8 == 0)
				{
					u8[A0 + 0x32] = 0xff
				}
				if (!original_mode && objA1.state.former == char.state.SONIC_DROPDASH)
					objA1.state = char.state.SONIC_DROPDASH
			}
		}

		D6.u8 &= 0x22
		if (D6.u8 != 0)
		{
			A1 = 0xffffb04a
		#if STANDALONE
			if (objA1.state == char.state.SPINDASH || (u8[A1 + 0x38] == CHARACTER_SONIC && objA1.state.former == char.state.SONIC_DROPDASH))
		#else
			if (objA1.state == char.state.SPINDASH)
		#endif
			{
				if (!u16[A0 + 0x30] && !original_mode)
					playSound(0x5a)		// add Origins whirring sound if the wheel is not already spinning
				u16[A0 + 0x30] = 0x3c
				u8[A0 + 0x32] = 1
				D0.u8 = (u8[A1 + 0x2a] + objA0.flags2a) & 0x01
				if (D0.u8 == 0)
				{
					u8[A0 + 0x32] = 0xff
				}
				if (!original_mode && objA1.state.former == char.state.SONIC_DROPDASH)
					objA1.state = char.state.SONIC_DROPDASH
			}
		}
	}

	if (u16[A0 + 0x30] != 0)
	{
		D0.u16 = objA0.subtype2c & 0x0f
		A3 = 0xfffff7e0 + D0.s16

		--u16[A0 + 0x30]
		if (u16[A0 + 0x30] == 0)
		{
			u8[A3] = 0
			objA0.animation.sprite = 0
		}
		else
		{
			u8[A3] = 1
			if (objA0.flags2a & object.flag.P1_ON_OBJECT)
			{
				A1 = 0xffffb000
				fn025ea6()
			}
			if (objA0.flags2a & object.flag.P2_ON_OBJECT)
			{
				A1 = 0xffffb04a
				fn025ea6()
			}

			--objA0.animation.timer
			if (s8(objA0.animation.timer) < 0)
			{
				objA0.animation.timer = 1
				objA0.compound.sprite1.animation.sprite = (objA0.compound.sprite1.animation.sprite + u8[A0 + 0x32]) & 0x03
			}
			objA0.animation.sprite = (objA0.animation.sprite != 0) ? 0 : 4
		}
	}

	DrawOrUnloadObject()
}

//# address-hook(0x025ea6) end(0x025f0c)
function void fn025ea6()
{
	D1.u16 = objA0.position.x.u16 - 0x10
	if (objA0.flags2a & 0x01)
	{
		D1.u16 += 0x20
	}
	D2.u16 = objA0.position.y.u16 + 0x10
	D1.u16 -= objA1.position.x.u16
	D2.u16 -= objA1.position.y.u16
	LookupAngleByVector()
	LookupSinCos()
	D1.s32 = (s32(D1.s16) * -0x0700) >> 8
	objA1.velocity.x = D1.u16
	D0.s32 = (s32(D0.s16) * -0x0700) >> 8
	objA1.velocity.y = D0.u16
	u8[A1 + 0x2a] |= char.flag.IN_AIR
	objA1.flags2a &= ~(char.flag.CONTROL_LOCK | char.flag.ON_OBJECT)
#if STANDALONE
	if (objA1.state == char.state.SONIC_DROPDASH)
	{
		u8[A1 + 0x40] = 1	// Re-enable double jump state
		u8[A1 + 0x2f] = 1	// Re-enable jump flag
	}
	else
#endif
	{
		u8[A1 + 0x40] = 0
	}
	u8[A1 + 0x3d] = 0
	playSound(0x7b)
}





// Load MGZ chunks from rawdata instead of ROM.
// Function taken from level\03mgcz\level_mgz.lemon
//# address-hook(0x051160) end(0x0511c4)
function void fn051160()
{
	if (u16[0xffffeec6] != 0)
	{
		u16[0xffffeec6] = 0

		push(A3)
		push(A2)
		push(A0)
		push(D7)

	//	Kosinski.addToDecompressionQueue(0x3cb1c4, 0xffff6b00)	// Act 2 chunks
		System.loadExternalRawData(stringformat("mgz2_chunks_s", global.act + 1), KosinskiRawdataBuffer)		// copy Secondary chunks to shared memory
		Kosinski.addToDecompressionQueue(KosinskiRawdataBuffer, 0xffff6b00)									// decompress them to their proper RAM (see above)

		Kosinski.addToDecompressionQueue(0x3c9cd2, 0xffff9c60)

		Kosinski.addToDMAQueue(0x3ca132, 0x4a40)

		requestLoadingPatterns(0x14)

		D7 = pop()
		A0 = pop()
		A2 = pop()
		A3 = pop()

		level.scrolling_routine += 4
	}

	UpdateBackground.MGZ1()

	A4 = 0x23c9f8
	A5 = 0xffffa800
	fn04f0ce()
	UpdateScreenShake()
}





// Add a hardcoded check for the final MGZ2 trigger platform on the path to the flying boss to remove itself after opening the path.
// While it hides itself in a wall pillar, it's perfectly flush with the edge, causing issues if Knux tries to climb it.
// Function taken from objects\03_mgz\mgz_triggeredplatform.lemon.
//# address-hook(0x03466e) end(0x0346dc)
function void fn03466e()
{
	bool skipCheck = false
	D0.u16 = objA0.subtype2c & 0x0f
	A3 = 0xfffff7e0
	if (u8[A3 + D0.s16] != 0)
	{
		if (u8[A0 + 0x32] & 0x80)
		{
			skipCheck = true
		}
		else
		{
			u8[A0 + 0x32] = 1
		}
	}

	if (!skipCheck && s8[A0 + 0x32] > 0)
	{
		D0.u16 = u16[A0 + 0x34]
		if (objA0.flags2a & 0x01)
		{
			D0.s16 = -D0.s16
		}
		objA0.position.y.u16 += D0.u16

		--u16[A0 + 0x30]
		if (u16[A0 + 0x30] == 0)
		{
			u8[A0 + 0x32] = 0xff
			camera.screenshake.state = 0
		}
		else
		{
			camera.screenshake.state = 0xffff
		}
	}

	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	fn01dc56()

	if (global.zone_act == 0x0201 && objA0.position.x.u16 == 0x3920 && objA0.position.y.u16 == 0x0714)	// end location of final MGZ2 trigger platform for flying boss path
		UnloadObject()

	DrawOrUnloadObject()
}




// Add hardcoded checks to manipulate a star post in MGZ2 when traversing the "loop" section.
// Function taken from objects\basics\checkpoint.lemon
//# address-hook(0x02cfa8) end(0x02cfb2)
function void Checkpoint.BaseUpdate()
{
	if (global.zone_act == 0x0201 && objA0.subtype2c == 5 && checkpoint.number <= 5 && level.trigger08 && !original_mode)
	{
		objA0.subtype2c = 6		// if the loop has been done once and we've returned to the star post, give it a special ID to retrigger it
		A2 = 0xffff0000 + u16[A0 + 0x48]	// find respawn table entry for star post
		u8[A2] &= 0xfe			// remove the last bit of the first of the two respawn table flags to align with a fresh star post
		u32[A0 + 0x22] = 0x00010300		// set values used in animation (flashing) to an initialized red appearance
	}

	// Can lead to:
	//  - 0x02cfc0	-> objA0.base_state = 0x00	-> Initialization
	//  - 0x02d012	-> objA0.base_state = 0x02	-> Inactive
	//  - 0x02d0f8	-> objA0.base_state = 0x04	-> Active (if called from here; the Inactive function also calls this)
	//  - 0x02d10a	-> objA0.base_state = 0x06	-> Head spinning (used only by this child object)
	//  - 0x02d47e	-> objA0.base_state = 0x08	-> Bonus stage stars animating (used only by these child objects)
	call tableLookupAddress(0x02cfb6, objA0.base_state)
}

// Function taken from scripts\maingame\maingame.lemon
//# address-hook(0x02d234) end(0x02d336)
function void SetupCharacterAtLastCheckpoint()
{
	base.SetupCharacterAtLastCheckpoint()

	if (global.zone_act == 0x0201 && checkpoint.number == 6 && level.trigger08 != 1 && !original_mode)
		level.trigger08 = 1		// if we are restarting from the loop's star post after that return, automatically throw the trigger
	else if (unlock_act == 2 && layout.part == 1 && camera.position.x.u16 >= 0x1de0 + 0x0700 - getScreenExtend())
	{
		water.height.current = 0x0510
		water.height.next = 0x0510
		water.height.target = 0x0510
	}
}








// In MGZ2, force a certain arrow signpost to face the opposite direction after a Relief is shattered.
// In EHZ, add a check for bridge support posts.
// Function taken from objects\level\decorativesprite.lemon
//# address-hook(0x02b928) end(0x02b962)
function void fn02b928()
{
	if (global.zone_act == 0x0201 && objA0.position.x.u16 == 0x2804 && objA0.position.y.u16 == 0x07f4 && level.trigger0a && !original_mode)
		objA0.subtype2c = 0x0c	// change from 0x0b (left arrow) to 0x0c (right arrow)

	if (!unlock_act)
	{
		base.fn02b928()
		return
	}

	objA0.mapping_offset = 0x88002c
	objA0.sprite_attributes = (sprite_attribute.PALETTE.LINE2 | 0x03b2)	// 0x03b6 in Sonic 2, but we ignore the animation sprite shift
	objA0.render_flags |= render_flag.WORLD
//	objA0.animation.sprite = objA0.subtype2c
	objA0.sprite_priority = 0x80
	objA0.box_size.x = 0x04
	objA0.box_size.y = 0x04

	objA0.update_address = 0x02b962
	fn02b962()
}







// In Original Mode, require the spinning top to break certain MGZ pillars
// Function taken from objects\level\wall.lemon
//# address-hook(0x021568) end(0x021690)
function void fn021568()
{
	u16[A0 + 0x30] = u16[0xffffb000 + 0x18]
	objA0.value32 = u16[0xffffb04a + 0x18]

	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	fn01dc56()

	if (u8[A0 + 0x2c] & 0x80)
	{
		if (level.trigger00 == 0)
		{
			DrawOrUnloadObject()
		}
		else
		{
			UnloadObject()
		}
		return
	}

	D6 = (D6 << 16) + (D6 >> 16)
	D6.u16 &= 0x03
	if (D6.u16 == 0)
	{
		DrawOrUnloadObject()
		return
	}

	A1 = 0xffffb000
	D1.u16 = u16[A0 + 0x30]
	if (D6.u16 & 0x01)
	{
		bool canBreakWall = false
		if (super.active || u8[A1 + 0x38] == CHARACTER_KNUCKLES)
		{
			// Super/Hyper forms can break walls, and Knuckles can
			canBreakWall = true
		}
		else
		{
			// Does this wall allow for rolling into the wall? Otherwise the fire shield will do
			if ((objA0.flags2a & object.flag.P1_PUSHING) || (u8[A1 + 0x2b] & char.bonus.SHIELD_FIRE))
			{
				canBreakWall = (objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x0480)
			}
		}

		if (canBreakWall)
		{
			objA0.flags2a &= ~object.flag.P1_PUSHING
			fn02165a()

			A1 = 0xffffb04a
			if ((objA0.flags2a & object.flag.P2_PUSHING) && objA1.state == char.state.ROLLING)
			{
				objA0.flags2a &= ~object.flag.P2_PUSHING
				objA1.velocity.x = objA0.value32
				u16[A1 + 0x1c] = objA1.velocity.x
				objA1.flags2a &= ~char.flag.PUSHING
			}

			DrawOrUnloadObject()
			return
		}
	}

	A1 = 0xffffb04a
	D1.u16 = objA0.value32
	if ((objA0.flags2a & object.flag.P2_PUSHING) && objA1.state == char.state.ROLLING && abs(D1.s16) >= 0x0480)
	{
		objA0.flags2a &= ~object.flag.P2_PUSHING
		fn02165a()

	#if STANDALONE
		if (Game.getSetting(SETTING_FIX_GLITCHES) >= 2)
		{
			// Prevent slope glitch here for player 1
			if ((u8[0xffffb000 + 0x2a] & char.flag.ON_OBJECT) && u16[0xffffb000 + 0x42] == A0.u16)
			{
				u8[0xffffb000 + 0x2a] &= ~char.flag.ON_OBJECT
				u8[0xffffb000 + 0x2a] |= char.flag.IN_AIR
			}
		}
	#endif
	}
#if STANDALONE
	else if (global.zone == 0x02 && !original_mode)
	{
		// In MGZ, make all normal breakable walls also breakable by spinning top
		D6 = (D6 << 16) + (D6 >> 16)
		fn021758()
	}
#endif
	else
	{
		DrawOrUnloadObject()
	}
}





// Adds a dark shade to MGZ pillars that only Knuckles can break.
// Function taken from objects\level\wall.lemon
//# address-hook(0x021818) end(0x021936)
function void fn021818()
{	
	base.fn021818()

	if (global.zone == 0x02 && objA0.subtype2c == 0x10 && !original_mode)
		Renderer.drawCustomSprite("mgz_pillar_knuxshading", objA0.position.x.u16, objA0.position.y.u16, 0x00, 0x20, 0x9eff, 0, 96)	// the 0x20 flag means to use world space coordinates
}




// Alter functions regarding MGZ top collision to make sure an old AIR-specific glitch is not possible in Original Mode.
// Functions taken from maingame\collision.lemon
// These functions do not have address hooks.
//# alias(fn00fd9a_shared) deprecated
function void Character.CheckLeftWallCollision.shared()
{
	D3.u16 ^= 0x0f
	checkStaticCollisionHorizontal(D3.u16, D2.u16, 0xfffff768, -0x10, 0x400)

	D2.u8 = 0x40
	if (Game.getSetting(SETTING_FIX_GLITCHES) >= 2 && !original_mode)
		D3.u8 = u8[0xfffff768]		// Due to a mistake in code porting, this line was missing for quite a long time in S3AIR, causing a glitch that is now actively used in speedrunning
	if (D3 & 0x01)
		D3.u8 = 0x40
}

function void Character.CheckRightWallCollision.shared()
{
	checkStaticCollisionHorizontal(D3.u16, D2.u16, 0xfffff768, 0x10, 0)

	D2.u8 = 0xc0
	if (Game.getSetting(SETTING_FIX_GLITCHES) >= 2 && !original_mode)
		D3.u8 = u8[0xfffff768]		// Due to a mistake in code porting, this line was missing for quite a long time in S3AIR, causing a glitch that is now actively used in speedrunning
	if (D3 & 0x01)
		D3.u8 = 0xc0
}





// Create an invisible object to prevent a softlock from rebounding after destroying the last Relief for Knuckles in MGZ2.
// This code is from scripts\objects\03_mgz\mgz_reliefhead.lemon.
//# address-hook(0x03438e) end(0x034512)
function void fn03438e()
{
	if (u8[A0 + 0x34] == 0)
	{
		D0.u16 = u16[0xffffb010] - objA0.position.x.u16 + u16[A0 + 0x30]
		if (D0.u16 < 0xc0)
		{
			D0.u16 = u16[0xffffb014] - objA0.position.y.u16 + 0x80
			if (D0.u16 < 0xc0)
			{
				if (objA0.state == 0)
				{
					objA0.state.both = 0x0100
				}
			}
		}

		if (u8[A0 + 0x28] == 0)
		{
			if (objA0.value32 != 0)
			{
				--objA0.value32
				if (objA0.value32 == 0)
				{
					u8[A0 + 0x28] = 0x17
				}
			}
			else
			{
				objA0.value32 = 0x3c
				if (allocDynamicObjectAfterA0())
				{
					objA1.update_address = 0x034536
					if (u8[A0 + 0x29] == 0)	// A0 + 0x29 contains the Relief's hit count (initially 3), so it's destroyed here.
					{						// We don't want to alter A1 here, though, so we add code to spawn the invisible object later.
						objA1.update_address = 0x01e5e0
						u16[A1 + 0x0a] = 0x8000
						u8[A1 + 0x05] = 2
						u8[A0 + 0x34] = 1
						objA0.animation.sprite = 0

						A3 = 0xfffff7e0
						D0.u16 = objA0.subtype2c & 0x0f
						u8[A3 + D0.s16] = 1
					}

					objA1.position.x.u16 = objA0.position.x.u16
					objA1.position.y.u16 = objA0.position.y.u16
					u8[A1 + 0x04] = objA0.render_flags
					u8[A1 + 0x04] &= 0xbf
					u8[A1 + 0x2a] = objA0.flags2a
					u32[A1 + 0x0c] = objA0.mapping_offset
					u16[A1 + 0x0a] = objA0.sprite_attributes
					u16[A1 + 0x08] = 0x0200
					u8[A1 + 0x07] = 0x08
					u8[A1 + 0x06] = 0x08
					u8[A1 + 0x20] = 0x02
				}
				
				// Create an invisible object after destroying this particular Relief: the final one for Knux in Act 2
				if (global.zone_act == 0x0201 && objA0.subtype2c == 0x0F && u8[A0 + 0x29] == 0)
				{
					objA1.update_address = 0x01ec18
					objA1.position.x.u16 = 0x38D0
					objA1.position.y.u16 = 0x0868
					objA1.subtype2c = 0x14
				}

				playSound(0x6e)
			}
		}

		Object.animationUpdate(0x034548)
		if (objA0.base_state != 0)
		{
			objA0.base_state = 0
			if (allocDynamicObjectAfterA0())
			{
				objA1.update_address = 0x034518
				objA1.position.x.u16 = objA0.position.x.u16 + 0x10
				objA1.position.y.u16 = objA0.position.y.u16 + 0x20
				u8[A1 + 0x04] = objA0.render_flags & 0xbf
				u32[A1 + 0x0c] = objA0.mapping_offset
				u16[A1 + 0x0a] = objA0.sprite_attributes & 0x7fff
				u16[A1 + 0x08] = 0x0300
				u8[A1 + 0x07] = 0x10
				u8[A1 + 0x06] = 0x04
				u8[A1 + 0x28] = 0x9b
				objA1.velocity.x = -0x400
				if (objA0.flags2a & 0x01)
				{
					objA1.velocity.x = -objA1.velocity.x
					objA1.position.x.u16 -= 0x20
				}

				playSound(0x67)
			}
		}
	}

	fn01b662()
}







// Slightly adjust the positions at which the MGZ2 quake will speed up.
// Function taken from level\03_mgz\level_mgz.lemon
//# address-hook(0x051b1c) end(0x051b92)
function void fn051b1c()
{
	D0.u16 = u16[0xffffeed4]
	if (D0.u16 >= objA0.countdown_value)
	{
		playSound(0x5f)
		camera.screenshake.state = 0x0e
		u16[0xffffeeb4] = 0
		knuckles.preventclimbing &= ~0x80
		UnloadObject()
		return
	}

	D2.u16 = u16[0xffffb010]
	D3.u16 = u16[0xffffb014]
	if (objA0.value39 != 0)
	{
		D1.u16 = D0.u16
		++D1.u16
	}
	else
	{
		if (objA0.flags38 == 0)
		{
			if ((!original_mode && D3.u16 < 0x02b0 && D2.u16 < 0x3cbc) || (original_mode && D3.u16 < 0x0200 && D2.u16 < 0x3cb0)) // formerly 0x0200 and 0x3cb0
			{
				objA0.value39 = 0xff
			}
		}
		else
		{
			if ((!original_mode && D2.u16 >= 0x3d46) || (original_mode && D2.u16 >= 0x3d50))	// formerly 0x3d50
			{
				objA0.value39 = 0xff
			}
		}

		D1 = objA0.countdown_callback + u32[A0 + 0x30]
		objA0.countdown_callback = D1
		D1 = (D1 << 16) + (D1 >> 16)
	}

	u16[0xffffeed4] = D1.u16
	D1.u16 -= D0.u16
	u16[0xffffb014] -= D1.u16
	u16[0xffffb05e] -= D1.u16
}






// Adjust the camera y lock at the MGZ2 flying boss to accomodate ultrawide.
// Functions taken from level\03_mgz\level_mgz.lemon
//# address-hook(0x01c930) end(0x01c96c)
function void fn01c930()
{
	if (original_mode)
	{
		base.fn01c930()
		return
	}

	if (camera.position.y.u16 >= 0x0600 && camera.position.y.u16 < 0x0700)
	{
		if (u16[0xffffb010] >= 0x3aa0)	// formerly if (camera.position.x.u16 >= 0x3a00)
		{
			D0.u16 = 0x06a0
			level.vertical_wrap = D0.u16
			move_area.top.target = D0.u16
			move_area.bottom.current = D0.u16
			move_area.bottom.target = D0.u16
			D0.u16 = 0x3c80 + ((getScreenExtend() + 0x0f) & 0xfff0)
			move_area.right = D0.u16
			move_area.right.target = D0.u16
			camera.update_routine += 2
		}
	}
}

//# address-hook(0x01c96e) end(0x01c9c6)
function void fn01c96e()
{
	if (original_mode)
	{
		base.fn01c96e()
		return
	}

	if (u16[0xffffb010] >= 0x3aa0)	// formerly if (camera.position.x.u16 >= 0x3a00)
	{
		D0.u16 = 0x3c80 - (getScreenExtend() & 0xfff0)
		if (D0.u16 > camera.position.x.u16)
			return

		move_area.left = D0.u16
		move_area.left.target = D0.u16

		if (allocDynamicObjectStd())
		{
			// Trigger boss
			objA1.update_address = 0x06c31a
			objA1.position.x.u16 = 0x3d20
			objA1.position.y.u16 = 0x0668
		}

		camera.update_routine += 2
	}
	else
	{
		D0 = 0x1000
		u32[0xffffee18] = D0	// level.vertical_wrap = 0, move_area.bottom.current = 0x1000
		u32[0xffffee10] = D0	// move_area.top.target	= 0, move_area.bottom.target = 0x1000

		D0.u16 = 0x6000
		move_area.right = D0.u16
		move_area.right.target = D0.u16

		camera.update_routine -= 2
	}
}





// Allow the MGZ2 flying boss to descend for a longer period of time (ending up lower) when Knuckles fights him.
// Function taken from bosses\boss_mgz2.lemon
//# address-hook(0x06c3ec) end(0x06c414)
function void fn06c3ec()
{
	objA0.base_state = 0x04
	playMusic(MUSIC_MAINBOSS)
	level.default_music.u8 = MUSIC_MAINBOSS

	objA0.velocity.y = 0x80
	objA0.countdown_value = (isMainCharacter(CHARACTER_KNUCKLES) && !original_mode) ? 0xff : 0xbf
	objA0.countdown_callback = 0x06c422
}






// In Original Mode, revert a minor change to boss speed that AIR makes.
// Function taken from bosses\boss_mgz2.lemon
//# address-hook(0x06c658) end(0x06c686)
function void fn06c658()
{
	objA0.base_state = 0x20
	objA0.countdown_value = 0xff
	objA0.countdown_callback = 0x06c614
	objA0.flags38 |= (0x04 | 0x08)

#if STANDALONE
	if (objA0.velocity.y == 0)
	{
		// Give him more time to cross the wider screen, if moving from left to right
		objA0.countdown_value += getScreenExtend()
	}
	else if (!original_mode)	// used to just be "else"
	{
		// And a little bit less otherwise
		objA0.countdown_value -= 0x10
	}
#endif
}






// In Original Mode, use miniboss music for the non-flying MGZ2 boss and undo an AIR widescreen adjustment.
// Functions taken from bosses\boss_mgz2_knuckles.lemon
//# address-hook(0x06c698) end(0x06c6ee)
function void fn06c698()
{
	A1 = 0x06c688
	if (InitBoss(0x06c6a2))
		return

	if (!original_mode)
	{
		// Use main boss music
		objA0.value26 = MUSIC_MAINBOSS
	}
	else
		objA0.value26 = MUSIC_MINIBOSS_2

	StartBossFight()

	objA0.update_address = 0x06c6f4
	objA0.countdown_callback = 0x06c6fa

	Kosinski.addToDMAQueue(0x36b340, 0x67e0)

	Kosinski.addToDMAQueue(0x36d572, 0x8bc0)

	requestLoadingPatterns(0x6d)
	loadPaletteLine1(0x06d97c)

	level.bossarea.left -= getScreenExtend()
	level.bossarea.right += getScreenExtend()

	// Alter some chunks to the right of the level's edge (i.e., the left edge due to wrapping)
	// to allow the correct zone transition in ultrawide resolutions.
	u8[0xffff8108] = 0x50
	u8[0xffff8188] = 0x4f
	u8[0xffff8208] = 0xbc
}

//# address-hook(0x06d45e) end(0x06d4aa)
function void fn06d45e()
{
	u16 type = D1.u16
	u16 px
	if (!original_mode)
		px = camera.position.x.u16 + getScreenWidth() / 2 + 8 + D0.s16
	else
		px = camera.position.x.u16 + 168 + D0.s16
	u16 py = D3.u16
	u16 offset = u16[0x06d4ac + type * 2]
	u16[A0 + 0x26] = offset

	objA0.position.x.u16 = px
	objA0.position.y.u16 = py
	u16[A2+0] = type * 2
	u16[A2+2] = offset
	u16[A2+4] = px
	u16[A2+6] = py
	u32[A0 + 0x30] = u32[0x06d4bc + type * 4]
	objA0.animation.frame = 0
	objA0.animation.timer = 0

	u32[A0 + 0x18] = u32[0x06d34e + offset * 2]
	if (objA0.render_flags & render_flag.FLIP_X)
	{
		objA0.velocity.x = -objA0.velocity.x
	}
}





// Choose appropriate music in various cases in Original Mode.
// Finishing the non-flying MGZ2 boss as Super Sonic is one example of where adjustments are needed.
// Function taken from maingame\character\character.lemon
function void chooseFittingMusic()
{
#if STANDALONE
	// Reworked version for S3AIR

	// If drowning music is playing, don't start something else
	if (u8[0xffffb000 + 0x2c] <= 12)
		return

	// Boss music needed?
	if (level.boss_encounter != 0)
	{
		if (global.zone_act == 0x0a00)
		{
			// Sky Sanctuary Zone bosses
			playMusic(level.default_music.u8)
		}
		else if (level.boss_encounter == 1)
		{
			// Main boss is always in Act 2, and in LRZ Boss act, in AIR.
			bool isMainBoss = (global.act.apparent == 1 || global.zone_act == 0x1600)
			// Original Mode checks.
			if (original_mode && global.zone_act == 0x0201 && camera.position.y.u16 < 0x0100)	// MGZ2 non-flying boss
				isMainBoss = 0
			else if (original_mode && global.zone_act == 0x0401 && camera.position.x.u16 < 0x2d00)	// laser miniboss
				isMainBoss = 0
			playMusic(isMainBoss ? MUSIC_MAINBOSS : MUSIC_MINIBOSS_2)
		}
		else if (level.boss_encounter == 2)
		{
			// LBZ 2 Big Arms fight
			playMusic(MUSIC_BIGARMS)
		}
		else if (level.boss_encounter == 3)
		{
			// HPZ fight against Knuckles
			playMusic(BossHPZKnuckles.chooseMusicTrack())
		}
	}
	else if (super.active || super.active.tails)
	{
		playMusic(MUSIC_SUPER)		// Super Theme
	}
	else if (u8[0xffffb000 + 0x2b] & char.bonus.INVINCIBLE)
	{
		playMusic(MUSIC_INVINCIBLE)		// Invincibility Theme
	}
	else
	{
		playMusic(level.default_music)
	}

#else

	// In original code, this is only called where A1 == 0xffffb000
	if (level.boss_encounter)
	{
		playMusic(MUSIC_MINIBOSS)
	}
	else if (super.active || (u8[A1 + 0x2b] & char.bonus.INVINCIBLE))
	{
		playMusic(MUSIC_INVINCIBLE)
	}
	else
	{
		playMusic(level.default_music)
	}

#endif
}



// In Original Mode, do not speed up fleeing Eggman after MGZ2 and FBZ2 bosses as AIR does (to prevent visible VRAM conflicts)
// Functions taken from bosses\bosses_shared.lemon
//# address-hook(0x067f04) end(0x067f18)
function void fn067f04()
{
	D0.u16 = camera.position.y.u16 + 0x40
	if (D0.u16 < objA0.position.y.u16)
	{
		--objA0.position.y.u16

	#if STANDALONE
	if (!original_mode)
	{
		// Faster after Knuckles' boss fight in MGZ 2
		if (global.zone == 0x02 && isMainCharacter(CHARACTER_KNUCKLES))
		{
			if ((objA0.position.y.u16 % 3) == 0)
				--objA0.position.y.u16
		}
	}
	#endif

		return
	}

	objA0.base_state = 0x08
	fn067f1e()
}

//# address-hook(0x067f1e) end(0x067f38)
function void fn067f1e()
{
	// This function is also used by FBZ 2 boss after defeat

	objA0.render_flags |= render_flag.FLIP_X
	objA0.velocity.x = 0x0300
	objA0.velocity.y = 0
	objA0.countdown_value = 0x0100

#if STANDALONE
	if (!original_mode)
	{
		// Faster in FBZ so he's definitely offscreen when level results start (and overwrite some his patterns in VRAM)
		if (global.zone == 0x04)
		{
			objA0.velocity.x += getScreenExtend() * 4
		}

		// Same for Knuckles' boss fight in MGZ 2
		if (global.zone == 0x02 && isMainCharacter(CHARACTER_KNUCKLES))
		{
			objA0.velocity.x += getScreenExtend() * 6
		}
	}
#endif

	// "spawnChildObjects(0x0681b4)" replaced by:
	spawnChildObject(0x068062, 0x00, 30, 0)
}





// Adjust Egg Prison position at the end of MGZ2 to sit on a lower (flat) floor and to be centered on screen.
// Function taken from bosses\boss_mgz2_knuckles.lemon
//# address-hook(0x06c8b4) end(0x06c8ee)
function void fn06c8b4()
{
	objA0.update_address = 0x06c8f4
	level.wait_for_results = 0xff
	level.boss_encounter = 0

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x086540
		objA1.position.x.u16 = original_mode ? 0x3f40: 0x3f30	// originally 0x3f40
		objA1.position.y.u16 = original_mode ? 0xb0 : 0xd0		// originally 0xb0
	}

	D0.u16 = level.bossarea.left + getScreenWidth() - 0x28
	screenmover_target.right = D0.u16

	spawnSimpleChildObjects(0x084b00)
}





// Adjust end-of-zone transition from MGZ to CNZ to unlock Tails' movement
//# address-hook(0x06c8f4) end(0x06c930)
function void fn06c8f4()
{
	move_area.left = camera.position.x.u16
	if (level.wait_for_results)
		return

	objA0.update_address = 0x06c932
	level.wait_for_results = 0
	stopCharacterWinPose(0xffffb000)
	stopCharacterWinPose(0xffffb04a)	// added to unlock Tails' movement
	PlayMusicAfterLevelResults()
	control.player1 = 0
	player1.control_override = 0xff
	objA0.countdown_value = 0
	player1.camera_lock = 1
	move_area.right += 0x30

#if STANDALONE
	// Replace a chunk so Knuckles won't run into a wall (just outside the right screen border)
	// Note that this chunk is actually on the left of the level, as we're on the rightmost edge of the level, and the chunks wrap here
//	u8[0xffff8188] = 0x4f	// 0x4a in AIR. We handle this on boss load (function void fn06c698()) instead of after the level's end so the fix is always visible in ultrawide resolutions.
#endif
}











// Start walk-in levels with a run at the standard ground speed cap.
// This should make it less tempting to jump at the start of DEZ1 (which can kill a player), and makes abusing a frame-perfect jump
// for extra acceleration when starting a walk-in useless.
// Function taken from objects\level\walkintolevel.lemon
//# address-hook(0x044a26) end(0x044a62)
function void fn044a26()
{
	player1.control_override = 1
	control.player1 = 0x0800

	camera.use_forced_target = true			// Forces camera to a certain position
	camera.forced_target.x = u16[A0 + 0x30]
	camera.forced_target.y = objA0.value32

	if (!original_mode)
	{
		u16[0xffffb01c] = 0x0680	// set player to usual max ground speed
		if (global.characters == CHARS_SONIC_AND_TAILS || useKnucklesAndTails)
			u16[0xffffb01c + 0x4a] = 0x0680	// set sidekick Tails to usual max ground speed
	}

	D0.u16 = u16[0xffffb010] + 0x10
	if (D0.u16 < u16[A0 + 0x30])
		return

	player1.control_override = 0
	player2.control_override = 0
	UnloadObject()
}






// Display potential control inputs when on a "doom barrel"
// Function taken from objects\04_cnz\cnz_barrel.lemon
//# address-hook(0x032208) end(0x0322ee)
function void fn032208()
{
	bool onBarrel = objA0.flags2a & object.flag.P1_ON_OBJECT
	if (objA0.velocity.y < 0 && onBarrel && display_inputs && !original_mode)
		Renderer.drawCustomSprite("@input_icon_button_up", getScreenWidth()/2, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	else if (onBarrel && display_inputs && !original_mode)
		Renderer.drawCustomSprite("@input_icon_button_down", getScreenWidth()/2, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	base.fn032208()
}




// Revert behavior on the inflating platform for Original Mode: sidekick Tails should affect it and it should get stuck on the floor.
// Function taken from objects\04_cnz\cnz_inflatingplatform.lemon
//# address-hook(0x031c0a) end(0x031c98)
function void fn031c0a()
{
	D0.u8 = objA0.flags2a & (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT)
	// Ignore AI Tails
	if (tails.control_counter == 0 && !original_mode)
		D0.u8 &= object.flag.P1_ON_OBJECT
	if (u8[A0 + 0x30] == 0)
	{
		if (D0.u8 != 0)
		{
			u8[A0 + 0x30] = 1
			objA0.state.both = 0x0100
		}

		if (objA0.velocity.y != 0)
		{
			UpdateMovementStraightSimple()
			objA0.velocity.y += 8
			if (objA0.velocity.y >= 0)
			{
				objA0.velocity.y = 0
				objA0.state.both = 0x0200
			}
		}
	}
	else
	{
		if (D0.u8 != 0)
		{
			UpdateMovementStraightSimple()
			if (objA0.velocity.y < 0x200)
			{
				objA0.velocity.y += 0x18
			}

			CheckGroundCollision()
			if (D1.s16 < 0)
			{
				// Hit the ground
				objA0.position.y.u16 += D1.u16
			if (original_mode)
			{
				// In original code, the platform is stuck at the ground now
				//  -> But this is just punishing player who don't know this, so don't do this in S3AIR
				objA0.update_address = 0x031bd2
			}
				objA0.state.both = 0x0200
			}
		}
		else
		{
			objA0.velocity.y = -objA0.velocity.y - 0x80
			u8[A0 + 0x30] = 0
			playSound(0x75)
		}
	}
}







// In Original Mode, do not make a sound when the cannons fire
// Function taken from objects\04_cnz\cnz_cannon.lemon
//# address-hook(0x0319f4) end(0x031b16)
function void fn0319f4()
{
#if STANDALONE
	if (!original_mode)
	{
		// Ignore for Tails while he's carrying another player
		if (A1 == 0xffffb04a && tails.carrying)
			return

		// Also ignore character in all but normal state (especially in hurt state, as this would lead to buggy behavior)
		if (u8[A1 + 0x05] != 0x02)
			return
	}
#endif

	if (u8[A2] == 0)
	{
		u8 bit = (1 << D6.u8)
		if (objA0.flags2a & bit)
		{
			objA0.flags2a &= ~bit
			objA1.sprite_priority = 0x0380
			objA1.position.x.u16 = objA0.position.x.u16
			objA1.velocity.x = 0
			objA1.velocity.y = 0
			u16[A1 + 0x1c] = 0
			u8[A1 + 0x1e] = 0x0e
			u8[A1 + 0x1f] = 0x07
			objA1.state = char.state.ROLLING
			objA1.flags2a |= (char.flag.IN_AIR | char.flag.ROLLING)
			objA1.flags2a &= ~char.flag.ON_OBJECT
			u8[A1 + 0x2e] = 0x81

			u8[A2] = 1

		#if STANDALONE
			// If Tails is carrying the other player, this connection should better get resolved now
			if (tails.carrying && !original_mode)
			{
				tails.carrying = 0		// Seems to be this simple, or is anything else needed here?
			}
		#endif
		}
	}
	else if (u8[A2] == 1)
	{
		D0.u16 = objA1.velocity.y
		objA1.velocity.y += 0x38
		D0.s32 = s32(D0.s16) << 8
		u32[A1 + 0x14] += D0
		if (objA1.position.y.u16 > objA0.position.y.u16)
		{
			objA1.position.y.u16 = objA0.position.y.u16
			objA1.state = char.state.DISAPPEARED

			u8[A2] = 2
		}
	}
	else if (u8[A2] == 2)
	{
		if (u16[A0 + 0x34] != 2)
		{
			if (u16[A0 + 0x30] == 0x0200 || u16[A0 + 0x30] == 0x0202)
			{
				u16[A0 + 0x34] = 1
			}

			// Check if jump button pressed
			if ((D1.u16 & CONTROL_ABC) == 0)
				return
		}

		// Shoot now
		D0.u8 = 0x80 + objA0.compound.sprite1.animation.sprite * 0x10
		LookupSinCos()
		D1.s16 <<= 4
		D0.s16 <<= 4

		objA1.velocity.x = D1.s16
		objA1.velocity.y = D0.s16
		objA1.groundspeed = D1.s16
		objA1.position.x.u16 = objA0.position.x.u16
		objA1.position.y.u16 = objA0.position.y.u16 - 0x18
		objA1.state = char.state.ROLLING
		objA1.flags2a |= char.flag.IN_AIR
		u8[A1 + 0x2e] = 0
		u8[A1 + 0x40] = 0

		u16[A0 + 0x34] = 2
		u16[A0 + 0x36] = 0x0f

		u8[A2] = 3
		u8[A2 + 0x02] = 0x08

		if (!original_mode)
			playSound(0x81)
	}
	else
	{
		--u8[A2 + 0x02]
		if (u8[A2 + 0x02] == 0)
		{
			objA1.sprite_priority = 0x0100
			u8[A2] = 0
		}
	}
}








// Adjust the distance and direction a spiral tube tube carries a player in CNZ
// Function taken from objects\04_cnz\cnz_helix.lemon
//# address-hook(0x03318e) end(0x0331c8)
function void fn03318e()
{
	D0.u8 = u8[A4 + 0x01]
	u8[A4 + 0x01] += 0x08
	LookupSinCos()
	D1.s16 >>= 3
	D0.u16 = D1.u16
	D1.s16 >>= 1
	D0.u16 += D1.u16
	D0.u16 += objA0.position.x.u16
	objA1.position.x.u16 = D0.u16
	D0 = (global.act & 0x01) ? 0 : 0x80 // D0 = (u8[0xfffffe21] & 0x01) ? 0x80 : 0	// sets tube end direction based on act; based on odd or even rings in original game.
	if (D0.u8 == u8[A4 + 0x01])
	{
		u8[A4] += 0x02				// something to do with how to move down the spiral
		u16[A4 + 0x02] = 0x40		// vertical distance divided by 2, usually 0xc0, 0x40 sets the correct height for this mod
	}
}




// Remove the roll jump flag when a character is sprung by a Clamer badnik
// Function taken from badniks\cnz_clamer.lemon
//# address-hook(0x0890d8) end(0x089122)
function void fn0890d8()
{
	D0.u16 = 0x0800
	u8[A1 + 0x2a] &= ~0x01
	if (objA0.render_flags & render_flag.FLIP_X)
	{
		D0.s16 = -D0.s16
		u8[A1 + 0x2a] |= 0x01
	}
	u8[A1 + 0x05] = 0x02
	objA1.position.y.u16 += 6
	objA1.velocity.x = D0.u16
	objA1.velocity.y = -0x800
	u16[A1 + 0x1c] = D0.u16
	objA1.state = char.state.STRAIGHTJUMP
	if (!original_mode)
		objA1.flags2a &= ~char.flag.CONTROL_LOCK	// new to remove roll jump control lock
	objA1.flags2a |= char.flag.IN_AIR
	u8[A1 + 0x40] = 0

	playSound(0xb1)
}



// Do not enable a Batbot priority fix in Original Mode
// Functions taken from enemies\cnz_batbot.lemon
//# address-hook(0x08937c) end(0x08938a)
function void fn08937c()
{
#if STANDALONE
	// Put Batbot in front of the stage, #contributed by TheMushrunt
	if (!original_mode)
		objA0.sprite_priority = 0x200
#endif
	// Targets:
	//  - 0x089394	-> objA0.base_state = 0x00
	//  - 0x0893a4	-> objA0.base_state = 0x02
	//  - 0x0893cc	-> objA0.base_state = 0x04
	call tableLookupAddress(0x08938e, objA0.base_state)

	Enemy.DrawOrUnload()
}

//# address-hook(0x08942e) end(0x089440)
function void fn08942e()
{
#if STANDALONE
	// Putting Batbot's body in front of the stage required the eyes to be brought up in priority
	if (!original_mode)
		objA0.sprite_priority = 0x180
#endif
	MoveWithParent()

	// Targets:
	//  - 0x08944a	-> objA0.base_state = 0x00
	//  - 0x08940c	-> objA0.base_state = 0x02
	//  - 0x089452	-> objA0.base_state = 0x04
	call tableLookupAddress(0x089444, objA0.base_state)

	fn084920()
}


// In Original Mode, hurt players should fall through CNZ antigrav fans
// Function taken from objects\04_cnz\cnz_fan.lemon
//# address-hook(0x031e96) end(0x031f2e)
function void fn031e96()
{
	if (!original_mode)
		base.fn031e96()

#if STANDALONE
	if (debug_mode.state != 0)
		return
#endif

	u16 dx = objA1.position.x.u16 - objA0.position.x.u16 + objA0.value32
	u16 dy = objA1.position.y.u16 - objA0.position.y.u16 + u8[0xfffffe84] + u16[A0 + 0x36]
	if (dx < u16[A0 + 0x34] && dy < u16[A0 + 0x38])
	{
//	#if STANDALONE
//		// Also consider the "hurt" state
//		if (u8[A1 + 0x05] <= 0x04 && u8[A1 + 0x2e] == 0)
//		{
//			if (u8[A1 + 0x05] == 0x04)
//				u8[A1 + 0x05] = 0x02
//	#else
		if (u8[A1 + 0x05] < 0x04 && u8[A1 + 0x2e] == 0)
		{
//	#endif
			D1.u16 = dy - u16[A0 + 0x36]
			if (D1.s16 >= 0)
			{
				D1.u16 = (-1 - D1.s16) * 2
			}

			D1.u16 += u16[A0 + 0x36]
			D1.s16 = -D1.s16
			D1.s16 >>= 4
			objA1.position.y.u16 += D1.u16
			objA1.flags2a |= char.flag.IN_AIR
			objA1.flags2a &= ~char.flag.CONTROL_LOCK
			objA1.velocity.y = 0
			u8[A1 + 0x2f] = 0
			u8[A1 + 0x40] = 0

			D6 = 1
			u16[A1 + 0x1c] = 1
		#if STANDALONE
			if (u8[A1 + 0x27] == 0 || objA1.state == char.state.ROLLING)	// Prevent a rare glitch that makes Sonic roll over the fans
		#else
			if (u8[A1 + 0x27] == 0)
		#endif
			{
				objA1.state = char.state.RUNNING
				u8[A1 + 0x27] = 1
				u8[A1 + 0x30] = 0x7f
				u8[A1 + 0x31] = 8

			#if STANDALONE
				// Fix for bug when Tails carries other player and gets caught by the fan
				if (u8[A1 + 0x38] == CHARACTER_TAILS && tails.carrying)
				{
					u8[0xffffb000 + 0x2a] |= char.flag.IN_AIR
					u8[0xffffb000 + 0x2e] = 0
				}
			#endif
			}
		}
	}
}





// Modify the lowest possible camera position in CNZ2 to disallow seeing below the level background
// Function taken from level\04_cnz\level_cnz.lemon
//# address-hook(0x052224) end(0x052228)
function void UpdateLevelScrolling.CNZ2()
{
	if (!original_mode && move_area.bottom.target == 0x1000)
		move_area.bottom.target = 0x0b70	// going more than a few pixels lower than this reveals the background's lower edge
	base.UpdateLevelScrolling.CNZ2()
}



// Do not enable a CNZ1 boss palette fix in Original Mode
// Function taken from objects\shared.lemon
//# address-hook(0x08598a) end(0x0859cc)
function void fn08598a()
{
#if STANDALONE
	// Fix for CNZ1 miniboss altering Ring palette, #contributed by TheMushrunt
	if ((objA0.update_address == 0x06da24 && objA0.base_state < 0x06) && global.zone_act == 0x0300 && !original_mode)
		return
#endif
	if (u8[0xfffffabf] != 0)
		return

	A1 = 0xfffffade
	while (u16[A1] != 0)
	{
		--u8[A1 + 2]
		if (s8[A1 + 2] < 0)
		{
			A2 = u32[A1 + 4]
			A3 = 0xffff0000 + u16[A2]
			A4 = A2 + u16[A1]
			D1.u16 = u16[A4]
			if (D1.s16 < 0)
			{
				if (fn0859ce())
				{
					A1 += 8
					continue
				}
			}

			D2 = u8[A2 + 2]
			while (D2.s16 >= 0)
			{
				u16[A3] = u16[A4]
				A3 += 2
				A4 += 2
				--D2.s16
			}

			u8[A1 + 2] = u16[A4]
			A4 += 2
			D0 = A4 - A2
			u16[A1] = D0.u16
		}
		A1 += 8
	}
}






// In Original Mode, do not use AIR's camera adjustment after the CNZ1 boss
// Function taken from level\04_cnz\level_cnz.lemon
//# address-hook(0x051d82) end(0x051e0e)
function void fn051d82()
{
	D0.u16 = 0x01c0
	fn0520e8()
	D7.u16 = 0xc000
	D1 = 0
	D2.u16 = 0x0200
	fn04ef64()
	if (!_negative())
	{
		D7.u16 = 0xe000
		fn051fb0()
		UpdateBackgroundTiles.General()
		WriteScrollOffsets()
		fn04f386()
		return
	}

	A1 = 0xffff0004 + u16[A3 + 0x0c]
	A5 = 0xffff0063 + u16[A3 + 0x12]
	D0.u16 = u16[A3 - 0x08]
	D1.u16 = u16[A3 - 0x0a]
	D2 = 5
	while (D2.s16 >= 0)
	{
		copyMemory(A5, A1, 5)
		A1 += D0.u16
		A5 += D1.u16
		--D2.s16
	}

	level.dualplanecollision = 0
	u16[0xffffeeda] = 0
	D0.u16 = 0x01c0
	u16[0xffffb000 + 0x14] += D0.u16
	u16[0xffffb04a + 0x14] += D0.u16
	camera.position.y.u16 += D0.u16
	camera.foreground.y.u16 += D0.u16
	Level.GetCameraPosition()

	if (!original_mode)
		move_area.bottom.target = 0x0420

	u16[0xffffeec8] = (D0.u16 + 0xe0) & level.height.tilemask
	u16[0xffffeeca] = 0x0f
	level.scrolling_routine += 4
	fn051e12()
}






// For Original Mode, ignore the water height set in StartingWaterHeights.bin.
// Also set water for the proper unlockable acts.
// Functions taken from maingame\maingame.lemon
//# address-hook(0x007892) end(0x007a48)
//# address-hook(0x007893)
function void Level.InitializeWater()
{
	bool levelHasWater = false
	if (global.zone_act == 0x0000 || global.zone == 0x01 || global.zone_act == 0x0501 || global.zone_act == 0x0601 || unlock_act == 2)
	{
		levelHasWater = true
	}
	else if (global.zone_act == 0x0001)		// Angel Island 2
	{
		levelHasWater = (global.zone_act.apparent != 0x01 || !isMainCharacter(CHARACTER_KNUCKLES) || level.start_location == 1)
	#if STANDALONE
		if (!levelHasWater && checkpoint.number != 0)	// Checkpoint 0 is Knuckles' start
		{
			// Knuckles presumably on Sonic's path?
			u16 px = (global.stage_type == 0) ? checkpoint.x : u16[0xfffffe4c]
			u16 py = (global.stage_type == 0) ? (checkpoint.y & 0x7fff) : u16[0xfffffe4e]
			if (px < 0x1400)
			{
				// Start area of AIZ 2
				levelHasWater = (py < 0x0400)
			}
			else
			{
				levelHasWater = (py < 0x0620)
			}
		}
	#endif
	}
	else if (global.zone_act == 0x0301)		// Carnival Night 2
	{
		levelHasWater = !isMainCharacter(CHARACTER_KNUCKLES)
	}

	if (!levelHasWater)
	{
		level.water_present = 0
		water.height.current = 0x1000
		water.height.next = 0x1000
		water.height.target = 0x1000
	}
	else
	{
		level.water_present = 1
		competition_mode.active = 0

		u16[0xfffffff6] = 0x4ef9	// Machine code for "jump"
		if (global.zone == 0x01)
		{
			irq_table.lineupdate = 0x001024
		}
		else if (u16[0xffffffd6] >= 0x1000)
		{
			irq_table.lineupdate = 0x000f00
		}
		else
		{
			irq_table.lineupdate = 0x000dd8
		}

		water.palette.source = 0x0074e0

		u16 offset = global.zone * 4 + global.act * 2
		u16 waterHeight = u16[0x006d2c + offset]
		if (original_mode && global.zone_act == 0x0301)		// Original Mode CNZ2 lines up with base S3&K
			waterHeight = 0x0a90
		if (unlock_act == 2)	// Chemical Plant Zone
		{
			bool KnuxHardLayout = (layout.part == 2)
			waterHeight = (KnuxHardLayout) ? 0x0590 : (layout.part == 1 && (checkpoint.number & 0x7f) <= 10) ? 0x0710 : (layout.part == 1) ? 0x0510 : 0x0c00
		}
		water.height.target = waterHeight
		water.height.current = waterHeight
		water.height.next = waterHeight
		water.height.target = waterHeight

		water.transition_counter = 0
		water.fullscreen = 0
		water.height.changerate = 1

		Level.InitializeWater.Part2()
	}
}

//# address-hook(0x00796c)
function void Level.InitializeWater.Part2()
{
	if (level.water_present)
	{
		if (global.zone_act == 0x0000)			// AIZ 1
		{
			D0 = 0x2b
		}
		else if (global.zone_act == 0x0001)		// AIZ 2
		{
			D0 = 0x2c
			water.palette.source = 0x007502
		}
		else if (global.zone_act == 0x0100)		// HCZ 1
		{
			D0 = 0x31
			water.palette.source = 0x007554
		}
		else if (global.zone_act == 0x0101)		// HCZ 2
		{
			D0 = 0x32
			water.palette.source = 0x007554
		}
		else if (global.zone_act == 0x0301)		// CNZ 2
		{
			D0 = 0x3a
			water.palette.source = 0x00752a
		}
		else if (global.zone_act == 0x0501)		// ICZ 2
		{
			D0 = 0x39
			water.palette.source = 0x00752a
		}
		else if (global.zone_act == 0x0600)		// LBZ 1
		{
			D0 = 0x2d
			water.palette.source = 0x007554
		}
		else									// LBZ 2	// CPZ is using this while testing
		{
			D0 = 0x2e
			water.palette.source = 0x00757e
		}

		D1.u16 = D0.u16
		fn003df2()

		D0.u16 = D1.u16
		fn003e0e()

		if (checkpoint.number != 0)
		{
			water.fullscreen = checkpoint.water.fullscreen
		}

	#if STANDALONE
		if (!EXTENDED_CHARACTER_PALETTES)
	#endif
		{
			if (isMainCharacter(CHARACTER_KNUCKLES))
			{
				// Copying in Knuckles' colors into underwater palette
				A1 = 0x007a4a + global.zone * 6
				if (unlock_act)
					A1 = 0x007a4a + 0x03 * 6	// use CNZ water palette for now
				copyMemory(0xfffff004, A1, 6)
				copyMemory(0xfffff084, A1, 6)
			}
		}
	}
}



// Edit the target water height when the breakable block is destroyed to drain the water in CNZ2.
// Function taken from level\04_cnz\cnz2_knuckles_lights_out.lemon
//# address-hook(0x065d46) end(0x065d68)
function void fn065d46()
{
	if (original_mode)
	{
		base.fn065d46()
		return
	}
	A1 = 0xffff0000 + u16[A0 + 0x44]
	if (u32[A1] != 0x02a5f8)
	{
		CheckForUnloadObject()
		return
	}

	if (u8[0xfffffaa2] == 0)
	{
		u8[0xfffffaa2] = 0xff
		water.height.target = 0x0c10	// 0x0a58	// normally 0x0958, but it's then set to 0x0a58 anyway when the lights are turned on in the original code
		water.height.changerate = 2
	}

	UnloadObject()
}

// Edit the target water height when the switch to turn the CNZ2 lights on is activated.
// The time attack check is removed, as we use the normal water settings in DAGE time attack modes.
// Function taken from level\04_cnz\cnz2_knuckles_lights_out.lemon
//# address-hook(0x065d8c) end(0x065dd0)
function void fn065d8c()
{
	if (original_mode)
	{
		base.fn065d8c()
		return
	}
	fn065dec()
	objA0.animation.sprite = 0

	if (objA0.flags2a & 0x18)
	{
		objA0.animation.sprite = 1

//	#if STANDALONE
//		if (time_attack)
//		{
//			// Lower the water level, even though lights were on all the time
//			water.height.target = 0x0b90
//		}
//	#endif

		if (u8[0xfffffaa3] != 0)
		{
			u8[0xfffffaa3] = 0
			water.height.target = 0x0c10	// 0x0a58
			playSound(0x57)
			if (allocDynamicObjectStd())
			{
				objA1.update_address = 0x062480
				u8[A1 + 0x2c] = 0xff
			}
		}
	}

	DrawOrUnloadObject()
}



// In Original Mode, allow gliding over the CNZ2 boss.
// Function taken from level\04_cnz\level_cnz.lemon
//# address-hook(0x05227c) end(0x05227c)
function void fn05227c()
{
	UpdateBackground.CNZ1()
	fn052280()

#if STANDALONE
	// Limit movement to where the boss area ends, to prevent Knuckles from gliding over the boss
	if (global.zone_act == 0x0301 && move_area.right == 0x6000 && camera.position.x.u16 >= 0x4500 && camera.position.y.u16 < 0x320 && !original_mode)
	{
		move_area.right = max(0x4620 + getScreenWidth(), 0x47e0)
		level.vertical_wrap = 0x0200
	}
#endif
}



// Lowers the CNZ2 boss slightly for Knuckles to match DAGE behavior
// and make Original Mode adjustments.
// Functions taken from bosses\boss_cnz2.lemon
//# address-hook(0x06e4f2) end(0x06e542)
function void fn06e4f2()
{
	setupObjectAttributesFull(0x06ed84)
	boss.remaining_hits = 8

	// start new code
	if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		objA0.position.y.u16 += 0x0010
	}
	// end new code

	u16[A0 + 0x3a] = objA0.position.y.u16
	objA0.countdown_value = 0x7f
	objA0.countdown_callback = 0x06e55e
	objA0.velocity.x = -0x100
	fn0685e2()

	spawnChildObjects(0x0681a4)
	if (_equal())
	{
		u8[A1 + 0x2c] = 0x09
	}

	spawnChildObjects(0x06edcc)

	A2 = 0x06edd4
	SpawnIdenticalChildObjects()
}

//# address-hook(0x06e4be) end(0x06e4c4)
function void fn06e4be()
{
	if (!original_mode)
	{
		// Let Robotnik start slightly more to the right, so he does not clip in
		objA0.position.x.u16 += 16
	}

	objA0.update_address = 0x06e4c6
}

//# address-hook(0x06e724) end(0x06e772)
function void fn06e724()
{
	move_area.left = camera.position.x.u16
	if (level.wait_for_results)
		return

	objA0.update_address = 0x06e778

	stopCharacterWinPose(0xffffb000)
	stopCharacterWinPose(0xffffb04a)

	PlayMusicAfterLevelResults()
	screenmover_target.top = 0x0200
	if (!original_mode)
		screenmover_target.right = level.bossarea.left + 0x0320 + getScreenExtend()		// Using 0x0320 here, as the cannon is off-center otherwise
	else
		screenmover_target.right = level.bossarea.left + 0x0310

	// "spawnSimpleChildObjects(0x084b0c)" replaced by:
	spawnSimpleChildObjects(0x084aa4, 1)		// Screen mover for the upper border

	// "spawnSimpleChildObjects(0x084b00)" replaced by:
	spawnSimpleChildObjects(0x084a48, 1)		// Screen mover for the right border

	if (!original_mode)
	{
		// Exchange rightmost chunks
		u8[0xffff8417] = u8[0xffff8416]
		u8[0xffff84af] = u8[0xffff84ae]
	}
}
//# address-hook(0x06e7e4) end(0x06e80a)
function void fn06e7e4()
{
	// Fire the cannon when it's ready
	--objA0.countdown_value
	if (objA0.countdown_value >= 0)
		return

	A1 = 0xffff0000 + u16[A0 + 0x44]
	if (u8[A1 + 0x26] != 0x12)
		return

	objA0.update_address = 0x06e80c

	control.player1 = 0x7070		// CONTROL_ABC, CONTROL_ABC

	player1.control_override = 0xff

#if STANDALONE
	if (!original_mode)
	{
		// Prevent that character gets stopped by right screen border after getting shot out of the cannon
		player1.camera_lock = 1
		move_area.right += 0x100
	}
#endif
}


//# address-hook(0x06e80c) end(0x06e826)
function void fn06e80c()
{
	// Minor tweak: Fade out a little later
	if ((u16[0xffffb000 + 0x14] > camera.position.y.u16 - 0x20) && !original_mode)
		return
	else if (u16[0xffffb000 + 0x14] > camera.position.y.u16 + 0x20)
		return

	TriggerNextZone(0x0500)
	fn0852ae()
}

//# address-hook(0x06e8a2) end(0x06e8b0)
function void fn06e8a2()
{
	UpdateMovementSimple()
	if (objA0.velocity.y >= 0)
	{
		Object.TriggerOnGroundHit()		// Calls 0x06e8b6 on each hit
	}

	if (!original_mode)	// outside of Original Mode, don't let the ball go off screen
	{
		if (objA0.position.x.u16 < move_area.left + 0x10 && objA0.velocity.x < 0)
		{
			objA0.velocity.x = -objA0.velocity.x
		}
		else if (objA0.position.x.u16 > move_area.right + 320 - 0x10 && objA0.velocity.x > 0)
		{
			objA0.velocity.x = -objA0.velocity.x
		}
	}
}
















function void ICZ1_CustomSprites()
{
	#if STANDALONE
	if (rain_intensity && camera.position.x.u16 < 0x3940 && palette_set >= 2 && !original_mode)	// only if this isn't set to None in the mod settings and in the opening area
	{
		D0.u8 = ((level.framecounter.low + (camera.position.x.u16/4)) & 0x3F) // * 2	// snow is 64 by 64 (0x3F by 0x3F), position is moved by 1/2 pixel down and 2 left each frame
		D1.u8 = ((level.framecounter.low - (camera.position.y.u16/8)) & 0x7F) // * 2	// snow is 64 by 64 (0x3F by 0x3F), position is moved by 1/2 pixel down and 2 left each frame
		{
		if (rain_intensity == 1)
			Renderer.drawCustomSprite("snow0_light", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
		else if (rain_intensity == 2)
			Renderer.drawCustomSprite("snow0", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
		else
			Renderer.drawCustomSprite("snow0_heavy", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
		}																								// Different values for the first nybble make the snow render above low plane foreground and above sprites,
	}																									// as stated in the Oxygen handbook.
	#endif
}





// When entering the ICZ1 snowboarding section, if a shield was carried from CNZ2, do not draw it until the character is on screen.
// Because of the timing of shield pattern updates, this causes the lightning shield to pop in two frames too late, but this is much less noticeable than a floating empty shield.
// This also occurs in all run-in levels but is most noticeable in ICZ1 for Sonic.
// Function taken from objects\basics\shields.lemon
//# address-hook(0x01999a) end(0x0199e8)
function void Shield.SharedSpriteUpdate()
{
	base.Shield.SharedSpriteUpdate()
	if (global.zone_act == 0x0500 && u16[0xffffb010] == 0x0010 && !original_mode)
	{
		VDP.setupVRAMWrite(objA0.shield.targetInVRAM)
		VDP.zeroVRAM(0x340)
	}
}


// Overwrites function disallowing leftward pushing of ICZ sliding platforms in Act 1
// Function taken from objects\05_icz\icz_floatingplatform.lemon
//# address-hook(0x089ff2) end(0x08a034)
function void fn089ff2()
{
	bool pushing = (objA0.flags2a & 0x20) && (control.pad1.state & (CONTROL_LEFT | CONTROL_RIGHT))
	if (global.zone_act == 0x0501)
		pushing = (objA0.flags2a & 0x20) && (control.pad1.state & CONTROL_RIGHT)
	if (pushing)
	{
		++objA0.value39
		if (objA0.value39 >= 0x10)
		{
			objA0.base_state = 0x08

			A1 = 0xffffb000
			CheckDistanceToPlayers()

			D1.u16 = 0x80
			if (D0.u16 != 0)
				D1.s16 = -D1.s16
			objA0.velocity.x = D1.u16
		}
	}
	else
	{
		objA0.value39 = 0
	}
}





// Creates velocity direction exception for the first ICZ sliding platform
// Function taken from objects\05_icz\icz_floatingplatform.lemon
//# address-hook(0x08a11c) end(0x08a174)
function void fn08a11c()
{
	fn08a36c()
	UpdateMovementStraightSimple()
	CheckGroundCollision()
	if (D1.s16 >= 0)
	{
		if (objA0.velocity.x != 0)
		{
			if (objA0.velocity.x >= 0)
			{
				D3 = 0x20
				fn00fac4()
				if (D1.s16 < 0)
				{
					objA0.position.x.u16 += D1.u16
					objA0.velocity.x = 0
				}
			}
			else
			{
				D3 = -0x20
				fn00fe3c()
				if (D1.s16 < 0)
				{
					objA0.position.x.u16 += D1.u16
					objA0.velocity.x = 0
				}
			}
		}
	}
	else
	{
		objA0.base_state = 0x08
		D0.u16 = objA0.velocity.y
		if (D3 & 0x40)
			D0.s16 = -D0.s16

		objA0.velocity.x = D0.u16
		if (objA0.position.x.u16 > 0x3e80 && objA0.position.x.u16 < 0x4000 && !original_mode)	// Act 1's first platform when not in Original Mode
			objA0.velocity.x = -D0.u16	// The code doesn't check the act, though; there simply aren't platforms there in Act 2
	}
}





// This function sets y velocity on the frame a sliding platform leaves the ground, after which fn08a36c() does for future frames.
// We tell a midair platform to reclaim its spot as the active platform, as another spawning platform may have overwritten it.
// Function taken from objects\05_icz\icz_floatingplatform.lemon
//# address-hook(0x08a3b6) end(0x08a3bc)
function void fn08a3b6()
{
	D1.u16 >>= 1
	objA0.velocity.y = D1.u16
	u16[0xfffffaa4] = A0.u16	// again set this platform's address (lower word) as the active moving platform
}





// Load chunks, blocks, and tiles as the character moves from ICZ1 to ICZ2
// Function taken from level\05_icz\level_icz.lemon
//# address-hook(0x05382c) end(0x053882)
function void fn05382c()
{
	if (camera.position.x.u16 >= 0x6900)
	{
		// Preparation for mini-boss fight
		push(A3)
		push(A2)
		push(A0)
		push(D7)

	//	Kosinski.addToDecompressionQueue(0x3dcfbc, 0xffff0a00)		// Act 2 Chunks
		System.loadExternalRawData(stringformat("icz2_chunks_s", global.act + 1), KosinskiRawdataBuffer)		// copy Secondary chunks to shared memory
		Kosinski.addToDecompressionQueue(KosinskiRawdataBuffer, 0xffff0a00)									// decompress them to their proper RAM (see above)

		Kosinski.addToDecompressionQueue(0x3da26a, 0xffff9408)

		Kosinski.addToDMAQueue(0x3daf0a, 0x2440)

		requestLoadingPatterns(0x20)

		D7 = pop()
		A0 = pop()
		A2 = pop()
		A3 = pop()

		level.scrolling_routine += 4
	}

	UpdateBackgroundScrolling.ICZ1.Indoors()
	UpdateBackgroundTiles.General()
	WriteScrollOffsets()
}








// In Original Mode, undo some ICZ1 boss changes
// Function taken from bosses\boss_icz1.lemon
//# address-hook(0x0711ec) end(0x071224)
function void Boss.ICZ1.UpdateState00()
{
	// Base state 0x00: Initialization
	setupObjectAttributesFull(0x071960)

	boss.remaining_hits = 6
	objA0.value3e = 0x200
	objA0.velocity.y = 0x80
	objA0.countdown_value = 0xbf
	objA0.countdown_callback = 0x071236

	if (!original_mode)
	{
		// Move a bit to the left
		objA0.position.x.u16 -= getScreenExtend() / 2

		// Set x-velocity for arc depending on screen width
		objA0.value3e = 0x200 + (108 * getScreenExtend() / 40)
	}

	// "spawnSimpleChildObjects(0x0719aa)" replaced by:
	spawnSimpleChildObjects(0x0714b8, 8)

	// "spawnChildObjects(0x071984)" replaced by:
	spawnChildObject(0x071446, 0x00, -14, -11)
	spawnChildObject(0x071446, 0x02, 14, -11)
	spawnChildObject(0x071446, 0x04, 0, 18)
	spawnChildObject(0x071446, 0x06, -14, -11)
	spawnChildObject(0x071446, 0x08, 14, -11)
	spawnChildObject(0x071446, 0x0a, 0, 14)
}







function void ICZ2_CustomSprites()
{
	#if STANDALONE
	if (rain_intensity && camera.position.y.u16 < 0x06c0 && isMainCharacter(CHARACTER_KNUCKLES) && palette_set >= 2 && !original_mode)	// only if this isn't set to None in the mod settings and in the outdoor area with Knux
	{
		D0.u8 = ((level.framecounter.low + (camera.position.x.u16/4)) & 0x3F) // * 2	// snow is 64 by 64 (0x3F by 0x3F), position is moved by 1/2 pixel down and 2 left each frame
		D1.u8 = ((level.framecounter.low - (camera.position.y.u16/8)) & 0x7F) // * 2	// snow is 64 by 64 (0x3F by 0x3F), position is moved by 1/2 pixel down and 2 left each frame
		{
		if (rain_intensity == 1)
			Renderer.drawCustomSprite("snow0_light", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
		else if (rain_intensity == 2)
			Renderer.drawCustomSprite("snow0", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
		else
			Renderer.drawCustomSprite("snow0_heavy", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
		}																								// Different values for the first nybble make the rain render above low plane foreground and above sprites,
	}																									// as stated in the Oxygen handbook.
	#endif

	if (!original_mode)
	{
		Renderer.drawCustomSprite("icz2_backgroundpillar", 0x11a4 - camera.foreground.x.u16, 0x0290 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
		Renderer.drawCustomSprite("icz2_backgroundpillar", 0x2824 - camera.foreground.x.u16, 0x01b0 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
		Renderer.drawCustomSprite("icz_cavefill", 0x3d80 - camera.foreground.x.u16, 0x0700 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
	}
}





// In Original Mode, let the camera at the ICZ2 Knux start scroll left.
// Function taken from level\05_icz\level_icz.lemon
//# address-hook(0x053cc4) end(0x053cc8)
function void InitLevelTiles.ICZ2()
{
	if (camera.position.x.u16 >= 0x0700 && !original_mode)
	{
		move_area.left = 0x0740
		camera.position.x.u16 = max(0x0740, camera.position.x.u16)
	}

	// These seems to fill the patterns on screen initially
	//  (the same as will be done when scrolling, but here for the whole screen once)
	Level.GetCameraPosition()
	Level.InitialTilesFill()
}






// Adjust the x-coordinates for which background loading can occur to accommodate for the final Sonic/Tails ICZ2 giant ring
// and reintroduce flying over the ICZ1 boss in Original Mode.
//# address-hook(0x053cd0) end(0x053d50)
function void InitLevelScrolling.ICZ2()
{
	bool indoors = false

	level.scrolling_routine = 0x04
	u16 xMax = (original_mode) ? 0x3600 : 0x4000
	if (camera.position.x.u16 < xMax)	// originally 0x3600, but changed for new layout post-cutscene
	{
		if (camera.position.y.u16 >= 0x0700)	// usually 0x0720, but DAGE has one background switch with slightly less cover
		{
			indoors = true
		}
		else if (camera.position.y.u16 >= 0x0580 && camera.position.x.u16 < 0x1000)
		{
			indoors = true
		}
	}

	u16[0xffffeee8] = indoors * 0xff
	if (!indoors)
	{
		if (camera.position.x.u16 < 0x0720)
		{
			fn23e20e()
		}
		else
		{
			fn23e1aa()
		}
		UpdateBackgroundScrolling.ICZ2.Outdoors()
		D0 = 0
	}
	else
	{
		fn23e1da()
		UpdateBackgroundScrolling.ICZ2.Indoors()
		fn04f2f6()
	}

	D1 = 0
	Level.InitialTilesFill()

	A4 = indoors ? 0x23e246 : 0x23e23e
	A5 = 0xffffa800
	fn04f0ce()
}

//# address-hook(0x053d60)
//# address-hook(0x053d78) end(0x053e58)
function void fn053d78()
{
	u16 xMax = (original_mode) ? 0x3600 : 0x4000

	// This function updates both foreground and background x-scrolling

	// Switch between indoors and outdoors if necessary
	bool indoors = (u16[0xffffeee8] != 0)
	if (!indoors)
	{
		D0.u16 = camera.position.x.u16
		if (D0.u16 >= 0x1000 && D0.u16 < xMax) // originally 0x3600, but changed for new layout post-cutscene
		{
			if (u16[0xffffb010] > 0x3980 && u16[0xffffb010] < 0x3a00)
			{
				if (camera.position.y.u16 >= 0x0780)
				{
					// Switch to indoors
					move_area.left = 0x0740	// normal start-of-act camera x minimum, which is now reset after Knux cutscene
					fn053d96()
					return
				}
			}
			else if (camera.position.y.u16 >= 0x0700)	// usually 0x0720, but DAGE has one background switch with slightly less cover
			{
				// Switch to indoors
				fn053d96()
				return
			}
		}

		UpdateBackgroundScrolling.ICZ2.Outdoors()
	}
	else
	{
		D0.u16 = camera.position.x.u16
		if (D0.u16 >= 0x1000 && D0.u16 < xMax) // originally 0x3600, but changed for new layout post-cutscene
		{
			if (u16[0xffffb010] > 0x3980 && u16[0xffffb010] < 0x3a00)
			{
				if (camera.position.y.u16 < 0x0780)
				{
					// Switch to outdoors
					fn053dfc()
					return
				}
			}
			else if (D0.u16 < 0x1900 || D0.u16 >= 0x1b80)
			{
				if (camera.position.y.u16 < 0x0700)	// usually 0x0720, but DAGE has one background switch with slightly less cover
				{
					// Switch to outdoors
					fn053dfc()
					return
				}
			}
		}

		UpdateBackgroundScrolling.ICZ2.Indoors()

		A6 = 0xffffee90		// Address of camera.background.y
		A5 = 0xffffee96		// Address of camera.background.y.old
		D1 = 0
		D6 = 0x20
		LoadTileContentInDirY()
	}

	A4 = indoors ? 0x23e246 : 0x23e23e
	A5 = 0xffffa800
	fn04f0ce()

#if STANDALONE
	// Limit movement to where the boss area ends, to prevent Knuckles from gliding over the upper boss and into Act 2
	//  -> This can safely applied for the lower boss as well, as it's using the same x-positions
	if (global.zone_act == 0x0501 && global.zone_act.apparent == 0x0500 && move_area.right == 0x7000 && !original_mode)	// exception made for Original Mode
	{
		move_area.right = 0x06f0
	}
#endif
}




// Revert ICZ sloped bridge loading to use S3&K y bounds in Original Mode
// Function taken from object\level\bridge.lemon
//# address-hook(0x038756) end(0x0387b4)
function void fn038756()
{
	if (allocDynamicObjectAfterA0())
	{
		objA1.update_address = 0x03887c
		objA1.position.x.u16 = objA0.position.x.u16
		objA1.position.y.u16 = objA0.position.y.u16
		objA1.mapping_offset = objA0.mapping_offset
		objA1.sprite_attributes = objA0.sprite_attributes
		objA1.render_flags = objA0.render_flags
		objA1.sprite_priority = objA0.sprite_priority
		objA1.render_flags |= render_flag.COMPOUND
		objA1.box_size.x = 0x40
		objA1.box_size.y = original_mode ? 0x08 : 0x30	// For ICZ skewed bridges

		objA1.compound.count = D1.u16
		--D1.u8
		assert(D1.s16 <= 0x19)

		A2 = A1 + 0x18
		while (D1.s16 >= 0)
		{
			u16[(A2+=2)-2] = D3.u16
			u16[(A2+=2)-2] = D2.u16
			u16[(A2+=2)-2] = 0
			D3.u16 += 0x10
			--D1.s16
		}
	}
}







// Sets the x-flip behavior on ICZ crushing columns to only occur for Sonic and Tails.
// This flag is only used to block off the Knux cutscene.
// The first function handles dropping; the second function handles post-drop.
//# address-hook(0x08a4de) end(0x08a502)
function void fn08a4de()
{
	A1 = 0xffffb000
	CheckDistanceToObjectA1()
	if (D2.u16 >= 0x28)
	{
		if ((objA0.render_flags & render_flag.FLIP_X) && !isMainCharacter(CHARACTER_KNUCKLES))	// altered here
		{
			D0.u16 -= 2
		}

		if (D0.u16 != 0)
		{
			objA0.base_state = 0x10
		}
	}
}

//# address-hook(0x08a5e4) end(0x08a602)
function void fn08a5e4()
{
	A1 = 0xffffb000
	CheckDistanceToObjectA1()
	if ((objA0.render_flags & render_flag.FLIP_X) && !isMainCharacter(CHARACTER_KNUCKLES))	// altered here
	{
		D0.u16 -= 2
	}
	if (D0.u16 == 0)
	{
		objA0.base_state = 0x14
	}
}






// Add to a function that runs every frame in ICZ2 to check for when
// a character should enter the falling animation after the Knux scene.
// Also adjust the camera to make obstacles and bottomless pits more visible when crossing platforms on the water.
//# address-hook(0x053ccc) end(0x053ccc)
function void UpdateLevelTiles.ICZ2()
{
	// Falling animation checks for Knux cutscene
	if (u16[0xffffb010] > 0x3980 && u16[0xffffb010] < 0x3a00 && u16[0xffffb014] > 0x0680 && u16[0xffffb014] < 0x0688 && !original_mode)
	{
		if (u8[0xffffb020] == char.state.RUNNING || u8[0xffffb020] == char.state.STANDING)	// Check Sonic
		{
			u8[0xffffb020] = char.state.FALLING_PANIC
			u8[0xffffb02a] |= char.flag.IN_AIR
			u8[0xffffb03d] = 0		// Spindash flag is only active during standing/running if a peelout is charging
			u16[0xffffb03e] = 0		// Clear charge
		}
		if (u8[0xffffb06a] == char.state.RUNNING || u8[0xffffb06a] == char.state.STANDING)	// Check Tails
		{
			u8[0xffffb06a] = char.state.FALLING_PANIC
			u8[0xffffb074] |= char.flag.IN_AIR
		}
	}

	// Camera adjustment for crossing platforms on the water
	if (!original_mode)
	{
		if ((u16[0xffffb010] >= 0x22b0 && u16[0xffffb010] < 0x2800) || (u16[0xffffb010] >= 0x3800 && u16[0xffffb010] <= 0x3e00))
		{
			if (move_area.bottom.target != 0x0a10 || move_area.bottom.target != 0x0a30)
			{
				if (u16[0xffffb010] < 0x2800 && u16[0xffffb014] > 0x700)	// Knux water crossing area
				{
					move_area.bottom.current = max(0x0a10, (camera.position.y.u16 - 4) & 0xfffc)	// set to next lowest multiple of 4 in case of camera scroll glitches
					move_area.bottom.target = 0x0a10
				}
				else	// Sonic/Tails water crossing area
				{
					move_area.bottom.current = 0x0a30	// must be set right away, as the usual routing to match current match target is slower than the fall from the cutscene
					move_area.bottom.target = move_area.bottom.current
				}
			}
		}
		else if ((u16[0xffffb010] >= 0x0bc0 && u16[0xffffb010] < 0x22b0) || (u16[0xffffb010] >= 0x2800 && u16[0xffffb010] < 0x3800) || (u16[0xffffb010] > 0x3e00  && u16[0xffffb010] < 0x4000))	// last one is a window that does NOT stretch to the boss area
		{
			move_area.bottom.target = 0x0b20
			move_area.bottom.current = 0x0b20
		}
	}

	// Base function
	base.UpdateLevelTiles.ICZ2()
}




// Move the falling snowflakes that appear at outdoor bosses as if they are blown
// sideways like the other snow in Knuckles' campaign.
// These are heavier than the background snowflakes, so they fall faster and aren't blown as much.
// Function taken from objects\05_icz\icz_snowfall.lemon
//# address-hook(0x08b73a) end(0x08b750)
function void fn08b73a()
{
	if (!original_mode && palette_set >= 2 && isMainCharacter(CHARACTER_KNUCKLES))
	{
		objA0.velocity.x = -0x100
		if (objA0.position.x.u16 <= (camera.position.x.u16 - 4))	// just off screen to the left
			objA0.position.x.u16 += (getScreenWidth() + 8)			// wrap to just off screen to the right
	}

	base.fn08b73a()
}




// Adjust capsule spawn position in ICZ2 for different screen widths
// Function taken from bosses\boss_icz2.lemon
//# address-hook(0x071d9e) end(0x071de0)
function void fn071d9e()
{
	objA0.update_address = 0x071de2
	level.wait_for_results = 0xff
	level.boss_encounter = 0
	if (allocDynamicObjectStd())
	{
		// Spawn capsule
		objA1.update_address = 0x086540
		objA1.position.x.u16 = 0x4560 - getScreenExtend()
		if (getScreenWidth() >= 432)
			objA1.position.x.u16 += (getScreenWidth() - 416)
		objA1.position.y.u16 = 0x06a3
	}

	D0.u16 = level.bossarea.left + 0x0130
	screenmover_target.right = D0.u16 + getScreenExtend()
	if (getScreenWidth() >= 432)
		screenmover_target.right += (getScreenWidth() - 416)

	if (allocDynamicObjectStd())
	{
		// Spawn screen mover for the right border
		objA1.update_address = 0x084a48
	}
}


// Adjust capsule snow position in ICZ2 for different screen widths
// Function taken from objects\05_icz\icz_snow.lemon
//# address-hook(0x08b554) end(0x08b56a)
function void ICZSnow.Init2()
{
	D0 = objA0.subtype2c & ~0x80
	A2 = 0x08b7f4 + D0.s16
	objA0.update_address = u32[A2]
	A1 = u32[A2+4]
	A2 += 8
	SetupObjectAttributesFull()

	if (objA0.position.x.u16 >= 0x4520 && !original_mode)	// around capsule
	{
		if (getScreenWidth() < 400)
			objA0.position.x.u16 += ((400 - getScreenWidth())/2)
		else
		{
			objA0.position.x.u16 -= ((getScreenWidth() - 400)/2)
			if (getScreenWidth() >= 432)
				objA0.position.x.u16 += (getScreenWidth() - 416)
		}
	}
}









// Adjust end-of-zone transition in ICZ to match the original game by removing an AIR correction
// Function taken from bosses\boss_icz2.lemon
//# address-hook(0x071de2) end(0x071e22)
function void fn071de2()
{
	move_area.left = camera.position.x.u16
	if (level.wait_for_results)
		return

	level.wait_for_results = 0
	stopCharacterWinPose(0xffffb000)
	stopCharacterWinPose(0xffffb04a)

	PlayMusicAfterLevelResults()
	move_area.bottom.target = screenmover_target.bottom

//	if (!original_mode)
//		screenmover_target.right = 0x4720
//	else
		screenmover_target.right = 0x47c0

	spawnSimpleChildObjects(0x084b00)
	fn0852ae()
}



// Correct a missing bit of snow in the exit to ICZ2 with a future AIR version correction (post-v24.02.02.0)
// Function taken from enemies\shared.lemon
//# address-hook(0x085ad2) end(0x085b06)
function void fn085ad2()
{
	if ((objA0.render_flags & render_flag.VISIBLE) == 0)
	{
		DrawOrUnloadObject()
	}
	else
	{
		objA0.update_address = objA0.countdown_callback
	}

	#if STANDALONE
	// Special handling for the snow tunnel after ICZ 2 boss, to prevent a frame where the object is not drawn
	if (objA0.update_address == 0x08b554 && !original_mode) // addressof(ICZSnow.Init2)
	{
		ICZSnow.Init2()
		DrawObject()
	}
	#endif
}






// Remove vertical barriers once they fall to the right outside of Original Mode.
// D.A. Garden Edition always puts these in the floor level with the surface, and this tends to mess with player-floor interactions.
// If one of these is used in an edited layout as a legitimate platform, then the code needs to have an exception made.
// Function taken from objects\06_lbz\lbz_barrier.lemon
//# address-hook(0x025ffe) end(0x026032)
function void fn025ffe()
{
	if (objA0.subtype2c >= 0x60 && objA0.subtype2c <= 0x6f && !original_mode)	// if this object was vertical and then fell to the right,
	{
		UnloadObject()															// remove it.
		return
	}
	
	// Targets:
	//  - 0x026044	-> u16[A0 + 0x36] = 0x00
	//  - 0x02609e	-> u16[A0 + 0x36] = 0x02
	//  - 0x0260b0	-> u16[A0 + 0x36] = 0x04
	//  - 0x0260d2	-> u16[A0 + 0x36] = 0x06
	//  - 0x02609e	-> u16[A0 + 0x36] = 0x08
	//  - 0x0260c0	-> u16[A0 + 0x36] = 0x0a
	call tableLookupAddress(0x026038, u16[A0 + 0x36])

#if STANDALONE
	// Just unloaded itself?
	if (objA0.update_address == 0)
		return
#endif

	if (objA0.render_flags & render_flag.VISIBLE)
	{
		D1 = objA0.box_size.x + 11
		D2 = objA0.box_size.y
		D3.u16 = D2.u16 + 1
		D4.u16 = objA0.position.x.u16
		CheckCharacterOnClimbableObject()
	}

	D0.u16 = u16[A0 + 0x30]
	DrawOrUnloadObjectByD0()
}





// Disable AIR changes to Flybot spawning in Original Mode.
// Function taken from enemies\lbz_flybot.lemon
function void FlyBotAlert.CallFlyBot()
{
	// No spawn of bonus counter got too high, so this can't get abused any more
	if (score.bonus_counter >= 4 && !original_mode)
		return

	if (allocDynamicObjectAfterA0())
	{
		objA1.update_address = 0x08c966

		// Note: offsetX is always -0xc0 or 0xc0, offsetY is always -0x60
		D0.u16 = (objA0.subtype2c * 4) & 0x0c
		s16 offsetX = u16[0x029508 + D0.s16]
		s16 offsetY = u16[0x02950a + D0.s16]
		if (!original_mode)
		{
			// Flybot spawns on screen without that
			offsetX = (offsetX > 0) ? (getScreenWidth() / 2 + 0x20) : (-s16(getScreenWidth()) / 2 - 0x10)
		}

		A2 = 0xffffb000
		objA1.position.x.u16 = u16[A2 + 0x10] + offsetX
		objA1.position.y.u16 = u16[A2 + 0x14] + offsetY
	}
}





// In Original Mode, don't allow midair moves after jumping from a cup elevator.
// Function taken from objects\06_lbz\lbz_cupelevator.lemon
//# address-hook(0x026eda) end(0x02702c)
function void fn026eda()
{
#if STANDALONE
	if (debug_mode.state)
		return
#endif

	u8 bit = (1 << D6.u8)

	if (u8[A2] == 0)
	{
		if (u8[A2 + 0x02] != 0)
		{
			--u8[A2 + 0x02]
			return
		}

		D0.u8 = objA0.value26 - 0x20
		if (D0.u8 < 0x40)
			return

		if (fn01dcb6_internal(A1, D6))
		{
			fn01df90()
		}

		if ((objA0.flags2a & bit) == 0)
			return

		if (u16[A0 + 0x34] == 0)
		{
			D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + 8
			if (D0.s16 < 0 || D0.u16 >= 0x10)
				return
		}

		// Character enters the cup elevator
		u8[A2] = 1
		objA1.velocity.x = 0
		objA1.velocity.y = 0
		u16[A1 + 0x1c] = 0
		u8[A1 + 0x20] = 0
		u8[A1 + 0x2e] = 3
	}
	else
	{
		if (s8[A1 + 0x04] >= 0 || u8[A1 + 0x05] >= 0x04)
		{
			objA0.flags2a &= ~bit
			u8[A1 + 0x2a] &= ~char.flag.ON_OBJECT
			objA1.sprite_priority = 0x0100
			u8[A1 + 0x2e] = 0
			u8[A2] = 0
			u8[A2 + 0x02] = 0x3c
			return
		}

		// Check if jump button pressed
		D0.u8 &= CONTROL_ABC
		if (D0.u8 != 0 && u8[0xfffffaa9] == 0)
		{
			// Jumping out of the cup
			objA1.sprite_priority = 0x0100
			u8[A1 + 0x2e] = 0
			objA0.flags2a &= ~bit
			u8[A1 + 0x2a] &= ~char.flag.ON_OBJECT
			u8[A1 + 0x2a] &= ~char.flag.PUSHING
			u8[A1 + 0x2a] |= char.flag.IN_AIR
			u8[A1 + 0x40] = 0
			if (!original_mode)
			{
				// Why not allow jump moves here?
				u8[A1 + 0x40] = Game.getSetting(SETTING_LBZ_CUPELEVATOR)
			}
			u8[A1 + 0x1e] = 0x0e
			u8[A1 + 0x1f] = 0x07
			u8[A1 + 0x20] = char.state.ROLLING
			objA1.flags2a |= char.flag.ROLLING
			objA1.flags2a &= ~char.flag.CONTROL_LOCK
			if (D0 & 0x00000400)
			{
				objA1.velocity.x = -0x200
			}
			if (D0 & 0x00000800)
			{
				objA1.velocity.x = 0x200
			}
			objA1.velocity.y = -0x480

			u8[A2] = 0
			u8[A2 + 0x02] = 0x12
			return
		}
	}

	objA1.position.x.u16 = objA0.position.x.u16
	objA1.position.y.u16 = objA0.position.y.u16 - 0x10
	D0.u8 = objA0.value26 + 0x20
	objA1.sprite_priority = (D0.u8 >= 0xc0) ? 0x0100 : 0x0280

	D0 = objA0.value26
	fn032610()
}





// In Original Mode, tube transport elevators in LBZ1 take the original game's length of time to stop spinning
// Functions taken from objects\06_lbz\lbz_tubestransport.lemon
//# address-hook(0x029eb2) end(0x029f32)
function void fn029eb2()
{
	D0.u16 = u16[A0 + 0x22] - u16[A0 + 0x3c]
	if (D0.s16 < 0)
		D0.u16 += 0x0600
	u16[A0 + 0x22] = D0.u16

	D0.u16 = u16[A0 + 0x26] - u16[A0 + 0x3c]
	if (D0.s16 < 0)
		D0.u16 += 0x0c00
	u16[A0 + 0x26] = D0.u16

	if (u16[A0 + 0x3c] < 0x0180)
	{
		u16[A0 + 0x3c] += (Game.getSetting(SETTING_LBZ_TUBETRANSPORT) && !original_mode) ? 8 : 2
	}
	else
	{
		u8[A4] += 2
		u8[A4+1] = 0
		u16[A0 + 0x3c] = 0x0180
		fn0297a2()
		u8[0xffffee39] = 1
	}

	D0.u8 = u8[A4+1]
	u8[A4+1] += 2
	LookupSinCos()
	D0.s16 >>= 6
	objA0.position.y.u16 = u16[A0 + 0x46] - D0.u16

	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	fn01dc56()
}

//# address-hook(0x029fcc) end(0x02a014)
function void fn029fcc()
{
	// Slowing down
	u16 velocity = u16[A0 + 0x3c]

	u16[A0 + 0x22] -= velocity	// Note that this affects "objA0.animation.sprite" = u8[A0 + 0x22]
	u16[A0 + 0x26] -= velocity
	if (s16[A0 + 0x22] < 0)
		s16[A0 + 0x22] += 0x600
	if (s16[A0 + 0x26] < 0)
		s16[A0 + 0x26] += 0xc00

	if (u16[A0 + 0x3c] == 8)
	{
		if (objA0.animation.sprite == 2)
		{
			u8[A4] += 2
			if (objA0.respawn_entry)
			{
				A2 = 0xffff0000 + objA0.respawn_entry
				u8[A2] &= ~0x80
				objA0.respawn_entry = 0
			}
		}
	}
	else
	{
	#if STANDALONE
		if (Game.getSetting(SETTING_LBZ_TUBETRANSPORT) && !original_mode)
		{
			// Keep rotating with velocity == 0xa0 until close enough to end state
			if (u16[A0 + 0x3c] > 0xa0)
			{
				u16[A0 + 0x3c] -= 8
			}
			else
			{
				s16 fullBrakeRestLength = (u16[A0 + 0x3c] * (u16[A0 + 0x3c] / 8 - 1)) / 2
				s16 remaining = s16[A0 + 0x26] - 0x920 - fullBrakeRestLength
				while (remaining < 0)
					remaining += 0xc00
				if (remaining <= u16[A0 + 0x3c])
					u16[A0 + 0x3c] -= 8
			}
		}
		else
	#endif
		{
			u16[A0 + 0x3c] -= 4
		}
	}

	fn02a018()
}







// Adjust the camera at the end of LBZ1 for Knuckles.
// Function taken from \scripts\level\06_lbz\level_lbz.lemon
//# address-hook(0x05410c) end(0x054144)
function void fn05410c()
{
	if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		u16 px = u16[0xffffb010]
		u16 py = u16[0xffffb014]
	//	if (px >= 0x37c0 && px <= 0x3800) // && py >= 0x0600 && py <= 0x0680)
	//	{
			// Limits the screen to this top position, to hide that there's something (namely Sonic's path) above
	//		level.vertical_wrap = 0x040c // (py < 0x0640) ? 0x040c : 0
			level.vertical_wrap = (px >= 0x3700 && camera.foreground.y.u16 >= 0x40c) ? 0x040c : 0
	//	}
	#if STANDALONE
		if (px >= 0x3800 && py >= 0x0500 && py <= 0x0580)	// usually else if
		{
			// Do the same for a horizontal stripe through the whole rest of the act
			//  -> This is needed because you can get back from the last checkpoint with Knuckles & Tails
			level.vertical_wrap = (py < 0x0540) ? 0x040c : 0
		}
	#endif
	}
}



// Do not let use new Egg Mobile behaviors during LBZ1 pre-boss in Original Mode
// Functions taken from level\06_lbz\lbz1_pre_boss_cutscene.lemon
//# address-hook(0x08cd4c) end(0x08cd58)
function void fn08cd4c()
{
	UpdateMovementStraightSimple()
	fn08d1fc()
	fn085160()

	// Added to make Egg Mobile bob up and down instead of moving in a straight line after deploying Twin Hammer's box, #contributed by mrgrassman14
	if (!original_mode)
		fn0847e6()
}

//# address-hook(0x08d1fc) end(0x08d22e)
function void fn08d1fc()
{
	if (u8[A0 + 0x28] == 0)
	{
		if (objA0.state == 0)
		{
			objA0.state = 0x20
			playSound(0x6e)
			objA0.flags2a |= 0x40
		}

		// Make Egg Mobile flash when hitting it, #contributed by mrgrassman14
		if (!original_mode)
			Boss.updateHitFlashing(3, 0x07a622, 0x07a628, 0x07a62e)

		--objA0.state
		if (objA0.state == 0)
		{
			objA0.flags2a &= ~0x40
			u8[A0 + 0x28] = u8[A0 + 0x25]
		}
	}
}




// Don't have Knuckles jump away from the bomb cutscene in Original Mode
// Function taken from level\06_lbz\lbz1_pre_boss_cutscene.lemon
//# address-hook(0x062778) end(0x0627c0)
function void fn062778()
{
	if (objA0.render_flags & render_flag.VISIBLE)
	{
		objA0.position.x.u16 += 2

		// Make Knuckles jump here, as the platforms ends inside the visible screen
		if (objA0.position.x.u16 >= 0x3c28 && !original_mode)
		{
			u16 step = (objA0.position.x.u16 - 0x3c28) / 2
			if (step == 0)
			{
				// Start jumping
				objA0.velocity.y = -0x500
			}

			objA0.position.y.u16 += objA0.velocity.y >> 8
			objA0.velocity.y += 0x38
			objA0.animation.sprite = (step & 0x02) ? 0x08 : (0x04 + (step / 4) % 4)
		}
		else
		{
			Object.AnimationProgressByLocalA1()
		}
		return
	}

	// Knuckles despawns
	u8[0xfffffaa9] = 0
	u8[0xffffb000 + 0x2e] = 0		// Reset control_flags
	u8[0xffffb04a + 0x2e] = 0
	screenmover_target.right = 0x3b60 + getScreenExtend() * 2

	// "spawnSimpleChildObjects(0x084b00)" replaced by:
	spawnSimpleChildObjects(0x084a48, 1)		// Screen mover for the right border

	move_area.bottom.target = 0x0148
	fn0851e4()

	loadPaletteLine1(0x0a929c)
	Object.TriggerUnloading()

#if STANDALONE
	Game.endSkippableCutscene()
#endif
}





// Slow the building collapse to S3&K speed in Original Mode
// Function taken from \scripts\level\06_lbz\level_lbz.lemon
//# address-hook(0x053ff8) end(0x0540ce)
function void fn053ff8()
{
	if (u16[0xffffeec4] != 0)
	{
		if (s16[0xffffeec4] < 0)
		{
			u16[0xffffeec4] = 0x01
			gfx.plane_update_routine = 0x04		// Enter vertical scroll mode
			if (!original_mode)
				verticalScrollOffsetBias = 0

			if (allocDynamicObjectStd())
			{
				objA1.update_address = 0x054164
			}

			if (!original_mode)
			{
				// We don't want the screen to move to the left from here
				move_area.left = 0x3b60
				camera.position.x.u16 = 0x3b60
			}
		}

		A1 = 0xffffa94c
		A5 = 0x23e5e0
		u32 movementSpeed = u32[A1 + 0x2c]
		u32[A1 + 0x2c] += 0x0100
		if (!original_mode)
		{
			// Collapse faster
			u32[A1 + 0x2c] += 0x0100
		}

		D1.s16 = s16[A1 + 0x30] >> 6
		++u16[A1 + 0x30]

		u8 columnsMoving = 10
		for (u8 column = 0; column < 10; ++column)
		{
			D1.u16 = (D1.u16 + 2) & 0x0e
			D4 = u16[A5 + D1.s16] << 4
			D5 = u32[A1] - D4 - movementSpeed
			D5 = (D5 << 16) + (D5 >> 16)
			if (D5.s16 <= -0x0300)
			{
				D5.u16 = -0x0300
				--columnsMoving
			}
			D5 = (D5 << 16) + (D5 >> 16)
			u32[A1] = D5
			A1 += 4
		}

		if (columnsMoving > 0)
		{
			if (((level.framecounter - 1) & 0x0f) == 0)
			{
				playSound(0xcc)
			}
		}
		else
		{
			camera.screenshake.state = 0
			u16[0xffffeec4] = 0
			gfx.plane_update_routine = 0x0c		// Leave vertical scroll mode again

			fn0540d0()

			zeroMemory(0xffffa948, 0x38)
			playSound(0x5f)
		}
	}

	// Write scroll offset data
	A1 = 0xffffa900
	A4 = 0xffffa930
	A5 = 0xffffa948
	for (u8 i = 0; i < 12; ++i)
	{
		u16 value = u16[A5] + camera.foreground.y.u16
		u16[A1] = value
		u16[A4] = value
		A1 += 4
		A4 += 2
		A5 += 4
	}
}






// Use a function that is called every frame in LBZ1 to force the camera to cooperate
// if Sonic or Tails enters a bonus stage at the last star post.
// We also add a time attack check to remove the tube from Knuckles' boss area.
//# address-hook(0x053f22) end(0x053fa2)
function void UpdateLevelTiles.LBZ1()
{
	if (original_mode)
	{
		base.UpdateLevelTiles.LBZ1()
		return
	}

	if ((time_attack == 1 || time_attack == 2) && u16[0xffffb010] > 0x3a00 &&  u16[0xffffb014] > 0x0740)	// in time attack and in the Knuckles boss area
	{
		A1 = 0xffff0078 + u16[A3 + 0x4c]
		D0.u8 = u8[A1]
		A1 = 0xffff0078 + u16[A3 + 0x50]
		u8[(A1+=1)-1] = D0.u8
		u8[(A1+=1)-1] = D0.u8
		u8[(A1+=1)-1] = D0.u8
		D0.u16 = 0x0a40		// changed from 0x0a80
		move_area.bottom.current = D0.u16
		move_area.bottom.target = D0.u16
	}
	else if ((time_attack == 1 || time_attack == 2) && u16[0xffffb010] > 0x3c00 &&  u16[0xffffb014] < 0x0300)	// in time attack and in the Sonic boss area
	{
		u8[0xffff89df] = 0xad	// set layout swap location of boss "container" object to have a chunk showing one
	}
	
	if (u16[0xffffb010] > 0x3c00 && !isMainCharacter(CHARACTER_KNUCKLES))	// if past the building collapse
	{																		// limit the maximum camera y position
		move_area.bottom.target = 0x0148
		move_area.bottom.current = move_area.bottom.target
	}

	camera.foreground.y.u16 += camera.screenshake.offset

	fn05410c()

	if (u16[0xffffeec4] == 0x55)
	{
		u16[0xffffeec4] = 0
		if (global.characters != CHARS_KNUCKLES_ALONE)
		{
			A1 = 0xffff007d + u16[A3 + 0x08]
			u8[A1] = 0xda
		}
		else
		{
			// This gets reached when the floor explodes after Knuckles' LBZ 1 boss
			A1 = 0xffff0078 + u16[A3 + 0x4c]
			D0.u8 = u8[A1]
			A1 = 0xffff0078 + u16[A3 + 0x50]
			u8[(A1+=1)-1] = D0.u8
			u8[(A1+=1)-1] = D0.u8
			u8[(A1+=1)-1] = D0.u8

		#if STANDALONE
			// Change characters to the falling animations. Original Mode is already set to the base function, so no check is needed here.
			if (u8[0xffffb020] == char.state.RUNNING || u8[0xffffb020] == char.state.STANDING)
			{
				u8[0xffffb020] = char.state.KNUX_FALLING
				u8[0xffffb021] = char.state.KNUX_FALLING
				u8[0xffffb022] = 0xcb
				u8[0xffffb023] = 1
				u8[0xffffb02a] |= char.flag.IN_AIR
			}
			if (u8[0xffffb06a] == char.state.RUNNING || u8[0xffffb06a] == char.state.STANDING)
			{
				u8[0xffffb06a] = char.state.FALLING_PANIC
				u8[0xffffb074] |= char.flag.IN_AIR
			}
		#endif
		}

		fn04ed62()
		return
	}

	D0.u16 = u16[0xffffb010]
	D1.u16 = u16[0xffffb014]
	D2.u16 = level.display_routine
	if (D2.u16 == 0)
	{
		fn23e458()
		if (D3.s16 < 0)
		{
			fn053fe2()
		}
		else
		{
			fn04ed62()
		}
		return
	}

	A1 = 0x23e5cc + D2.u16
	u16 minimum = u16[(A1+=2)-2]
	u16 maximum = u16[(A1+=2)-2]
	if (D0.u16 >= minimum && D0.u16 <= maximum)
	{
		fn053fe2()
		return
	}

	level.display_routine = 0
	call 0x053fa4 + (D2.u16 >> 1)
	fn04ed62()
}



// Adjust the camera lock for Knuckles' end-of-act results in LBZ1.
// Functions taken from bosses\boss_lbz1.lemon
//# address-hook(0x08cfc8) end(0x08d012)
function void fn08cfc8()
{
	if (original_mode)
	{
		base.fn08cfc8()
		return
	}
	D0.u8 = objA0.flags38 & 0x05
	if (D0.u8 != 0x05)
		return

	objA0.update_address = 0x08d018
	objA0.countdown_value = 0x1f
	D0.u16 = 0x0a40		// changed from 0x0a80
	screenmover_target.bottom = D0.u16
	move_area.bottom.target = D0.u16

#if !STANDALONE
	// Do not create this object, it leads to the level music starting twice
	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x085b0a
	}
#endif
	hud.dirty.timer = 0

	spawnSimpleChildObjects(0x084b12)
	spawnSimpleChildObjects(0x08d27a)
}

//# address-hook(0x08d02e) end(0x08d044)
function void fn08d02e()
{
	if (camera.position.y.u16 >= 0x0a3c)	// formerly a check for >= 0x0a7c
	{
		if (!original_mode)
		{
			// Move object a bit left, so the signpost gets spawned in a better location
			objA0.position.x.u16 -= 0x10
		}

		objA0.update_address = 0x085668
		objA0.countdown_callback = 0x085ba8
	}
}





// LBZ1 boss: if the Eggman object doesn't control the boss spawning (e.g., marathon or after a checkpoint restart), don't let the camera jump forward
// Function taken from level\06_lbz\lbz1_pre_boss_cutscene.lemon
//# address-hook(0x08cdf2) end(0x08ce30)
function void fn08cdf2()
{
	A1 = 0xffffb000
	CheckDistanceToObjectA1()
	if (D2.u16 < 0x70 && camera.position.x.u16 >= 0x3da0)
	{
		objA0.update_address = 0x08488a		// Address of "Object.CountdownAndTrigger"
		move_area.left = 0x3da0
		objA0.countdown_value = 0x1f
		objA0.countdown_callback = 0x08cd9c
	}

	D0.u16 = (objA0.position.x.u16 & 0xff80) - level.despawn_position.x
	if (D0.u16 > 0x0280)
	{
		Enemy.UnloadDelayed()
	}
}





// Load chunks, blocks, and tiles as LBZ1 transitions to LBZ2
// Function taken from level\06_lbz\level_lbz.lemon
//# address-hook(0x054200) end(0x054278)
function void fn054200()
{
	if (u16[0xffffeec6] != 0)
	{
		u16[0xffffeec6] = 0

		u32 backupD7 = D7
		u32 backupA0 = A0
		u32 backupA2 = A2
		u32 backupA3 = A3

	//	Kosinski.addToDecompressionQueue(0x3eaf04, 0xffff0000)		// Act 2 Chunks
		System.loadExternalRawData(stringformat("lbz2_chunks_s", global.act + 1), KosinskiRawdataBuffer)		// copy Secondary chunks to shared memory
		Kosinski.addToDecompressionQueue(KosinskiRawdataBuffer, 0xffff0000)									// decompress them to their proper RAM (see above)

		Kosinski.addToDecompressionQueue(0x3e5f70, 0xffff96b8)

		Kosinski.addToDMAQueue(0x3e77d0, 0x33a0)

		D7 = backupD7
		A0 = backupA0
		A2 = backupA2
		A3 = backupA3

		level.scrolling_routine += 4
	}

	fn23e756()

	A4 = 0x05433a
	A5 = 0xffffa800
	D6 = 0x20
	D5 = 2
	fn04edf6()

	A4 = 0x05433e
	A5 = 0xffffa808
	fn04f0ce()

	A4 = 0x23e598
	A5 = 0xffffa92e		// That's where the scroll offset data got written before (in "fn053ff8")
	UpdateVerticalScrollOffsetsDuringCollapse()

	UpdateScreenShake()
}





// Disable the wave effect atop the water in LBZ2 in Original Mode.
// Function taken from level\06_lbz\level_lbz.lemon
//# address-hook(0x054608) end(0x05480a)
function void UpdateBackground.LBZ2()
{
	D3.u16 = camera.screenshake.offset
	D0.u16 = camera.foreground.y.u16 - D3.u16 - 0x05f0
	D1.u16 = D0.u16
	D0 = (D0 << 16)
	D0.s32 >>= 1
	D2 = D0
	D2.s32 >>= 3
	D0 -= D2
	D2.s32 >>= 2
	D0 -= D2
	D0 >>= 16
	D2.u16 = D0.u16
	camera.background.y.u16 = D0.u16 + 0x02c0 + D3.u16
	D2.u16 -= D1.u16
	u16[0xffffeee2] = D2.u16
	D0 = u32(camera.foreground.x.u16) << 16
	if (D2.u16 != 0)
	{
		D1 = D0
		D3 = D0
		D3.s32 >>= 6
		D4 = D3
		D4.s32 >>= 3
		D3 -= D4
		if (D2.s16 <= -0x40)
		{
			A1 = 0xffffa81e
			for (u8 i = 0; i < 0x40; ++i)
			{
				u16[A1] = D1 >> 16
				if (!original_mode)
				{
					// Add a nice moving waves effect
					s16 distance = (0x1200 / (0x80 - i))
					u16[A1] += (lookupSin(distance * 10 - level.framecounter) / s32(distance))
				}
				A1 += 2
				D1 -= D3
			}
		}
		else
		{
			A1 = 0xffffa91e
			for (u8 i = 0; i < 0x40; ++i)
			{
				A1 -= 2
				u16[A1] = D1 >> 16
				if (!original_mode)
				{
					// Add a nice moving waves effect; except if underwater, there is another waves effect already
					s16 distance = (0x1200 / (0x80 - i))
					u16[A1] += (lookupSin(distance * 10 - level.framecounter) / s32(distance))
				}
				D1 -= D3
			}

			if (D2.s16 < 0x40)
			{
				A1 = 0xffffa89e
				A5 = A1
				A6 = 0x26f460
				D1.u16 = D2.u16
				if (D1.s16 >= 0)
				{
					D3.u16 = 0x40 - D1.s16
					D3.u16 <<= 6
					A6 += D3.s16
					D3 = 0
					while (D1.s16 > 0)
					{
						D3.u8 = u8[A6]
						u16[A1] = u16[A5 + D3.s16 * 2]
						A1 += 2
						++A6
						--D1.s16
					}
				}
				else
				{
					D1.s16 = -D1.s16

					D3.u16 = 0x40 - D1.s16
					D3.u16 <<= 6
					A6 += D3.s16
					D3 = 0
					while (D1.s16 > 0)
					{
						A1 -= 2
						D3.u8 = u8[A6]
						u16[A1] = u16[A5 + D3.s16 * 2]
						++A6
						--D1.s16
					}
				}
			}
		}
	}

	A1 = 0xffffa9e2
	D1 = D0.s32 >> 1
	D3 = D0.s32 >> 4
	camera.background.x.u16 = D1 >> 16
	u16[A1-=2] = D1 >> 16
	D1 -= D3
	u16[0xffffeee4] = D1 >> 16
	u16[A1-=2] = D1 >> 16
	A5 = 0x23ef4e
	D1 -= D3
	D4 = 4

	while (D4.s16 >= 0)
	{
		D1 -= D3
		u16 value = D1 >> 16
		D5.u16 = u16[(A5+=2)-2]
		while (D5.s16 >= 0)
		{
			u16[A1-=2] = value
			u16[A1-=2] = value
			u16[A1-=2] = value
			u16[A1-=2] = value
			--D5.s16
		}
		--D4.s16
	}

	D3 = 0x3f
	if (D2.s16 >= 0)
	{
		D3.u16 -= D2.u16
	}

	D1 = (D1 << 16) + (D1 >> 16)
	while (D3.s16 >= 0)
	{
		u16[A1-=2] = D1.u16
		--D3.s16
	}

	A1 = 0xffffa800
	A5 = 0x23ef34
	D1 = D0
	D1.s32 >>= 6
	D3 = D1
	D4 = u32[0xffffa9e2]
	u32[0xffffa9e2] += 0x0e00
	D5 = 0x0c

	while (D5.s16 >= 0)
	{
		D6.u16 = u16[(A5+=2)-2]
		D1 += D4
		u16[A1 + D6.s16] = D1 >> 16
		D1 += D3
		--D5.s16
	}

	D1 = D0
	D1.s32 >>= 4
	D3 = D1
	D3.s32 >>= 1
	A1 = 0xffffa81a
	u16[(A1+=2)-2] = D1 >> 16
	D1 += D3
	D1 = (D1 << 16) + (D1 >> 16)
	u16[(A1+=2)-2] = D1.u16

	bool goto0547b6 = true
	if (D2.s16 < 0)
	{
		D4 = 0x3f
		D4.u16 += D2.u16

		if (D4.s16 >= 0x30)
		{
			D4.u16 -= 0x30
		}
		else
		{
			while (D4.s16 >= 0)
			{
				u16[(A1+=2)-2] = D1.u16
				--D4.s16
			}
			goto0547b6 = false
		}
	}
	else
	{
		D4 = 0x0f
	}

	if (goto0547b6)
	{
		D5 = 0x17
		while (D5.s16 >= 0)
		{
			u16[(A1+=2)-2] = D1.u16
			u16[(A1+=2)-2] = D1.u16
			--D5.s16
		}

		D1 = (D1 << 16) + (D1 >> 16)
		D1 += D3
		D1 = (D1 << 16) + (D1 >> 16)

		while (D4.s16 >= 0)
		{
			u16[(A1+=2)-2] = D1.u16
			--D4.s16
		}
	}

	D0 = 0x3f
	D0.u16 -= D2.u16
	if (D0.s16 >= 0)
	{
		D0.u16 = min(D0.u16 + 0x60, 0xdf)

		A1 = 0xffffa9de
		A5 = 0x04f878
		D1.u16 = (level.framecounter >> 1) & 0x7e
		A5.u16 += D1.u16

		while (D0.s16 >= 0)
		{
			D3.u16 = u16[A5-=2]
			A1 -= 2
			u16[A1] += D3.u16
			--D0.s16
		}
	}
}






// Implement a palette line fix coming to a future version of AIR.
// Function taken from bosses\boss_lbz2_1.lemon
//# address-hook(0x074098) end(0x0740de)
function void fn074098()
{
	A1 = 0xffff0000 + u16[A0 + 0x46]
	if (u8[A1 + 0x2a] & 0x80)
	{
		objA0.update_address = 0x0856d0
		objA0.flags2a |= 0x80

	if (!original_mode)		// Fix #contributed by Legobouwer to base AIR
		objA0.sprite_attributes = (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE2 | 0x0425)
	else
		objA0.sprite_attributes = (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE1 | 0x0425)

		objA0.velocity.x = u16[0x0740e4 + objA0.subtype2c]
		objA0.velocity.y = -0x200
		fn08594e()

		A1 = 0xffffb04a
		objA1.flags2a &= ~char.flag.CONTROL_LOCK
	}

	DrawObject()
}





// Allow Tails to run into the water after the first LBZ2 boss in Original Mode.
// Function taken from level\06_lbz\lbz2_mid_boss_cutscene.lemon
function void LBZ2MidBossCutscene.stopTailsFromSuicide()
{
	if (original_mode)
		return
	
	if (camera.position.x.u16 >= 0x3bc8)
	{
		u32 backupA0 = A0
		A0 = 0xffffb04a
		RespawnTails()
		A0 = backupA0
	}
	else if (u16[0xffffb04a + 0x10] >= 0x3bb0)
	{
		u16[0xffffb04a + 0x10] = 0x3bb0
		u16[0xffffb04a + 0x14] = min(u16[0xffffb04a + 0x14], 0x0630)
		u16[0xffffb04a + 0x18] = 0
		u16[0xffffb04a + 0x1c] = 0
		tails.ai_routine = 0x0a
	}
}








// Replicate the S3&K visual quirk of Knuckles flying the Eggmobile facing backwards in Original Mode.
// Function taken from level\06_lbz\lbz2_mid_boss_cutscene.lemon
//# address-hook(0x08d53e) end(0x08d556)
function void fn08d53e()
{
	A1 = 0xffffb000
	D0 = u8[A1 + 0x38]

	// Special treatment for Knuckles
	if (D0 == CHARACTER_KNUCKLES && !original_mode)
	{
		u8[A1 + 0x22] = 0x56
		D0 = 0
	}
	else
	{
		u8[A1 + 0x22] = u8[0x08d55c + D0.s16]
	}

	A2 = 0xffff0000 + u16[0x08d55e + D0.s16 * 2]
	u8[A2] = 0
	UpdatePlayer1SpritePatterns()
}




// Remove the Big Arms fight from Original Mode.
// Function taken from bosses\boss_lbz2_2.lemon
//# address-hook(0x0734fa) end(0x07360c)
function void fn0734fa()
{
	if (u8[A0 + 0x28] != 0)
		return

	if (boss.remaining_hits == 0)
	{
		// Note: This code in S3A is at 0x050194

		AddScoreForBossEnemy_NoHudDirty()

		objA0.animation.sprite = 5
		objA0.flags2a |= 0x40
		objA0.flags2a |= 0x80
		u8[A0 + 0x28] = 0
		D0.u16 = u16[A0 + 0x3c]
		objA0.flags38 |= (1 << D0.u8)

		// "spawnChildObjects(0x083fee)" replaced by:
		spawnChildObject(0x083d84, 0x00, 0, 0)

		u8[A1 + 0x2c] = 0x04

	#if STANDALONE
		// Knuckles can fight Sonic's bosses as well (using Tails)
		//  -> So don't check for him, but check the camera position
		bool isKnucklesFight = (camera.position.y.u16 < 0x0500)
		if (isKnucklesFight)
		{
			// Spawn Big Arms for Knuckles
			objA0.update_address = 0x073054
		}
		else if ((Game.getSetting(SETTING_LBZ_BIGARMS) && !original_mode) || time_attack >= 3)
		{
			// Spawn Big Arms for Sonic/Tails
			objA0.update_address = 0x073056
		}
		else
		{
			// Skip Big Arms
			objA0.update_address = 0x072b18
		}
	#else
		// For Knuckles, spawn Big Arms now
		objA0.update_address = isMainCharacter(CHARACTER_KNUCKLES) ? 0x073054 : 0x072b18
	#endif
		return
	}

	if (objA0.state == 0)
	{
		objA0.value3a = objA0.base_state
		objA0.base_state = 0x06
		objA0.state = 0x20
		objA0.flags2a |= 0x40

		playSound(0x6e)

		D0.u16 = objA0.velocity.y << 1
		if (abs(D0.s16) <= 0x0800)
		{
			objA0.velocity.y = D0.u16
		}

		if (boss.remaining_hits == 1 || boss.remaining_hits == 5)
		{
			if (boss.remaining_hits != 5)
			{
				objA0.flags38 |= 0x08
			}

			D0.u16 = u16[A0 + 0x3c]
			objA0.flags38 |= (1 << D0.u8)
			++u16[A0 + 0x3c]
			objA0.base_state = 0x08
			u8[A0 + 0x40] = 0x0f
			objA0.flags2a |= 0x20

			// "spawnChildObjects(0x0737f8)" replaced by:
			spawnChildObject(0x073192, 0x00, -16, 0)
			spawnChildObject(0x073192, 0x02, 16, 0)
		}
	}

	Boss.updateHitFlashing(2, 0x073612, 0x073616)

	--objA0.state
	if (objA0.state == 0)
	{
		objA0.base_state = objA0.value3a
		u16[0xfffffc22] = 0x0eee
		u8[A0 + 0x28] = u8[A0 + 0x25]
		objA0.flags2a &= ~0x40
	}
}



// AIR fixes in version after v22.09.10.00: remove visually broken object from Big Arms on defeat and do not reset character state upon final hit.
// We leave the object and character state reset in Original Mode.
// Function taken from bosses\boss_lbz2_3.lemon
//# address-hook(0x074fd2) end(0x07508c)
function void fn074fd2()
{
	if (objA0.base_state < 0x08 || u8[A0 + 0x28] > 0)
		return

	D0.u8 = boss.remaining_hits
	if (D0.u8 == 0)
	{
		objA0.update_address = 0x085668
		objA0.countdown_callback = 0x0746d8
		AddScoreForBossEnemy()

		// "spawnSimpleChildObjects(0x083fee)" replaced by:
		spawnSimpleChildObjects(0x083d84, 1)
		if (_equal())
		{
			u8[A1 + 0x2c] = 0x04
		}
		// This resets the character state, but is unnecessary, #contributed by TheMushrunt
		if (u8[A0 + 0x30] == 0 && original_mode)
		{
			stopCharacterWinPose(0xffffb000)
		}
	#if !STANDALONE
		// This object looks broken and is unnecessary, so leave it out in S3AIR, fix #contributed by Legobouwer
		// "spawnChildObjects(0x075186)" replaced by:
		spawnChildObject(0x074e12, 0x00, 0, 16)

	#else
		// Release main character if he was grabbed (can happen if second character makes the final hit)
		if (u8[0xffffb000 + 0x2e] & 0x81)
			u8[0xffffb000 + 0x2e] &= ~0x81

		bool isKnucklesFight = (camera.position.y.u16 < 0x0500)
		if (!isKnucklesFight)
		{
			// Change in standalone: No music fade-out to (very brief) level music before level results
			objA0.update_address = 0x08566a
		}
	#endif
		return
	}

	if (objA0.state == 0)
	{
		if (objA0.base_state == 0x0a)
		{
			u16[A0 + 0x3a] = 0x08
		}
		objA0.state = 0x3c
		playSound(0x6e)

		A1 = 0xffff0000 + u16[A0 + 0x44]
		u8[A1 + 0x28] = 0
	}

	objA0.flags2a |= 0x40
	Boss.updateHitFlashing(6, 0x075092, 0x07509e)

	--objA0.state
	if (objA0.state == 0)
	{
		objA0.flags2a &= ~0x40
		u8[A0 + 0x28] = u8[A0 + 0x25]
		A1 = 0xffff0000 + u16[A0 + 0x44]
		objA1.collision_attributes = (collision.flag.THREAT | collision.size.32x16)
	}
}




// Do not stop the explosion sound effects during the LBZ2 results in Original Mode.
// Function taken from level\06_lbz\lbz2_post_boss_cutscene.lemon
//# address-hook(0x072b46) end(0x072b94)
function void fn072b46()
{
	--objA0.countdown_value
	if (objA0.countdown_value < 0)
	{
		A1 = 0xffffb000
		if ((u8[A1 + 0x2a] & 0x80) == 0 && (u8[A1 + 0x2a] & char.flag.IN_AIR) == 0 && u8[A1 + 0x05] < 0x06)
		{
			objA0.update_address = 0x072b96
			StartCharacterWinPose()
			level.results_done = 0

			if (allocDynamicObjectStd())
			{
				// Level results
				objA1.update_address = 0x02dad0
			}

			if (allocDynamicObjectStd())
			{
				// Win pose for Tails
				objA1.update_address = 0x072cfa
			}

			if (!original_mode)
			{
				objA0.flags38 |= 0x20	// Stop explosions (and especially the sound effects) now already
				Game.onZoneActCompleted(global.zone_act.apparent)
			}
		}
	}
}



// In Original Mode, do not try to fade back to normal sky in the Sonic/Tails LBZ2 ending cutscene, as no Big Arms means it was never changed
// Function taken from level\06_lbz\lbz2_post_boss_cutscene.lemon
//# address-hook(0x072e2e)
function void fn072e2e()
{
	--objA0.countdown_value
	if (objA0.countdown_value >= 0)
		return

	u8[0xfffffa88] |= 0x01
	objA0.value39 = 0
	objA0.countdown_value = 0

	// "spawnChildObjects(0x07380c)" replaced by:
	spawnChildObject(0x072e9e, 0x00, 0, 0)
	spawnChildObject(0x072e9e, 0x02, -16, 40)
	spawnChildObject(0x072e9e, 0x04, -112, 0)
	spawnChildObject(0x072e9e, 0x06, -72, 40)
	spawnChildObject(0x072e9e, 0x08, 24, 16)
	spawnChildObject(0x072e9e, 0x0a, -36, -8)
	spawnChildObject(0x072e9e, 0x0c, -80, 28)

#if STANDALONE
	if ((Game.getSetting(SETTING_LBZ_BIGARMS) && !original_mode) || time_attack >= 3)
	{
		// Go into another state before unloading, to lighten up the sky again
		u16[A0 + 0x48] = 0
		objA0.update_address = 0x072e30
	}
	else
#endif
	{
		Object.TriggerUnloading()
	}
}




// If Tails has finished Knuckles' LBZ2 boss, make sure the correct falling sprites show in the next cutscene
// Functions taken from bosses\boss_lbz2_3.lemon
//# address-hook(0x07490a) end(0x074950)
function void fn07490a()
{
	if (u16[0xffffb000 + 0x10] >= 0x4510)
	{
		objA0.update_address = 0x074952

		A1 = 0xffffb000
		objA0.position.x.u16 = objA1.position.x.u16
		objA0.position.y.u16 = objA1.position.y.u16
		u8[A1 + 0x2e] = (control_flag.DISABLE_INTERACTION | control_flag.DISABLE_ANIMATION | control_flag.DISABLE_UPDATE)
		objA1.animation.sprite = 0x8c		// Set Sonic's grabbed sprite
		if (isMainCharacter(CHARACTER_TAILS) && !original_mode)
			objA1.animation.sprite -= 3		// Tails' falling animation is located in different sprite IDs
	#if STANDALONE
		if (!original_mode)
		{
			// This makes AI Tails jump
			control.player1 = 0x1010		// CONTROL_B, CONTROL_B
		}
	#endif
		UpdatePlayer1SpritePatterns()

		objA0.animation.frame = 0
		objA0.animation.timer = 0x0a
		objA0.velocity.x = 0x200
		objA0.velocity.y = -0x400
	}
}

//# address-hook(0x074952) end(0x0749a8)
function void fn074952()
{
	MoveWithGravity20()
	A1 = 0xffffb000
	objA1.position.x.u16 = objA0.position.x.u16
	objA1.position.y.u16 = objA0.position.y.u16

	--objA0.animation.timer
	if (s8(objA0.animation.timer) < 0)
	{
		objA0.animation.timer = 0x0a
		++objA0.animation.frame
		objA1.animation.sprite = (objA0.animation.frame & 0x01) ? 0x8c : 0x8d		// Set Knuckles' falling sprites
		if (isMainCharacter(CHARACTER_TAILS) && !original_mode)
			objA1.animation.sprite -= 3		// Tails' falling animation is located in different sprite IDs
		UpdatePlayer1SpritePatterns()
	}

	if (u16[0xffffb000 + 0x14] < level.bossarea.top + 0x0200)
		return

	TriggerNextZone(0x0700)		// Mushroom Hill Zone
	UnloadObject()
}






// In Original Mode, revert the MHZ pulley to its normal speed and enable the debug cheat.
// Functions taken from objects\07_mhz\mhz_elevator.lemon
//# address-hook(0x03e472) end(0x03e4e6)
function void fn03e472()
{
	objA0.value3a = 0
	A3 = 0xffff0000 + u16[A0 + 0x46]
	D0.u16 = u16[A0 + 0x34] + u16[A3 + 0x14] - 6
	objA0.position.y.u16 = D0.u16
	fn03e4ec()

	D1 = 0x18
	if (objA0.value3a != 0)
	{
		if (u8[A3 + 0x2c] != 0 && u16[A0 + 0x34] < 0x40)
		{
			u16[A0 + 0x34] += 4
			D1 = 0x1c
		}
	}
	else
	{
		if (u16[A0 + 0x34] != 0)
		{
			u16[A0 + 0x34] -= 4
			D1 = 0x14
		}
	}

	D0.u16 = u16[A0 + 0x36]
	u16[A3 + D0.s16] = u16[A0 + 0x34]
	if (Game.getSetting(SETTING_MHZ_ELEVATOR) && !original_mode)
	{
		// Much faster movement of the elevator
		u16[A3 + D0.s16] *= 2
	}

	objA0.animation.sprite = 3
	if (D1.u16 <= u16[A0 + 0x34])
	{
		D1.u16 += 0x10
		objA0.animation.sprite = (D1.u16 <= u16[A0 + 0x34]) ? 7 : 2
	}

	D0.u16 = objA0.countdown_value
	DrawOrUnloadObjectByD0()
}

//# address-hook(0x03e508) end(0x03e596)
function void fn03e508()
{
	if (u8[A2] == 0)
	{
		fn03e682()
		return
	}

	if ((objA1.render_flags & render_flag.VISIBLE) && u8[A1 + 0x05] < 0x04 && debug_mode.state == 0)
	{
		// Check if jump button pressed
		D1.u16 = D0.u16 & CONTROL_ABC
		if (D1.u8 == 0)
		{
			// AI Tails should better not be able to use the pulleys outside of Original Mode
			if (A1 == 0xffffb04a && tails.control_counter == 0 && !original_mode)
				D0.u16 &= ~0x0202
			fn03e5f2()
			return
		}

		u8[A1 + 0x2e] = 0
		u8[A2] = 0
		u8[A2 + 0x02] = 0x12

		D0.u16 &= 0x0f00	// Any direction held?
		if (D0.u16 != 0)
		{
			u8[A2 + 0x02] = 0x3c
		}
		if (D0 & 0x0400)	// CONTROL_LEFT held
		{
			objA1.velocity.x = -0x200
		}
		if (D0 & 0x0800)	// CONTROL_RIGHT held
		{
			objA1.velocity.x = 0x200
		}

		objA1.velocity.y = -0x380
		u8[A1 + 0x1e] = 0x0e
		u8[A1 + 0x1f] = 0x07
		objA1.state = char.state.ROLLING
		objA1.flags2a |= (char.flag.IN_AIR | char.flag.ROLLING)
		u8[A1 + 0x40] = 0x01
	}
	else
	{
		u8[A1 + 0x2e] = 0
		u8[A2] = 0
		u8[A2 + 0x02] = 0x3c
	}
}

//# address-hook(0x03e598) end(0x03e5e6)
function void fn03e598()
{
	// Check for cheat (disabled in standalone)
	if (original_mode)
	{
		if (A1 == 0xffffb000 && D0.u8 != 0)
		{
			D1 = u8[A0 + 0x40]
			if (D0.u8 == u8[0x03e5e8 + D1.s16])
			{
				++u8[A0 + 0x40]
				D1.u8 = u8[0x03e5e9 + D1.s16]
				if (D1.u8 != 0)
					return

				D1 = 0
				D1.u16 = -0x20
				A4 = 0xffff0000 + D1.u16
				if (u16[A4 - 0x32] == 0)
				{
					if (u16[A4] == 0)
					{
						D0.u16 = D1.u16
						u8[A0 + 0x40] = 0
						return
					}
					A4 += 2
				}

				D1 = 1
				u8[A4] = D1.u8
				u8[A4+1] = D1.u8
				D1.u16 = D0.u16
				playSound(SFX_RING)

				D0.u16 = D1.u16
			}
			u8[A0 + 0x40] = 0
		}
	}
}








// Display control inputs when hanging from a pulley in MHZ.
// Function taken from objects\07_mhz\mhz_elevator.lemon
//# address-hook(0x03e5f2) end(0x03e652)
function void fn03e5f2()
{
	if (A1 != 0xffffb04a && u16[A0 + 0x34] != 0x40 && display_inputs && !original_mode)		// A1 not sidekick Tails. Offset 0x34 increments by 0x04 each frame down is held, up to a maximum of 0x40.
	{																						// This implementation is incomplete; the 0x40 maximum is lowered if the pulley device is near/at the ceiling.
		Renderer.drawCustomSprite("@input_icon_button_down", getScreenWidth()/2, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	}

	base.fn03e5f2()
}





// Revert MHZ swing behaviors in Original Mode.
// Functions taken from objects\07_mhz\mhz_swingvine.lemon
//# address-hook(0x022a5c) end(0x022ad4)
function void fn022a5c()
{
	A3 = 0xffff0000 + u16[A0 + 0x3c]
	u8 angle = u8[A3 + 0x26]
	if (u8[A1 + 0x2a] & char.flag.FACING_LEFT)
		angle = -angle
	u16 offset = (u8(angle + 0x10) >> 5) * 2

	u8[A1 + 0x20] = 0
	u8[A1 + 0x22] = u8[0x022ad8 + offset]
	D2.s16 = s8[0x022ae8 + offset]
	D3.s16 = s8[0x022ae9 + offset]
	if (u8[A1 + 0x2a] & char.flag.FACING_LEFT)
		D2.s16 = -D2.s16

	A3 = 0xffff0000 + u16[A0 + 0x3c]
	D0.u8 = (u8[A3 + 0x26] + 4) & 0xf8
	LookupSinCos()
	s16 px = (8 - D0.s16) >> 4
	s16 py = (8 + D1.s16) >> 4

#if STANDALONE	// This STANDALONE check *should* look for !original_mode, but there's a single frame per angle of the vine's handle breaking off if set this way. Leave alone for now.
	// Set character rotation and offset
	u8[A1 + 0x26] = (u8[A3 + 0x26] + 4) & 0xf8

	D2.s16 = px * 0x16 / 0x10
	D3.s16 = py * 0x16 / 0x10
#endif
	objA1.position.x.u16 = u16[A3 + 0x10] + D2.u16 + px
	objA1.position.y.u16 = u16[A3 + 0x14] + D3.u16 + py

	fn022a28()
}

//# address-hook(0x022af8) end(0x022b9c)
function void fn022af8()
{
	if (u8[A2 + 0x02] != 0)
	{
		--u8[A2 + 0x02]
		if (u8[A2 + 0x02] != 0)
			return
	}

	D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + 0x10
	D1.u16 = objA1.position.y.u16 - objA0.position.y.u16
	u16 maxDiffY = 0x28
#if STANDALONE
	if (!original_mode)
	{
		// Always grab the handle if fast enough, no matter its current angle / position
		maxDiffY = 0x38
	}
#endif
	if (D0.u16 < 0x20 && D1.u16 < maxDiffY)
	{
		if (objA1.velocity.x < 0x0400 && D1.u16 >= 0x18)
			return

		if (u8[A1 + 0x2e] == 0 && u8[A1 + 0x05] < 0x04 && debug_mode.state == 0)
		{
			u8[A2] = 0x01
			if (objA1.velocity.x >= 0x0400)
			{
				u8[A2] = 0x81
				playSound(SFX_GRAB)
			}

			objA1.velocity.x = 0
			objA1.velocity.y = 0
			u16[A1 + 0x1c] = 0
			objA1.position.x.u16 = objA0.position.x.u16
			objA1.position.y.u16 = objA0.position.y.u16 + 0x14
			objA1.state = char.state.HANGING
			u8[A1 + 0x3d] = 0
			u8[A1 + 0x2e] = 0x03
			objA1.render_flags &= ~render_flag.FLIP_Y
		}
	}
}





// Have Sonic and Tails use some Knuckles code if they start in Knuckles' area in MHZ1.
// Function taken from level\07_mhz\level_mhz.lemon
//# address-hook(0x054ab6) end(0x054b1c)
function void InitLevelTiles.MHZ1()
{
	u16[0xffffeee8] = 0
	u8[0xfffff7c1] = 0
	fn054b80()

	if (global.lock_on_state != 0)
	{
		if (checkpoint.number == 0)
		{
			if (level.start_location == 1 || (!isMainCharacter(CHARACTER_KNUCKLES) && original_mode))
			{
				A1 = 0xffffb000
				objA1.position.x.u16 = 0x0718
				objA1.position.y.u16 = 0x062d
				D2.u16 = 0x0680
				D3.u16 = 0x05cd
			}
			else
			{
				D2.u16 = 0x0560
				D3.u16 = 0x0948
			}

			camera.position.x.u16 = D2.u16
			camera.foreground.x.u16 = D2.u16
			camera.position.y.u16 = D3.u16
			camera.foreground.y.u16 = D3.u16
		}
		else if (checkpoint.number == 1)
		{
			if (level.start_location == 2 || (isMainCharacter(CHARACTER_KNUCKLES) && original_mode))
			{
				D2.u16 = 0x0680
				camera.position.x.u16 = D2.u16
				camera.foreground.x.u16 = D2.u16
			}
		}
	}

	Level.GetCameraPosition()
	Level.InitialTilesFill()
}





// In palettes_weather.lemon, UpdateLevelTiles.MHZ2() also handles setting a chunk for the entrance to the MHZ2 winter area.



// Allow Knuckles' palette to load for the red switch at the start of MHZ2
// Function taken from maingame\cutscene_knuckles.lemon
function void CutsceneKnuckles.loadPalette()
{
#if STANDALONE
	// Do not load Knuckles' cutscene palette if using EXTENDED_CHARACTER_PALETTES, fix #contributed by TheMushrunt
//	if (!EXTENDED_CHARACTER_PALETTES || original_mode)		// In AIR v24.06.18.0, the Knuckles palette is always loaded
#endif
	{
		loadPaletteLine1(0x066912)
	}

	// When using EXTENDED_CHARACTER_PALETTES:
	//  - the (potentially modded) Knuckles palette gets used instead
	//  - it is already loaded at this point
}



function void MHZ2_CustomSprites()
{
	if (rain_intensity && palette_set >= 2)	// is weather enabled? All these checks do not need the palette_set variable checked, as original palette users are already sent to the base function
	{
		#if STANDALONE
		if (u16[0xfffffc62] == 0x028c)	// test for the autumn palette and create rain if so
		{
			D0.u8 = (level.framecounter.low & 0x3F)  * 2	// rain is 64 by 64 (0x3F by 0x3F), position is moved by 1/2 pixel down and 2 left each frame
			if (rain_intensity == 1)
				Renderer.drawCustomSprite("rain1_light", getScreenExtend() - 80 - D0.u8, 2 * D0.u8, 0x00, 0, 0x1100)	// usually ends in 0x1100
			else if (rain_intensity == 2)
				Renderer.drawCustomSprite("rain1", getScreenExtend() - 80 - D0.u8, 2 * D0.u8, 0x00, 0, 0x1100)	// usually ends in 0x1100
			else
				Renderer.drawCustomSprite("rain1_heavy", getScreenExtend() - 80 - D0.u8, 2 * D0.u8, 0x00, 0, 0x1100)	// usually ends in 0x1100
		}																								// Different values for the first nybble make the rain render above low plane foreground and above sprites,
																										// as stated in the Oxygen handbook.
		else if (u16[0x0fffffcd0] == 0x0EA8 && palette_set >= 2)	// test for the winter palette and create snow if so
		{
			D0.u8 = ((level.framecounter.low + (camera.position.x.u16/4)) & 0x3F) // * 2	// rain is 64 by 64 (0x3F by 0x3F), position is moved by 1/2 pixel down and 2 left each frame
			D1.u8 = ((level.framecounter.low - (camera.position.y.u16/8)) & 0x7F) // * 2	// rain is 64 by 64 (0x3F by 0x3F), position is moved by 1/2 pixel down and 2 left each frame
			{
			if (rain_intensity == 1)
				Renderer.drawCustomSprite("snow0_light", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
			else if (rain_intensity == 2)
				Renderer.drawCustomSprite("snow0", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
			else
				Renderer.drawCustomSprite("snow0_heavy", getScreenExtend() - 80 - (2 * D0.u8), D1.u8 / 2, 0x00, 0, 0x1100)
			}																								// Different values for the first nybble make the rain render above low plane foreground and above sprites,
		}																									// as stated in the Oxygen handbook.
		#endif
	}
}





// Load the correct MHZ2 boss area layout and trigger coordinates based on game mode: Original Mode or Redesigned Mode.
// Function taken from level\07_mhz\level_mhz.bin
//# address-hook(0x055250) end(0x0552f4)
function void fn055250()
{
	if (u16[0xffffb000 + 0x14] >= 0x0500)
	{
		fn054c68()
		fn04f2f6()

		u16[0xffffeec8] = (D0.u16 + getScreenHeight()) & level.height.tilemask
		u16[0xffffeeca] = 0x0f
		level.scrolling_routine += 4

		fn0552fc()
		return
	}

	u16 minY = 0x0418
	if (original_mode)
		minY = 0x0420

	if (u16[0xffffb000 + 0x14] > minY && u8[0xffffb000 + 0x2a] & char.flag.IN_AIR)
	{
		fn0554b8()
		fn0552e4()
		return
	}

	push(A3)
	push(A2)
	push(A0)
	push(D7)

	copyMemory(0xffff8000, 0x0a8044, 0x1000)
	if (original_mode)
		System.loadExternalRawData("MHZ2BossLayout_Orig", 0xffff8000)

	Kosinski.addToDecompressionQueue(0x1a30e8, 0xffff2280)	// MHZ2 boss area chunks
	Kosinski.addToDecompressionQueue(0x1a1b36, 0xffff9b28)

	Kosinski.addToDMAQueue(0x1a1eb6, 0x4440)

	D7 = pop()
	A0 = pop()
	A2 = pop()
	A3 = pop()

	level.scrolling_routine += 8
	fn055312()
}






// Revert to the original S3&K "jerky" camera movement on monkey bars in Original Mode.
// Function taken from objects\08_fbz\fbz_monkeybars.lemon
//# address-hook(0x03aa7e) end(0x03ac36)
function void fn03aa7e()
{
	if (u8[A2] == 0)
	{
		fn03ac86()
		return
	}

	if ((objA1.render_flags & render_flag.VISIBLE) && debug_mode.state == 0 && u8[A1 + 0x05] < 0x04)
	{
		// Check if jump button pressed
		D0.u8 &= CONTROL_ABC
		if (D0.u8 == 0)
		{
			while (true)
			{
				if (u8[A2 + 0x04] == 0)
				{
					D2.u16 = objA0.value3e - 0x10
					if (D0 & 0x0400)		// CONTROL_LEFT held
					{
						objA1.flags2a |= char.flag.FACING_LEFT
						D1.u16 = objA1.position.x.u16 - objA0.position.x.u16 + D2.u16
						if (D1.u16 != 0)
						{
							u8[A2 + 0x04] = 4
							u8[A2 + 0x02] = 1
						}
					}
					if (D0 & 0x0800)		// CONTROL_RIGHT held
					{
						objA1.flags2a &= ~char.flag.FACING_LEFT
						D1.u16 = objA1.position.x.u16 - objA0.position.x.u16 + D2.u16
						if (D1.u16 != D2.u16 * 2)
						{
							u8[A2 + 0x04] = 4
							u8[A2 + 0x02] = 0
						}
					}

					D0.u8 = u8[A1 + 0x2a] & char.flag.FACING_LEFT
					objA1.render_flags &= ~(render_flag.FLIP_X | render_flag.FLIP_Y)
					objA1.render_flags |= D0.u8
					objA1.position.y.u16 = objA0.position.y.u16 + 0x12
					if (u8[A2 + 0x04] == 0)
					{
						break
					}
				}

				--u8[A2 + 0x06]
				if (s8[A2 + 0x06] >= 0)
					break

				u8[A2 + 0x06] = 7
				D1 = u8[A2 + 0x04]
				if (D1.u8 == 2)
				{
					playSound(SFX_GRAB)
				}
				--D1.u16
				u8[A1 + 0x20] = (D1.u16 == 0) ? char.state.HANGING : char.state.RUNNING

				D1.u8 += u8[A2 + 0x08]
				u8[A1 + 0x22] = u8[0x03ac38 + D1.s16]
				D1.s16 = s8[0x03ac40 + D1.s16]
				if (u8[A2 + 0x02] != 0)
				{
					D1.s16 = -D1.s16
				}
			#if STANDALONE
				if (A1 == 0xffffb000 && !original_mode)
					globalCameraOffsetX -= D1.s16
			#endif
				objA1.position.x.u16 += D1.s16

				--u8[A2 + 0x04]
				if (u8[A2 + 0x04] != 0)
					break

				fn03ac48()

				u8[A2 + 0x06] = 0
				u8[A2 + 0x08] ^= 0x04

				if ((D0.u16 & 0x0c00) == 0)
					break
			}
		}
		else
		{
			u8[A2] = 0
			u8[A2 + 0x02] = 0x12

			D0.u16 &= 0x0f00		// Any direction held?
			if (D0.u16 != 0)
			{
				u8[A2 + 0x02] = 0x3c
			}
			if (D0 & 0x0400)		// CONTROL_LEFT held
			{
				objA1.velocity.x = -0x200
			}
			if (D0 & 0x0800)		// CONTROL_RIGHT held
			{
				objA1.velocity.x = 0x200
			}
			objA1.velocity.y = -0x380
			u8[A1 + 0x1e] = 0x0e
			u8[A1 + 0x1f] = 0x07
			u8[A1 + 0x20] = char.state.ROLLING
			u8[A1 + 0x22] = 0x96
			u8[A1 + 0x27] = 0
			objA1.flags2a |= (char.flag.IN_AIR | char.flag.ROLLING)
			objA1.flags2a &= ~(char.flag.ON_OBJECT | char.flag.CONTROL_LOCK)
			u8[A1 + 0x2e] = 0
			u8[A1 + 0x40] = 1
			u16[A1 + 0x42] = 0
		}

		D0 = u8[A1 + 0x22]
		u32 backupA2 = A2
		SetCharacterSpritePatterns()
		A2 = backupA2
	}
	else
	{
		fn03ab24()
	}
}







// Do not enforce the Tails hitbox adjustment on FBZ magnetic pendulums if a mod is using a larger character.
// Function taken from objects\08_fbz\fbz_magneticpendulum.lemon
//# address-hook(0x03d78c) end(0x03d902)
function void fn03d78c()
{
	if (objA0.base_state != 0)
	{
		D0.u16 = u16[A0 + 0x44]
		if (D0.u16 != 0)
		{
			A1 = 0xffff0000 + D0.u16
			u8[A1 + 0x05] = 0xff
		}
		UnloadObject()
		return
	}

	A1 = 0xffff0000 + u16[A0 + 0x46]
	D0.u8 = u8[A1 + 0x26]
	LookupSinCos()

	D1 = (D1 << 16)
	D1.s32 >>= 1
	D3 = D1
	D3.s32 >>= 3
	D1 -= D3
	D1 = (D1 << 16) + (D1 >> 16)
	D1.u16 += u16[A0 + 0x12]
	objA0.position.x.u16 = D1.u16

	D0 = (D0 << 16)
	D0.s32 >>= 1
	D3 = D0
	D3.s32 >>= 3
	D0 -= D3
	D0 = (D0 << 16) + (D0 >> 16)
	D0.u16 += u16[A0 + 0x16]
	objA0.position.y.u16 = D0.u16

	if (u8[A1 + 0x2f] == 0)
	{
		A2 = 0xffffb000
		if (u8[A2 + 0x2e] == 0 && u8[A2 + 0x05] < 0x04 && debug_mode.state == 0)
		{
			bool goto03d8e2 = false
			if (s8[A1 + 0x2c] < 0)
			{
				if (s16[A2 + 0x18] >= 0)
				{
					D0.u16 = objA0.position.x.u16 - 8
					if (D0.u16 <= u16[A2 + 0x10])
					{
						D0.u16 += 0x18
						if (D0.u16 >= u16[A2 + 0x10])
						{
							D0 = 0x1d
							D1 = 0x21
							if ((u8[A2 + 0x2a] & char.flag.ROLLING) == 0)
							{
								D0 = 0x22
								D1 = 0x26
								if (isMainCharacter(CHARACTER_TAILS) && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") && System.getGlobalVariableValueByName("DAGE_characterName") != "Ray")
								{
									D0 = 0x1e
									D1 = 0x22
									if (Mods.isModActive("Chaos The Impostor") && System.getGlobalVariableValueByName("ChaosForm") != 2)
									{
										D0 = 0x22
										D1 = 0x26
									}
								}
							}

							if (u8[A1 + 0x2e] != 0)
							{
								--D0.u16
								D0.s16 = -D0.s16
								--D1.u16
								D1.s16 = -D1.s16

								u32 tmp = D0
								D0 = D1
								D1 = tmp
							}

							D2.u16 = objA0.position.y.u16 - D0.u16
							if (D2.u16 >= u16[A2 + 0x14])
							{
								D2.u16 = objA0.position.y.u16 - D1.u16
								if (D2.u16 <= u16[A2 + 0x14])
								{
									D0.u16 = u16[A2 + 0x18]
									goto03d8e2 = true
								}
							}
						}
					}
				}
			}
			else
			{
				if (s16[A2 + 0x1a] < 0)
				{
					D0.u16 = objA0.position.y.u16 + 8
					if (D0.u16 >= u16[A2 + 0x14])
					{
						D0.u16 -= 0x18
						if (D0.u16 <= u16[A2 + 0x14])
						{
							D0 = 0x1d
							D1 = 0x21
							if ((u8[A2 + 0x2a] & char.flag.ROLLING) == 0)
							{
								D0 = 0x22
								D1 = 0x26
								if (isMainCharacter(CHARACTER_TAILS) && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") && System.getGlobalVariableValueByName("DAGE_characterName") != "Ray")
								{
									D0 = 0x1e
									D1 = 0x22
									if (Mods.isModActive("Chaos The Impostor") && System.getGlobalVariableValueByName("ChaosForm") != 2)
									{
										D0 = 0x22
										D1 = 0x26
									}
								}
							}

							if (u8[A1 + 0x2e] != 0)
							{
								--D0.u16
								D0.s16 = -D0.s16
								--D1.u16
								D1.s16 = -D1.s16

								u32 tmp = D0
								D0 = D1
								D1 = tmp
							}

							D2.u16 = objA0.position.x.u16 - D0.u16
							if (D2.u16 >= u16[A2 + 0x10])
							{
								D2.u16 = objA0.position.x.u16 - D1.u16
								if (D2.u16 <= u16[A2 + 0x10])
								{
									D0.s16 = -s16[A2 + 0x1a]
									goto03d8e2 = true
								}
							}
						}
					}
				}
			}

			if (goto03d8e2)
			{
				D0 = u32(D0.u16) * 0x51
				D0 >>= 8
				if (u8[A1 + 0x2e] != 0)
				{
					D0.s16 = -D0.s16
				}
				u8[A1 + 0x2f] = 0xff
				u16[A1 + 0x30] = D0.u16
				u8[A1 + 0x32] = 0xff
				u8[A2 + 0x2e] = 0x01
			}
		}
	}

	DrawObject()
}






//# address-hook(0x039f7e) end(0x03a0ae)
function void fn039f7e()
{
	bool isInside = (objA0.flags2a >> D6.u8) & 1
	u8 bit = (1 << D6.u8)

	if (!isInside)
	{
		D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + D4.u16
		if (D0.u16 < D5.u16)
		{
			if (!Game.getSetting(SETTING_FBZ_ENTERCYLINDER) || original_mode)
			{
				D0.u16 = objA1.position.y.u16 - objA0.position.y.u16 + 0x50
				if (D0.u16 < 0x18)
				{
					u8[A2 + 0x02] = 0x28
				}
			}

			if (u8[A2 + 0x02] != 0)
			{
				--u8[A2 + 0x02]
				return
			}

			D0.u16 = objA0.position.y.u16 + 0x3c
			D2.u16 = objA1.position.y.u16
			D1.u16 = D2.u16 + s8[A1 + 0x1e] + 4
			if (D0.u16 <= D1.u16)
			{
				D0.u16 -= D1.u16
				if (D0.u16 >= 0xfff0)
				{
					if (u8[A1 + 0x05] < 0x06 && debug_mode.state == 0)
					{
						D2.u16 += D0.u16
						D2.u16 += 0x03
						objA1.position.y.u16 = D2.u16
						LetSonicClimbOnObject()
						u8[A1 + 0x2d] = 0x80
						u16[A1 + 0x20] = char.state.RUNNING2
						u8[A2] = 0
						u8[A2 + 0x02] = 0
						if (u16[A1 + 0x1c] == 0)
						{
							u16[A1 + 0x1c] = 0x01
						}
					}
				}
			}
		}
	}
	else
	{
		if ((u8[A1 + 0x2a] & char.flag.IN_AIR) == 0)
		{
			D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + D4.u16
			if (D0.u16 < D5.u16)
			{
				if ((u8[A1 + 0x2a] & char.flag.ON_OBJECT) == 0)
					return

				D0.u8 = u8[A2]
				LookupSinCos()
				D1.s32 = s32(D1.s16) * 0x2800
				D1 = (D1 << 16) + (D1 >> 16)
				D2.u16 = objA0.position.y.u16 + D1.u16
				D1 = u8[A1 + 0x1e]
				D1.u16 -= 0x13
				D2.u16 -= D1.u16
				objA1.position.y.u16 = D2.u16
				D0.u8 = u8[A2]
				u8[A1 + 0x27] = D0.u8
				u8[A2] += 0x04
				if (u16[A1 + 0x1c] == 0)
				{
					u16[A1 + 0x1c] = 0x01
				}
				return
			}
		}
		else
		{
			D0.u8 = u8[A2] + 0x20
			if (D0.u8 < 0x40)
			{
				objA1.velocity.y >>= 1
			}
			else
			{
				objA1.velocity.y = 0
			}
		}

		u8[A1 + 0x2a] &= ~char.flag.ON_OBJECT
		objA0.flags2a &= ~bit
		u8[A1 + 0x30] = 0
		u8[A1 + 0x31] = 0x04
		u8[A1 + 0x2a] |= char.flag.IN_AIR
		u8[A1 + 0x2d] = 0
	}
}




// Remove rolling flag in FBZ vertical cylinders to prevent running out of speed and falling down.
// Functions taken from objects\08_fbz\fbz_staticcylinder.lemon
//# address-hook(0x03a314) end(0x03a466)
function void fn03a314()
{
	u8 bit = (1 << D6.u8)

	D0.u16 = abs(objA1.groundspeed)
	if (D0.u16 >= 0x0400 && (u8[A1 + 0x2a] & char.flag.IN_AIR) == 0)
	{
		if (u32[A2] != 0)
		{
			fn03a480()
			return
		}

		D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + 0xc0
		if (D0.s16 >= 0 && D0.s16 < 0x0180)
		{
			if ((u8[A1 + 0x2a] & char.flag.ON_OBJECT) == 0)
				return

			if (objA0.subtype2c != 0)
			{
				if (u8[A2 + 0x04] == 0)
				{
					if (D0.u16 >= 0xc0 && objA1.groundspeed >= 0)
					{
						u16[A2] = D0.u16 - 0xc0
						u16[A2 + 0x02] = 0
						objA1.render_flags |= (render_flag.FLIP_X | render_flag.FLIP_Y)

						fn03a480()
						return
					}
				}
				else
				{
					if (D0.u16 < 0xc0 && objA1.groundspeed < 0)
					{
						u16[A2] = D0.u16 + objA0.value42 - 0xc0
						u16[A2 + 0x02] = 0
						u16[A2 + 0x06] = -s16[A0 + 0x40]
						objA1.render_flags &= ~(render_flag.FLIP_X | render_flag.FLIP_Y)

						fn03a480()
						return
					}
				}
			}

			D0.u16 = (D0.u16 >> 5) & 0x0f
			D1.s8 = s8[0x03a468 + D0.u16]
			objA1.animation.sprite = u8[0x03a474 + D0.u16]		// Player characters' corkscrew diagonal running sprites
			D2.u16 = objA0.position.y.u16 + u16[A2 + 0x06] + D1.s8
			D1 = u8[A1 + 0x1e]
			D1.u16 -= 0x13
			D2.u16 -= D1.u16
			objA1.position.y.u16 = D2.u16
			u8[A1 + 0x20] = 0
			if (!original_mode)
				objA1.flags2a &= ~char.flag.ROLLING

			D0 = objA1.animation.sprite
			u32 backupA2 = A2
			SetCharacterSpritePatterns()
			A2 = backupA2
		}
		else
		{
			u8[A1 + 0x2a] &= ~char.flag.ROLLING
			u8[A1 + 0x1e] = u8[A1 + 0x44]
			u8[A1 + 0x1f] = u8[A1 + 0x45]
			objA1.state.both = char.state.RUNNING2
			u8[A1 + 0x2e] = 0
			u8[A1 + 0x2a] &= ~char.flag.ON_OBJECT
			objA0.flags2a &= ~bit
		}
	}
	else
	{
		objA1.velocity.x >>= 1
		u8[A1 + 0x2a] |= char.flag.IN_AIR
		u8[A1 + 0x2a] &= ~char.flag.ROLLING
		u8[A1 + 0x1e] = u8[A1 + 0x44]
		u8[A1 + 0x1f] = u8[A1 + 0x45]
		objA1.state.both = char.state.RUNNING2
		u8[A1 + 0x2e] = 0
		u8[A1 + 0x2a] &= ~char.flag.ON_OBJECT
		objA0.flags2a &= ~(u8(1) << D6.u8)
		u8[A1 + 0x27] = 0xc0
		u8[A1 + 0x30] = 0			// "char.rotation.x.count"
		u8[A1 + 0x31] = 0x04		// "char.rotation.x.speed"
	}
}

//# address-hook(0x03a480) end(0x03a542)
function void fn03a480()
{
#if STANDALONE
	if (debug_mode.state)
	{
		u8[A2] = 0
		return
	}
#endif

	D0.s32 = s32(objA1.groundspeed) << 8
	u32[A2] += D0
	if (s32[A2] < 0)
	{
		u32[A2] = 0
		u8[A2 + 0x04] = 0
		u16[A2 + 0x06] = -s16[A0 + 0x40]

		objA1.render_flags |= render_flag.FLIP_X
		objA1.render_flags &= ~render_flag.FLIP_Y

		fn03a314()
		return
	}

	D0.u16 = u16[A2]
	if (D0.u16 >= objA0.value42)
	{
		u32[A2] = 0
		u8[A2 + 0x04] = render_flag.FLIP_X
		u16[A2 + 0x06] = u16[A0 + 0x40]

		objA1.render_flags &= ~(render_flag.FLIP_X | render_flag.FLIP_Y)

		fn03a314()
		return
	}

	D2.u16 = objA1.position.x.u16
	D0.u16 = u16[A2]
	D0.u16 >>= 1
	LookupSinCos()
	D0.s32 = s32(D0.s16) * 0x6800
	D0 = (D0 << 16) + (D0 >> 16)
	D0.u16 += objA0.position.x.u16
	objA1.position.x.u16 = D0.u16
	D0.u16 -= D2.u16
	D0.s16 <<= 8
	objA1.velocity.x = D0.u16
	D2.u16 = objA1.position.y.u16
	D0.u16 = u16[A2] >> 2
	D0.u16 += u16[A2 + 0x06] + objA0.position.y.u16
	objA1.position.y.u16 = D0.u16
	D0.u16 -= D2.u16
	D0.s16 <<= 8
	objA1.velocity.y = D0.u16

	D0 = (u16[A2] >> 1) & 0xff
	if (objA1.groundspeed < 0)
	{
		D0.s8 = -D0.s8
	}
	D0.u16 = D0 / 0x0b
	objA1.animation.sprite = u8[0x03a548 + D0.u16]		// Player characters' corkscrew vertical running sprites
	u8[A1 + 0x20] = 0
	if (!original_mode)
		objA1.flags2a &= ~char.flag.ROLLING
	D0 = objA1.animation.sprite
	SetCharacterSpritePatterns()
}




// Draw a ship exterior overlay at the start of FBZ1 if new visuals are enabled
// and display hanging inputs
// Function takes from level\08_fbz\level_fbz.lemon
//# address-hook(0x0528be) end(0x0528c2)
function void UpdateLevelScrolling.FBZ1()
{
	FBZ1_CustomSprites()

	call 0x0528c6 + level.scrolling_routine
}

function void FBZ1_CustomSprites()
{
	// Level start
	if (u16[0xffffb010] < 0x0188 && palette_set >= 2 && !original_mode)
	{
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0000 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0080 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0180 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0200 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0280 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0300 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0380 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0480 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0500 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0580 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_wall", 0x0180 - camera.foreground.x.u16, 0x0600 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		
		Renderer.drawCustomSprite("fbz_tunneloverlay", 0x0180 - camera.foreground.x.u16, 0x0100 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9f01)
		Renderer.drawCustomSprite("fbz_tunnellights", 0x0180 - camera.foreground.x.u16, 0x0100 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x8000)
		Renderer.drawCustomSprite("fbz_tunneloverlay", 0x0180 - camera.foreground.x.u16, 0x0400 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9f01)
		Renderer.drawCustomSprite("fbz_tunnellights", 0x0180 - camera.foreground.x.u16, 0x0400 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x8000)

		Renderer.drawCustomSprite("fbz_exterior", 0x0000 - camera.foreground.x.u16, 0x0480 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_exterior", 0x0080 - camera.foreground.x.u16, 0x0480 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
		Renderer.drawCustomSprite("fbz_exterior", 0x0100 - camera.foreground.x.u16, 0x0480 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x9800)
	}

	else if (palette_set < 2 || original_mode)	// Use the original ROM hack's opening chunks if the visuals are set that way
	{
		u32[0xffff8550] = 0x2222220e
		u32[0xffff85d8] = 0x0000006a
		u32[0xffff8660] = 0x0000006a
	}

	// End of first outdoor area for Knuckles
	if (((u16[0xffffb010] < 0x1000 && s16[0xffffb014] < 0x01a0) || (u16[0xffffb010] < 0x1240 && s16[0xffffb014] < 0x0140)) && u8[0xffffb020] != char.state.DIED && palette_set >= 2 && !original_mode)
	{
		Renderer.addSpriteMaskWorld(0x1090, 0x1b0, 0x00c0, 0x0030, 0xcf00, 7)	// hide a Technosqueek that gets drawn in front of the chunks
	//	if (u32[0xffff80ac] == 0x888989a1)
	//	{
	//		Renderer.addSpriteMaskWorld(0x1090, 0x1b0, 0x00c0, 0x0030, 0xcf00, 7)	// hide a Technosqueek that gets drawn in front of the chunks
	//		call 0x0528c6 + level.scrolling_routine
	//		return
	//	}

		u32[0xffff80ac] = 0x888989a1

		u32[0xffff8134] = 0x888989a1

		u32[0xffff81b8] = 0x80acacad
		u32[0xffff81bc] = 0x888989a1
		
		u32[0xffff8240] = 0x88272727
		u32[0xffff8244] = 0x888989a1

		u32[0xffff82c8] = 0x88272727
		u32[0xffff82cc] = 0x888989a1

		u32[0xffff8350] = 0x88272727
		u32[0xffff8354] = 0x88898978

		u32[0xffff83d8] = 0x88272727
		u32[0xffff83dc] = 0x88898900

		fillPlaneA_Default(camera.position.x.u16, camera.position.y.u16, getScreenWidth(), getScreenHeight())
	}
	else if (palette_set >= 2  && !original_mode && u8[0xffffb020] != char.state.DIED)	// && u32[0xffff80ac] == 0x888989a1
	{
	//	if (u32[0xffff80ac] == 0x6aa1a1a1)
	//	{
	//		call 0x0528c6 + level.scrolling_routine
	//		return
	//	}

		u32[0xffff80ac] = 0x6aa1a1a1

		u32[0xffff8134] = 0x6aa1a1a1

		u32[0xffff81b8] = 0x0e707049
		u32[0xffff81bc] = 0x6aa1a1a1
		
		u32[0xffff8240] = 0x13a5a515
		u32[0xffff8244] = 0x6aa1a1a1

		u32[0xffff82c8] = 0xda1010b7
		u32[0xffff82cc] = 0x2b7819a1

		u32[0xffff8350] = 0xe7787817
		u32[0xffff8354] = 0x1f2f1678

		u32[0xffff83d8] = 0x1a500052
		u32[0xffff83dc] = 0x55565300

		fillPlaneA_Default(camera.position.x.u16, camera.position.y.u16, getScreenWidth(), getScreenHeight())
	}

	// Display hanging inputs
	if (u16[0xffffb010] > 0x0b60 && u16[0xffffb010] < 0x0ba0 && u16[0xffffb014] > 0x0840 && u16[0xffffb014] < 0x0880 && display_inputs && !original_mode && !global.game.paused && !level.trigger01)
	{
		Renderer.drawCustomSprite("@input_icon_button_down", getScreenWidth()/2 - 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
		Renderer.drawCustomSprite("@input_icon_button_A", getScreenWidth()/2 + 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	}
	else if (u16[0xffffb010] > 0x1b20 && u16[0xffffb010] < 0x1b60 && u16[0xffffb014] > 0x7c0 && u16[0xffffb014] < 0x0800 && display_inputs && !original_mode && !global.game.paused && !level.trigger02)
	{
		Renderer.drawCustomSprite("@input_icon_button_down", getScreenWidth()/2 - 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
		Renderer.drawCustomSprite("@input_icon_button_A", getScreenWidth()/2 + 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	}

	// Display pipe along which piston moves and floor end tapering where chunks meet walls without it
	if (!original_mode)
	{
		Renderer.drawCustomSprite("fbz_pipe256", 0x1400 - camera.foreground.x.u16, 0x07b0 - camera.foreground.y.u16, 0, 0, 0x2100)
		Renderer.drawCustomSprite("fbz_floorend", 0x0680 - camera.foreground.x.u16, 0x0580 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x0c60 - camera.foreground.x.u16, 0x0800 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
	}
}









// Adjust initial FBZ1 background
//# address-hook(0x052ca2) end(0x052cc2)
function void fn052ca2()
{
	if (u16[0xffffeed6] == 0)
	{
		if (D1.u16 > 0x0000)	// originally < 0x0640
		{
			fn052a2a()
		}
		else
		{
			fn052cc4()
		}
	}
	else
	{
		if (D1.u16 < 0x0000)	// originally > 0x0640
		{
			fn052a2a()
		}
		else
		{
			u16[0xffffeed6] = 0
			D0 = 4
			D6 = 0
			fn052cd4()
		}
	}
}

//# address-hook(0x052c2e) end(0x052c3c)
function void fn052c2e()
{
	#if STANDALONE
	if (!original_mode)
	{
		// Immediately refresh the background with a blue sky, to avoid visual glitch in widescreen
		//  -> TODO: Rather load the actual background content here
		for (u16 address = 0xe000; address <= 0xf000; address += 2)
			setVRAM(address, 0x6092)
	}
	#endif

	u8[0xffffeed6] = 0xff
	D0 = 0x10
	D6.u16 = 0x03f0
	A1 = 0x052dd0
	fn052c42()
}


















// Remove FBZ1 area where Knuckles can make the background flicker (original bug)
// and replace it with a way to fix the starting background.
// We will not revert this in Original Mode, as all it does is create a PSE concern.
//# address-hook(0x052c74) end(0x052c96)
function void fn052c74()
{
	if (u16[0xffffeed6] == 0)
	{
		if (D0.u16 > 0x0300)	// D0 holds the character's x position
		{
			fn052a2a()
			return
		}

		fn052c98()
	}
	else
	{
		if (D0.u16 < 0x0300)
		{
			fn052a2a()
			return
		}

		u16[0xffffeed6] = 0
		D0 = 0x08
		D6.u16 = 0xf0
		fn052cd4()
	}
}






// Updates FBZ door code and standard button code to preserve door open/close status in Non-Original Mode
// and to use original speed in Original Mode.
// Functions taken from objects\08_fbz\fbz_screwdoor.lemon
//# address-hook(0x03bbee) end(0x03bd14)
function void fn03bbee()
{
	if (original_mode)
	{
		base.fn03bbee()
		return
	}

	D0.u16 = (objA0.subtype2c >> 4) & 0x07
	objA0.state = D0.u8
	D0.u16 &= 0x06
	objA0.box_size.x = u8[0x03bbe8 + D0.s16]
	objA0.box_size.y = u8[0x03bbe9 + D0.s16]
	objA0.mapping_offset = 0x03bd8e
	objA0.sprite_attributes = 0x23d2
	objA0.render_flags |= 0x04
	objA0.sprite_priority = 0x0280
	u16[A0 + 0x44] = objA0.position.x.u16
	u16[A0 + 0x46] = objA0.position.y.u16

	Object.animationUpdate(0x03bd5e)
	
	// new block of code to preserve door status
	A3 = 0xfffff7e0 + (objA0.subtype2c & 0x0f)
	if (u8[A3] != 0)
	{
		objA0.update_address = 0x03bc92
		fn03bc92()
		return
	}


	if (s8[A0 + 0x2c] < 0)
	{
		if (objA0.respawn_entry)
		{
			A2 = 0xffff0000 + objA0.respawn_entry
			if (u8[A2] & 0x01)
			{
				objA0.position.y.u16 += 0x40
				objA0.update_address = 0x03bcf2
				fn03bcf2()
				return
			}
		}

		objA0.update_address = 0x03bd1a
		fn03bd1a()
	}
	else
	{
		objA0.update_address = 0x03bc72
		fn03bc72()
	}
}

// Function taken from objects\level\button.lemon
function void Button.checkIfPressed()
{
	if (original_mode)
	{
		base.Button.checkIfPressed()
		return
	}

	// This points to one of "level.trigger00" ... "level.trigger0f"
	A3 = 0xfffff7e0 + (objA0.subtype2c & 0x0f)

	if ((objA0.flags2a & (object.flag.P1_ON_OBJECT | object.flag.P2_ON_OBJECT)) == 0)
	{
		// Button is released
		if ((objA0.subtype2c & 0x10) == 0 && global.zone != 0x04)	// global zone check is new for FBZ doors
		{
			u8[A3] &= ~(1 << D3.u8)
		}
		objA0.animation.sprite = 0
	}
	else
	{
		// Button is pressed
		if (u8[A3] == 0)
		{
			playSound(SFX_CLICK)
		}
		u8[A3] |= (1 << D3.u8)
		objA0.animation.sprite = 1
	}
}

//# address-hook(0x03bc92)
function void fn03bc92()
{
	u8 change = 1
	if (Game.getSetting(SETTING_FBZ_SCREWDOORS) && !original_mode)
	{
		// Only make the short types faster
		change = ((objA0.subtype2c & 0x20) || (objA0.subtype2c & 0x40) == 0) ? 2 : 1
	}
	objA0.flags2e += change
	if (objA0.flags2e >= 0x80)
	{
		objA0.update_address = 0x03bcf2
	}

	D0 = objA0.flags2e
	if (objA0.subtype2c & 0x10)
	{
		D0.s16 = -D0.s16
	}

	if (objA0.subtype2c & 0x20)
	{
		objA0.position.x.u16 = u16[A0 + 0x44] + (D0.s16 >> 1)
	}
	else if (objA0.subtype2c & 0x40)
	{
		objA0.position.x.u16 = u16[A0 + 0x44] + D0.s16
	}
	else
	{
		objA0.position.y.u16 = u16[A0 + 0x46] + (D0.s16 >> 1)
	}

	Object.animationUpdate(0x03bd5e)

	fn03bcf2()
}




// If below the square FBZ blocks that form bridges after coming up from underneath them, don't make the blocks solid.
// This helps with floor collision oddities and with ensuring Knuckles can climb the walls they touch.
// Function taken from objects\08_fbz\fbz_platformblock.lemon
//# address-hook(0x03c3ee) end(0x03c410)
function void fn03c3ee()
{
	D1 = objA0.box_size.x + 11
	D2 = objA0.box_size.y
	D3.u16 = D2.u16 + 1
	D4.u16 = objA0.position.x.u16
	if (!(objA0.subtype2c == 0x14 && objA0.value32 == 0x40))	// subtype of sealing bridge floor, and value32 is the distance away from extended position (retracted is usually 0x40)
		fn01dc56()	// SolidObjectFull routine, which is always called in the original object code

	D0.u16 = u16[A0 + 0x44]
	DrawOrUnloadObjectByD0()
}





// Adjust FBZ1 boss camera locations for wide resolutions
// Function taken from scripts\bosses\boss_fbz1.lemon
//# address-hook(0x06ef14) end(0x06ef30)
function void fn06ef14()
{
	u16 widthDelta = 0
	if (getScreenWidth() > 400)
		widthDelta = (getScreenWidth() - 400) / 4

	objA0.base_state = 0x04
	screenmover_target.right = move_area.right
	move_area.left = u16[A0 + 0x3a] - widthDelta
	move_area.right = u16[A0 + 0x3a] + 0x80 + widthDelta
}



// Undo FBZ1 eye fix in Original Mode
// Function taken from scripts\bosses\boss_fbz1.lemon
//# address-hook(0x06f7a6) end(0x06f7be)
function void fn06f7a6()
{
	objA0.countdown_value = u16[0x06f7c0 + objA0.subtype2c]
	A1 = 0x06f7c6 + objA0.subtype2c * 2
	D1.u16 = u16[(A1+=2)-2]
	u16[A0 + D1.s16] = u16[(A1+=2)-2]
#if STANDALONE
	if (!original_mode)
		u16[A0 + D1.s16] += 2 	// Add 2 to make Gapsule's eye windows symmetrically aligned, #contributed by mrgrassman14
#endif
}



// Draw signpost in front of FBZ1 boss only in Revisited Mode.
// Also set signpost to launch upward when first touched in a Sonic 2 act.
// Function taken from objects\basics\signpost.lemon
//# address-hook(0x0837d8) end(0x08382e)
function void fn0837d8()
{
	if (SetupObjectAttributesSlotted(0x083b04))
		return

	if (u8[0xffffb000 + 0x0a] & 0x80)
		u8[A0 + 0x0a] |= 0x80

	level.signpost.address = A0.u16

	objA0.hitbox_extends.x = 0x18
	objA0.hitbox_extends.y = 0x1e
	u32[A0 + 0x30] = isMainCharacter(CHARACTER_KNUCKLES) ? 0x083b58 : 0x083b4a
	if (!unlock_act)
		objA0.position.y.u16 = camera.position.y.u16 - 0x20
	else
	{
		objA0.velocity.y = -0x380	// + 0x0c to advance one frame if needed
		// Set starting appearance to Eggman
		objA0.animation.sprite = 3
		objA0.animation.frame = 8
	}

	// Move signpost in front of Gapsule in FBZ 1; #contributed by iCloudius
	if (global.zone_act == 0x0400 && !original_mode)
		objA0.sprite_priority = 0x180
	playSound(0xb8)

	// "spawnChildObjects(0x083b2e)" replaced by:
	spawnChildObject(0x083a24, 0x00, 0, 24)
}




// Import a graphics fix from post-v24.02.02.0 AIR.
// Once a version after this one becomes the minimum requirement, this code can be removed.
// Function taken from objects\o8_fbz\fbz_capsule.lemon
//# address-hook(0x089dee) end(0x089e6a)
function void fn089dee()
{
	D1.u16 = objA0.subtype2c
	D0 = objA0.subtype2c & 0x06
	D2.u16 = u16[0x089e6c + D0.u16]
	objA0.velocity.y = D2.u16
	objA0.value3e = D2.u16
	// objA0.sprite_attributes = u16[0x089e74 + (D0.u16 & 0x02)]
	D0.u16 &= 0x02
	objA0.sprite_attributes = u16[0x089e74 + D0.u16]

	D2 = global.zone * 2
	A1 = 0x02c7ba + D2.u16
	D0.u16 >>= 1
	D0.u16 = u8[A1 + D0.u16] * 8

	A2 = 0x02c7ea
	objA0.mapping_offset = u32[A2 + D0.u16 + 4]
	D1.u16 <<= 2
	objA0.countdown_value = D1.u16

	A1 = 0xffff0000 + u16[A0 + 0x46]
	objA0.velocity.x = (objA0.position.x.u16 < objA1.position.x.u16) ? -0x200 : 0x200
	objA0.render_flags &= ~render_flag.FLIP_X
	if (objA0.velocity.x < 0)
	{
		objA0.render_flags |= render_flag.FLIP_X
	}
}




// Adjust camera on the outdoor section on the lowest route of FBZ2
// to prevent sight of interior tiles, and display hanging inputs
//# address-hook(0x052e34) end(0x052e40)
function void UpdateLevelTiles.FBZ2()
{
	FBZ2_CustomSprites()

	// New for the outdoor section
	if (!original_mode)
	{
		if (camera.position.x.u16 >= 0x0d00 && camera.position.x.u16 <= 0x1180 && camera.position.y.u16 >= 0x0a00)	// If outdoors and not leaving,
			move_area.left = 0x0d00																					// prevent seeing within left wall,
		else if (camera.position.x.u16 <= 0x1500)																	// else if still early in the level,
			move_area.left = 0x0000																					// allow returning to the start.
	}

	camera.foreground.y.u16 += camera.screenshake.offset
	call 0x052e44 + s16[0xffffeec0]
}

function void FBZ2_CustomSprites()
{
	// Add floor end tapering where chunks meet walls without it
	if (!original_mode && (u8[0xffff8af8] != 0xb2))		// layout check to make sure we're not drawing indoor floor art while outside
	{
		Renderer.drawCustomSprite("fbz_floorend", 0x0980 - camera.foreground.x.u16, 0x0800 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x0ae0 - camera.foreground.x.u16, 0x0800 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x0d00 - camera.foreground.x.u16, 0x0a80 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x05e0 - camera.foreground.x.u16, 0x0280 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x1460 - camera.foreground.x.u16, 0x0a00 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x16e0 - camera.foreground.x.u16, 0x0480 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x1760 - camera.foreground.x.u16, 0x0900 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x1e60 - camera.foreground.x.u16, 0x0480 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
		Renderer.drawCustomSprite("fbz_floorend", 0x2300 - camera.foreground.x.u16, 0x0a80 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xa001)
	}

	if (!original_mode && u8[0xffff89ac] == 0x89 && global.game.paused)		// if we handle this here when not paused, the lights disappear one frame too late
	{
		Renderer.drawCustomSprite("fbz_tunnellights", 0x2380 - camera.foreground.x.u16, 0x0b00 - camera.foreground.y.u16, 0, 0, 0x8000)
		Renderer.drawCustomSprite("fbz_tunnellights", 0x2400 - camera.foreground.x.u16, 0x0b00 - camera.foreground.y.u16, 0, 0, 0x8000)
		Renderer.drawCustomSprite("fbz_tunnellights", 0x2410 - camera.foreground.x.u16, 0x0b00 - camera.foreground.y.u16, 0, 0, 0x8000)
		Renderer.drawCustomSprite("fbz_door", 0x2580 - camera.foreground.x.u16, 0x0b40 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO | SPRITE_FLAG_FLIP_X, 0x9f01)
		u32 rectColor = ((u16[0xfffffc4e] & 0x0000f) * 0x12000000) + ((u16[0xfffffc4e] & 0x000f0) * 0x12000)+ ((u16[0xfffffc4e] & 0x00f00) * 0x12) + 0xff	// rearrange the indoor purple background wall color data for a drawRect
		Renderer.drawRect(0x2570 - camera.foreground.x.u16, 0x0b40 - camera.foreground.y.u16, 16, 64, rectColor, 0x9eff, 0, 1)
	}

	// Display inputs for dropping from overhead bars
	if (u16[0xffffb010] > 0x0f60 && u16[0xffffb010] < 0x0fa0 && u16[0xffffb014] > 0x840 && u16[0xffffb014] < 0x0880 && display_inputs && !original_mode && !global.game.paused && !level.trigger02)
	{
		Renderer.drawCustomSprite("@input_icon_button_down", getScreenWidth()/2 - 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
		Renderer.drawCustomSprite("@input_icon_button_A", getScreenWidth()/2 + 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	}
	else if (u16[0xffffb010] > 0x17e0 && u16[0xffffb010] < 0x1820 && u16[0xffffb014] > 0x840 && u16[0xffffb014] < 0x0880 && display_inputs && !original_mode && !global.game.paused && !level.trigger06)
	{
		Renderer.drawCustomSprite("@input_icon_button_down", getScreenWidth()/2 - 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
		Renderer.drawCustomSprite("@input_icon_button_A", getScreenWidth()/2 + 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	}
	else if (u16[0xffffb010] > 0x1f60 && u16[0xffffb010] < 0x1fa0 && u16[0xffffb014] > 0x780 && u16[0xffffb014] < 0x07c0 && display_inputs && !original_mode && !global.game.paused && !level.trigger0b)
	{
		Renderer.drawCustomSprite("@input_icon_button_down", getScreenWidth()/2 - 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
		Renderer.drawCustomSprite("@input_icon_button_A", getScreenWidth()/2 + 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	}

	if (global.game.paused)		// a sprite mask for the laser miniboss is hidden when the game is paused
		Renderer.addSpriteMaskWorld(0x2aa0, 0x05e0, 0x2be0 - 0x2aa0, 0x0600 - 0x05e0, 0x9f80, 1)
}




// Add a new outdoor area to FBZ2.
// Function taken from level\08_fbz\level_fbz.lemon
//# address-hook(0x053234) end(0x053240)
function void fn053234()
{
	D0.u16 = u16[0xffffb000 + 0x10]
	D1.u16 = u16[0xffffb000 + 0x14]
	call 0x053244 + level.display_routine

	if (u16[0xffffb010] > 0x2280 && u16[0xffffb010] < 0x2880 && !original_mode)
		FBZ2.newRouteArtSwap()
}

function void FBZ2.newRouteArtSwap()
{
	bool skyBackground = ((u16[0xffffb010] > 0x2300 && u16[0xffffb014] > 0x0b00) || (u16[0xffffb010] > 0x2540 && u16[0xffffb010] < 0x2840 && u16[0xffffb014] > 0x0a00) || (u16[0xffffb010] >= 0x2840 && camera.position.y.u16 > 0x0918))
	bool outdoorChunks = ((u16[0xffffb010] > 0x2540 && u16[0xffffb010] <= 0x2578 && u16[0xffffb014] > 0x0a00 && u16[0xffffb014] < 0x0b40) || (u16[0xffffb010] > 0x2578 && u16[0xffffb010] < 0x2840 && u16[0xffffb014] > 0x0a00) || (u16[0xffffb010] >= 0x2840 && u16[0xffffb014] > 0x0a72))

	u32 chunkAddress
	if (outdoorChunks && u32[0xffff89ac] != 0x8989f089)
	{
		u32[0xffff89ac] = 0x8989f089
		u32[0xffff89b0] = 0x898989ab
		u32[0xffff89b4] = 0x89ab8989

		u32[0xffff8a2a] = 0x8989f083
		u32[0xffff8a2e] = 0x838383ab
		u32[0xffff8a32] = 0x89ab8989

		u32[0xffff8aa8] = 0x8989f000
		u32[0xffff8aac] = 0x00e0008c
		u32[0xffff8ab0] = 0xb8ab8989

		u32[0xffff8b26] = 0x8989f000
		u32[0xffff8b2a] = 0x00ff0000
		u32[0xffff8b2e] = 0x31ab8989

		u32[0xffff8ba4] = 0xdcdcdd00
		u32[0xffff8ba8] = 0x00000022
		u32[0xffff8bac] = 0x22ab8989

		u32[0xffff8c22] = 0x8989f022
		u32[0xffff8c26] = 0x00000000
		u32[0xffff8c2a] = 0x00ab8989
	}
	else if (!outdoorChunks && u32[0xffff89ac] != 0x10101021)
	{
		u32[0xffff89ac] = 0x10101021
		u32[0xffff89b0] = 0xa1a1a1a1
		u32[0xffff89b4] = 0xc86aa1a1

		u32[0xffff8a2a] = 0xa1a11878
		u32[0xffff8a2e] = 0x78787819
		u32[0xffff8a32] = 0xc86aa1a1

		u32[0xffff8aa8] = 0xa1a16b00
		u32[0xffff8aac] = 0x00e00016
		u32[0xffff8ab0] = 0xd06aa1a1

		u32[0xffff8b26] = 0x19a16b00
		u32[0xffff8b2a] = 0x00ff0000
		u32[0xffff8b2e] = 0x316aa1a1

		u32[0xffff8ba4] = 0x71727300
		u32[0xffff8ba8] = 0x00000022
		u32[0xffff8bac] = 0x226aa1a1

		u32[0xffff8c22] = 0x21a16b22
		u32[0xffff8c26] = 0x00000000
		u32[0xffff8c2a] = 0x006aa1a1
	}


	if (u16[0xffffb014] > 0x0b7e)	// If the player is stuck under the first outside platform,
		u8[0xffff8c25] = 0x35		// use the top-solid only variant to let the player back up.
	else							// Otherwise, use the variant with thicker solidity
		u8[0xffff8c25] = 0x22		// to support falls from above.

	fillPlaneA_Default(camera.position.x.u16 - 0x40, camera.position.y.u16 - 0x40, getScreenWidth() + 0x80, getScreenHeight() + 0x80)

	if (outdoorChunks)
	{
		Renderer.drawCustomSprite("fbz_tunnellights", 0x2380 - camera.foreground.x.u16, 0x0b00 - camera.foreground.y.u16, 0, 0, 0x8000)
		Renderer.drawCustomSprite("fbz_tunnellights", 0x2400 - camera.foreground.x.u16, 0x0b00 - camera.foreground.y.u16, 0, 0, 0x8000)
		Renderer.drawCustomSprite("fbz_tunnellights", 0x2410 - camera.foreground.x.u16, 0x0b00 - camera.foreground.y.u16, 0, 0, 0x8000)
		Renderer.drawCustomSprite("fbz_door", 0x2580 - camera.foreground.x.u16, 0x0b40 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO | SPRITE_FLAG_FLIP_X, 0x9f00)
		Renderer.drawRect(0x2570 - camera.foreground.x.u16, 0x0b40 - camera.foreground.y.u16, 16, 64, 0x482448ff, 0x9eff, 0, 1)
	}

	// Handle background swap
	if (u16[0xffffeed6] == 0)
	{
		if (!skyBackground)
		{
			fn052a2a()
			return
		}

		fn05326a()
	}
	else
	{
		if (skyBackground)
		{
			fn052a2a()
			return
		}

		u16[0xffffeed6] = 0
		D0 = 8
		D6 = 0
		fn05327a()
	}
}


// In Original Mode, undo changes to the FBZ2 laser miniboss.
// Functions taken from bosses\boss_fbz2_mid.lemon
//# address-hook(0x06fd16) end(0x06fd28)
function void fn06fd16()
{
	// Targets:
	//  - 0x06fd38	-> objA0.base_state = 0x00  -> Initialization
	//  - 0x06fdc0	-> objA0.base_state = 0x02  -> Waiting for player to reach the boss area
	//  - 0x06fe00	-> objA0.base_state = 0x04  -> Deploying laser
	//  - 0x06fe22	-> objA0.base_state = 0x06  -> Short wait time (used in various places, incl. during laser shots)
	//  - 0x06feb2	-> objA0.base_state = 0x08  -> Charging laser, and wall movement if needed

	call tableLookupAddress(0x06fd2e, objA0.base_state)

    if (!original_mode)
    {
        // Destructible laser logic here and in other functions below was #contributed by HazelSpooder
        if (objA0.base_state < 0x06)
        {
            // Prevent boss from being damaged too early
            DrawObject()
            return
        }
    }

	fn070330()
	Enemy.DrawDynamicObject()
}

//# address-hook(0x06fd38) end(0x06fdba)
function void fn06fd38()
{
	setupObjectAttributesFull(0x070396)

	if (!original_mode)
    {
        // Use 8 hits for the laser (Origins uses 12 hits, but the laser is faster in S3AIR)
        boss.remaining_hits = 8
    }
    else
        boss.remaining_hits = 0x7f

	objA0.value39 = 6			// Laser shots until the thing blows up by itself
	level.boss_encounter = 1
	screenmover_target.bottom = move_area.bottom.target
	move_area.left = 0x2900
	move_area.bottom.target = 0x05e0
	if (!original_mode)
		move_area.right = 0x2b40

	u32 address = isMainCharacter(CHARACTER_KNUCKLES) ? 0x0705d0 : 0x0705b6
	addPatternLoadingCue(address)

	loadPaletteLine1(0x070420)

	if (allocDynamicObjectStd())
	{
		// Create the object that fades out level music and starts the boss theme afterwards
		objA1.update_address = 0x085b30
		u8[A1 + 0x2c] = Game.getSetting(SETTING_FBZ2_MIDBOSS_TRACK) ? MUSIC_MINIBOSS_2 : MUSIC_MAINBOSS
		if (original_mode)
			u8[A1 + 0x2c] = MUSIC_MINIBOSS_2
	}

	// "spawnChildObjects(0x0703d0)" replaced by:
	spawnChildObject(0x06ffdc, 0x00, 0, 0)
	spawnChildObject(0x07002a, 0x02, 0, 0)

	// "spawnSimpleChildObjects(0x0703de)" replaced by:
	spawnSimpleChildObjects(0x0862ae, 1)
	if (_equal())
	{
		u8[A1 + 0x2c] = 0x49
	}

	// "spawnIdenticalChildObjects(0x0703c8)" replaced by:
	spawnChildObjects(0x06ff5c, 0, 0, 4)		// Force field generators
}

//# address-hook(0x06ff70) end(0x06ffb6)
function void fn06ff70()
{
	A1 = 0xffff0000 + u16[A0 + 0x46]
	if ((u8[A1 + 0x2a] & 0x80) == 0)
	{
		// Only move the left wall
		if ((objA0.subtype2c & 0x02) == 0)
		{
			A1 = 0xffff0000 + u16[A0 + 0x46]
			if (u8[A1 + 0x38] & 0x08)
			{
				// Start moving
				objA0.update_address = 0x06ffb8
				objA0.countdown_value = 0x1f
				objA0.countdown_callback = 0x06ffca
				objA0.velocity.x = 0x100

				if (!original_mode)
				{
					// Make things more interesting by moving a bit more in each step
					objA0.countdown_value += 6
				}
			}
		}

		DrawObject()
	}
	else
	{
		objA0.update_address = 0x01b588		// Address of "DrawOrUnloadObject"
	}
}

//# address-hook(0x0701b4) end(0x0701e8)
function void fn0701b4()
{
	MoveWithParent()
	Object.AnimationProgressByLocalA1.SpeedUp()

	if (!original_mode)
	{
		// Make the laser shoot faster
		objA0.flags2e = min(objA0.flags2e, 0x08)
		
		// Unload this object if laser is destroyed by player
		A1 = 0xffff0000 + u16[A0 + 0x46]
		if (objA1.value3a == 1)
		{
			UnloadObject()
			return
		}
	}
	if (D2.u16 != 0)
	{
		if (D2.s16 > 0)
		{
			// This is a countdown
			if (objA0.flags2e != 0x04)
			{
				Enemy.DrawDynamicObject()
				return
			}
			playSound(0x53)
		}

		if (objA0.value2f == 0x20)
		{
			A1 = 0xffff0000 + u16[A0 + 0x46]
			u8[A1 + 0x38] |= 0x02
		}
	}
	Enemy.DrawDynamicObject()
}



// Do not enable rumbling when restarting at last FBZ2 star post in Original Mode
// Function taken from level\08_fbz\level_fbz.lemon
//# address-hook(0x052fa8) end(0x053018)
function void InitLevelScrolling.FBZ2()
{
	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x052d10
	}

	if (camera.position.x.u16 >= 0x2c40)
	{
	#if STANDALONE
		// This begins the rumbling sound at the end of Act 2 when starting from the final checkpoint, #contributed by mrgrassman14
		if (!original_mode)
			objA1.update_address = 0x08642e
	#endif
		level.scrolling_routine = 0x10
		D0.u16 = u16[A3]
		u16[A3 + 0x70] = D0.u16
		u16[A3 + 0x74] = D0.u16
		u16[A3 + 0x78] = D0.u16
		u16[A3 + 0x7c] = D0.u16

		camera.screenshake.state.hi = 0xff
		D7.u16 = 0xc000
		fn05318c()

		fn04f2f6()
		Level.InitialTilesFill()
		WriteScrollOffsetsFlipped()
		fn04f386()

		scrolloffset.y.planeA = camera.background.y.u16
		scrolloffset.y.planeB = camera.foreground.y.u16

		signalMultiReturn()
		return
	}

	fn052a2a()
	fn04f2f6()

	D1 = 0
	Level.InitialTilesFill()

	A4 = 0x052d28
	A5 = 0xffffa800
	fn04f0ce()
}





// Slightly adjust the positions at which the FBZ2 ending sequence will speed up.
// This function is in time_attack.lemon, as the same function stops the floor entirely in time attack modes.
// Function taken from level\08_fbz\fbz_dualplane.lemon







// In Original Mode, some objects should not get moved when player relocation for FBZ2 boss occurs
// Function taken from level\08_fbz\level_fbz.lemon
//# address-hook(0x0530f0) end(0x05318a)
function void fn0530f0()
{
	D7.u16 = 0xc000
	UpdateBackgroundTiles.General()
	WriteScrollOffsetsFlipped()
	fn04f386()
	UpdateScreenShake()
	scrolloffset.y.planeA = camera.background.y.u16
	scrolloffset.y.planeB = camera.foreground.y.u16

	signalMultiReturn()

	if (u16[0xffffeed8] != 0)
	{
		u16[0xffffeed8] = 0

		// Move everything (incl. camera and characters) into place
		s16 moveX = s16[0xffffee98]		// Gets subtracted from X
		s16 moveY = s16[0xffffee9c]		// Gets added to Y
		u16[0xffffee98] = 0
		u16[0xffffee9c] = 0

		u16[0xffffb000 + 0x10] -= moveX
		u16[0xffffb04a + 0x10] -= moveX
		if (u8[0xffffb000 + 0x2a] & char.flag.IN_AIR)
		{
			u16[0xffffb000 + 0x14] += moveY
			u16[0xffffb04a + 0x14] += moveY
		}

		if (!original_mode)
		{
			// Don't forget the other stuff like shield effects, Tails' tails and the Super Flickies
			for (u32 address = 0xffffcbc0; address <= 0xffffce5a; address += 0x4a)
			{
				u16[address + 0x10] -= moveX
				u16[address + 0x14] += moveY
			}
		}

		camera.position.x.u16 -= moveX
		camera.position.y.u16 += moveY
		camera.foreground.x.u16 -= moveX
		camera.foreground.y.u16 += moveY
		level.vertical_wrap += moveY
		move_area.left -= moveX
		move_area.right -= moveX
		move_area.bottom.current += moveY
		move_area.bottom.target = move_area.bottom.current

		A1 = 0xffff005c + u16[0xffff8034]
		D0.u16 = u16[0xffff8000] - 0x14
		D1 = 3
		while (D1.s16 >= 0)
		{
			zeroMemory(A1, 0x14)
			A1 += D0.u16 + 0x14
			--D1.s16
		}
	}
}







// Allow the spiked hands of the FBZ2 boss to deal damage after defeat in Original Mode
// and disable AIR's custom Knuckles boss speed change in Original Mode.
// Functions taken from bosses\boss_fbz2.lemon
//# address-hook(0x070948) end(0x070956)
function void fn070948()
{
	if (!original_mode)
	{
		base.fn070948()
		return
	}

	// Targets:
	//  - 0x070966	-> objA0.base_state = 0x00
	//  - 0x070990	-> objA0.base_state = 0x02
	//  - 0x0709a8	-> objA0.base_state = 0x04
	//  - 0x070a0c	-> objA0.base_state = 0x06
	//  - 0x070a28	-> objA0.base_state = 0x08
	call tableLookupAddress(0x07095c, objA0.base_state)

	// Code here to check when spikes should damage is removed; the base function is called outside of Original Mode
	Enemy.DrawDynamicObject()
}

//# address-hook(0x0709a8) end(0x0709f6)
function void fn0709a8()
{
	A1 = 0xffff0000 + u16[A0 + 0x46]
	if ((u8[A1 + 0x38] & 0x10) == 0)
	{
		if ((u8[A1 + 0x38] & 0x08) == 0)
			return

		objA0.base_state = 0x06
		D0 = objA0.subtype2c * 2
		if (objA1.render_flags & render_flag.FLIP_X)
			D0.u16 += 8

		A1 = 0x0709fc + D0.u16
		objA0.velocity.x = s16[(A1+=2)-2]
		objA0.countdown_value = u16[(A1+=2)-2]
		objA0.countdown_callback = 0x070a12

		if (!original_mode)
		{
			if (getScreenExtend() >= 20)
			{
				// Let him move faster in widescreen
				if (isMainCharacter(CHARACTER_KNUCKLES))
				{
					objA0.velocity.x = objA0.velocity.x * 2
				}
				else
				{
					objA0.velocity.x = objA0.velocity.x * 3/2
				}
			}
		}
	}
	else
	{
		// "spawnChildObjects(0x070f24)" replaced by:
		spawnChildObject(0x070bfe, 0x00, -8, -16)
		spawnChildObject(0x070bfe, 0x02, 8, -16)
		spawnChildObject(0x070bfe, 0x04, -8, 16)
		spawnChildObject(0x070bfe, 0x06, 8, 16)

		fn0852ae()
	}
}





// Correct Euka's FBZ2 ending collision fix for capsule animals to use a chunk suiting DAGE's collision
// Function taken from bosses\boss_fbz2.lemon
//# address-hook(0x070870) end(0x0708a4)
function void fn070870()
{
	objA0.update_address = 0x0708aa
	level.wait_for_results = 0xff
	level.boss_encounter = 0

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x086540
		objA1.position.x.u16 = 0x307c
		objA1.position.y.u16 = 0x0660
	}

	screenmover_target.right = 0x2fdc + getScreenExtend()
	spawnSimpleChildObjects(0x084b00)

#if STANDALONE
	// Add chunks with an actual collision near the capsule
	//  -> This is done only to give the freed critter something to walk on, as they would otherwise fall through the floor
	//  -> Also note these chunks won't be shown in the game
	for (u32 address = 0xffff874c; address <= 0xffff8751; ++address)
		u8[address] = 0xe5	// 0x01
#endif
}











// Allows sand splash and sound effect when Knuckles lands in SOZ1
//# address-hook(0x042028) end(0x042090)
function void fn042028()
{
	player1.control_override = 1
	player2.control_override = 1
	control.player1 = 0
	control.tails = 0

	A1 = 0xffffb000
	fn042092()

	A1 = 0xffffb04a
	if (u32[A1] != 0)
	{
		fn042092()
	}

	A2 = 0xffffb000
	D0.u16 = (global.characters == CHARS_TAILS_ALONE) ? 0x0694 : 0x0690
	
	// new if statements to adjust for Knuckles' different position or for character mods
	if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		D0.u16 += 0x0006
	}
	if (Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") && global.characters == 3)
		D0.u16 = 0x0690
	if (Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") && global.characters == 2)
		D0.u16 = 0x069a
	if (Mods.isModActive("Chaos The Impostor") && global.characters == 2)
		D0.u16 = 0x069a

	if (D0.u16 == u16[A2 + 0x14])
	{
		fn042180()

		playSound(0x82)

		A2 = 0xffffb04a
		if (u32[A2] != 0)
		{
			fn042180()
		}
	}

	if (u16[0xffffb014] >= 0x06c0)
	{
		objA0.update_address = 0x0420a6
	}
}





// Make new functions that draws smaller copies of the sand pit darkener

function void SOZ.drawDarkSandPitShallow56(u16 px, u16 py, u16 width)
{
	for (u16 i = 0; i < width; i += 0x80)
	{
		Renderer.drawCustomSprite("obj_dark_sand_pit_overlay_shallow56", px + i - camera.foreground.x.u16, py + 0x38 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x8000)
	}
}

function void SOZ.drawDarkSandPitShallow72(u16 px, u16 py, u16 width)
{
	for (u16 i = 0; i < width; i += 0x80)
	{
		Renderer.drawCustomSprite("obj_dark_sand_pit_overlay_shallow72", px + i - camera.foreground.x.u16, py + 0x38 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x8000)
	}
}

function void SOZ.drawDarkSandPitShallow120(u16 px, u16 py, u16 width)
{
	for (u16 i = 0; i < width; i += 0x80)
	{
		Renderer.drawCustomSprite("obj_dark_sand_pit_overlay_shallow120", px + i - camera.foreground.x.u16, py + 0x38 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x8000)
	}
}

function void SOZ.drawDarkSandPitShallow184(u16 px, u16 py, u16 width)
{
	for (u16 i = 0; i < width; i += 0x80)
	{
		Renderer.drawCustomSprite("obj_dark_sand_pit_overlay_shallow184", px + i - camera.foreground.x.u16, py + 0x38 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x8000)
	}
}





// Draw sand pit overlays in SOZ1 and SOZ2
//# address-hook(0x055a7a) end(0x055a7e)
function void UpdateLevelScrolling.SOZ1()
{
	call 0x055a82 + level.scrolling_routine

	SOZ1_CustomSprites()
}

function void SOZ1_CustomSprites()
{
	if (!original_mode)
	{
		// Draw dark sand pit overlays
		SOZ.drawDarkSandPit(0x0800, 0x09d0, 0x100)
		SOZ.drawDarkSandPitShallow120(0x0B00, 0x0210, 0x100)
		SOZ.drawDarkSandPitShallow56(0x1080, 0x0450, 0x100)
		SOZ.drawDarkSandPitShallow72(0x1280, 0x06C0, 0x180)
		SOZ.drawDarkSandPitShallow56(0x1700, 0x0bd0, 0x180)
		SOZ.drawDarkSandPitShallow56(0x1900, 0x03d0, 0x100)
		SOZ.drawDarkSandPitShallow120(0x1e80, 0x0b50, 0x100)
		SOZ.drawDarkSandPitShallow72(0x2180, 0x08c0, 0x180)
		SOZ.drawDarkSandPitShallow56(0x2780, 0x0450, 0x200)
		SOZ.drawDarkSandPitShallow56(0x2780, 0x0750, 0x100)
		SOZ.drawDarkSandPitShallow56(0x2780, 0x0bd0, 0x200)
		SOZ.drawDarkSandPitShallow120(0x2d00, 0x0890, 0x100)
		SOZ.drawDarkSandPit(0x3380, 0x0a90, 0x200)
		SOZ.drawDarkSandPitShallow72(0x3480, 0x03C0, 0x200)
		SOZ.drawDarkSandPitShallow56(0x3580, 0x0650, 0x100)
		SOZ.drawDarkSandPitShallow120(0x3c80, 0x0290, 0x100)
		SOZ.drawDarkSandPitShallow120(0x3e00, 0x0910, 0x100)
		SOZ.drawDarkSandPitShallow184(0x3e80, 0x04d0, 0x100)
		SOZ.drawDarkSandPitShallow56(0x4100, 0x0a10, 0x100)

		if (time_attack == 1 || time_attack == 2)	// draw the pyramid already in place
			Renderer.drawCustomSprite("soz1_pyramid", 0x4250 - camera.foreground.x.u16, 0x07c0 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x2001)
	}
	if (original_mode || global.game.paused)	// somehow these sprite masks from fn055b70() are missed in Original Mode
	{
		Renderer.addSpriteMaskWorld(0x4220, 0x0a00, 0x230, 0x40, 0x9f00, 1)
		Renderer.addSpriteMaskWorld(0x4200, 0x0a08,  0x20, 0x38, 0x9f00, 1)
	}
}

//# address-hook(0x056294) end(0x056298)
function void UpdateLevelScrolling.SOZ2()
{
	call 0x05629c + level.scrolling_routine

	SOZ2_CustomSprites()
}

function void SOZ2_CustomSprites()
{
	if (!original_mode)
	{
		// Draw dark sand pit overlays
		SOZ.drawDarkSandPitShallow56(0x0600, 0x07d0, 0x100)
		SOZ.drawDarkSandPitShallow56(0x0b00, 0x04d0, 0x180)
		SOZ.drawDarkSandPitShallow56(0x0d80, 0x05d0, 0x200)
		SOZ.drawDarkSandPitShallow72(0x1180, 0x03c0, 0x180)
		SOZ.drawDarkSandPitShallow56(0x1680, 0x0250, 0x180)
		SOZ.drawDarkSandPitShallow56(0x1700, 0x06d0, 0x200)
		SOZ.drawDarkSandPitShallow72(0x2780, 0x0140, 0x200)
		SOZ.drawDarkSandPitShallow120(0x3880, 0x0290, 0x080)
		SOZ.drawDarkSandPitShallow120(0x4300, 0x0290, 0x180)
		SOZ.drawDarkSandPitShallow56(0x4300, 0x07d0, 0x180)
		SOZ.drawDarkSandPitShallow184(0x4d00, 0x0550, 0x100)
	}
}




// In Original Mode, raise the SOZ1 pyramid at the original speed.
// In Marathon Modes, raise the pyramid extremely fast.
// Only standard Revisited Mode should allow the cutscene to be sped up.
// Functions taken from level\09_soz\level_soz.lemon
//# address-hook(0x055a9a) end(0x055b00)
function void fn055a9a()
{
	if (u16[0xffffeec6] != 0)
	{
		// Start pyramid rising
		u16[0xffffeec6] = 0
		u16[0xffffee9c] = -8
		camera.screenshake.state.hi = 0xff

		fn055db6()
		fn04f2f6()

		u16[0xffffeec8] = (D0.u16 + getScreenHeight()) & level.height.tilemask
		u16[0xffffeeca] = 0x0f
		level.scrolling_routine += 4
		fn055b08()

		if (!original_mode && !time_attack)
			Game.startSkippableCutscene()
	}
	else
	{
		D0.u16 = (u16[0xffffb000 + 0x10] >= 0x4000) ? 0x0960 : 0x0b20
		move_area.bottom.current = D0.u16
		move_area.bottom.target = D0.u16
		fn055e96()
		fn055d56()

		A6 = 0xffffee90		// Address of camera.background.y
		A5 = 0xffffee96		// Address of camera.background.y.old
		D1 = 0
		D6 = 0x20
		LoadTileContentInDirY()
		fn055df2()
	}
}

//# address-hook(0x055d94) end(0x055db0)
function void fn055d94()
{
	// Pyramid rising
	if (camera.screenshake.state & 0x8000)
	{
		if (time_attack)
		{
			// Pyramid rising should be faster than fast forwarding the cutscene
			u16[0xffffee9c] += 6
			if (s16[0xffffee9c] >= 0x0280)
			{
				camera.screenshake.state = 0x08
				s16[0xffffee9c] = 0x0280

			#if STANDALONE
				Game.endSkippableCutscene()
			#endif
			}
		}
		else if (Game.getSetting(SETTING_SOZ_PYRAMID) && !original_mode)
		{
			// Let pyramid rise faster
			u16[0xffffee9c] += min(level.framecounter & 0x03, 2)
			if (s16[0xffffee9c] >= 0x0280)
			{
				camera.screenshake.state = 0x08
				s16[0xffffee9c] = 0x0280

			#if STANDALONE
				Game.endSkippableCutscene()
			#endif
			}
		}
		else
		{
			D0.u16 = level.framecounter & 0x03
			if (D0.u16 != 0)
			{
				++u16[0xffffee9c]
				if (s16[0xffffee9c] >= 0x0280)
				{
					camera.screenshake.state = 0x08
				}
			}
		}
	}

	fn055db6()
}





// In Original Mode, revert SOZ1 boss back to S3&K behavior
// Functions taken from bosses\boss_soz1.lemon
function bool BossSOZ1.slideAsRock()
{
	if (original_mode)
		return false

	if (objA0.velocity.x != 0)
	{
		moveWithGravity(0x60)

		CheckGroundCollision()
		if (D1.s16 <= 0)
		{
			objA0.position.y.u16 += D1.s16
			objA0.velocity.y = 0
		}

		if (objA0.velocity.x > 0)
			objA0.velocity.x = max(objA0.velocity.x - 0x10, 0)
		else
			objA0.velocity.x = min(objA0.velocity.x + 0x10, 0)

		if (abs(objA0.velocity.x) >= 0x80 && (abs(objA0.velocity.x) & 0xf0) == 0)
		{
			// Spawn dust effects
			// "spawnIdenticalChildObjects(0x07740a)" replaced by:
			spawnChildObjects(0x07706c, 0, 5, 6)
		}
	}

	if (objA0.velocity.x == 0)
	{
		objA0.hitbox_extends.y = 0x3b
		return false
	}

	// Still sliding
	return true
}

//# address-hook(0x076b44) end(0x076b7a)
function void fn076b44()
{
#if STANDALONE
	if (BossSOZ1.slideAsRock())
		return
#endif

	CheckDistanceToPlayers()
	if (D2.u16 >= 0x80 && !original_mode)		// More tolerance to player distance
		return
	else if (D2.u16 >= 0x60)
		return

	objA0.base_state = 0x06
	if (D0.u16 != 0)
		objA0.render_flags |= render_flag.FLIP_X
	else
		objA0.render_flags &= ~render_flag.FLIP_X

	objA0.countdown_value = 0x3e
	objA0.countdown_callback = 0x076b86

	// "spawnChildObjects(0x0773de)" replaced by:
	spawnChildObject(0x077022, 0x00, 0, 64)
}

//# address-hook(0x076ca2) end(0x076cc8)
function void fn076ca2()
{
	// Hit the ground as a block (after character attacked his head)
	objA0.base_state = 0x04
	if (original_mode)
	{
		objA0.hitbox_extends.y = 0x3b
		objA0.velocity.x = 0
	}
	objA0.velocity.y = 0
	camera.screenshake.state = 0x08

	playSound(0x5f)

	// Spawn dust effects
	// "spawnIdenticalChildObjects(0x07740a)" replaced by:
	spawnChildObjects(0x07706c, 0, 4, 6)
}

//# address-hook(0x076d14) end(0x076d26)
function void fn076d14()
{
	objA0.base_state = 0x12
	objA0.value3a = 0x01
	if (!original_mode)
	{
		// Reduce his waiting time
		objA0.countdown_value = 64
	}
	else
		objA0.countdown_value = 96
}

//# address-hook(0x076d28) end(0x076d7a)
function void fn076d28()
{
	--objA0.countdown_value
	if (objA0.countdown_value >= 0)
	{
		CheckDistanceToPlayers()
		if (objA0.render_flags & render_flag.FLIP_X)
		{
			D0.u16 -= 2
		}
		if (D0.u16 == 0)
			return

		objA0.base_state = 0x14
		u32[A0 + 0x30] = 0x077452
		if (!original_mode)
			objA0.countdown_value = max(objA0.countdown_value, 110)   // This avoids immediate jump after turning around
		objA0.countdown_callback = 0x076da8
	}
	else
	{
		objA0.base_state = 0x16
		u32[A0 + 0x30] = 0x077482
		objA0.countdown_callback = 0x076de6
		objA0.velocity.x = 0
		objA0.velocity.y = 0
	}
}

//# address-hook(0x076de6) end(0x076e06)
function void fn076de6()
{
	objA0.base_state = 0x0c
	objA0.countdown_callback = 0x076c92

	if (!original_mode)
	{
		// Make him jump a bit further
		objA0.velocity.x = (objA0.render_flags & render_flag.FLIP_X) ? 0x1c0 : -0x1c0
	}
	else
		objA0.velocity.x = (objA0.render_flags & render_flag.FLIP_X) ? 0x180 : -0x180
}

//# address-hook(0x0772f6) end(0x0773aa)
function void fn0772f6()
{
	if (objA0.position.y.u16 < 0x0a10)
	{
		if ((objA0.flags2a & 0x40) == 0)
			return
		if ((objA0.flags38 & 0x80) == 0)
			return

		objA0.flags38 &= ~0x80
		objA0.base_state = 0x0c

		objA0.countdown_callback = 0x076ca2
		objA0.hitbox_extends.y = 0x08
		objA0.animation.sprite = 0
		objA0.animation.frame = 0
		objA0.animation.timer = 0
		objA0.value3a = 0
		objA0.value39 = 0

		playSound(SFX_COLLAPSE)

		A1 = 0xffff0000 + u16[A0 + 0x44]
		if (!original_mode)
			objA0.velocity.x = (objA1.position.x.u16 >= objA0.position.x.u16) ? -0x2c0 : 0x2c0
		else
			objA0.velocity.x = (objA1.position.x.u16 >= objA0.position.x.u16) ? -0x200 : 0x200
		objA0.velocity.y = -0x200
	}
	else
	{
		objA0.update_address = 0x076e0a
		objA0.velocity.x = 0
		objA0.velocity.y = 0x40
		objA0.countdown_value = 0xbf
		hud.dirty.timer = 0
		screenmover_target.left = move_area.left
		screenmover_target.right = move_area.right
		move_area.left = camera.position.x.u16
		move_area.right = camera.position.x.u16 + getScreenExtend() * 2

		// "spawnSimpleChildObjects(0x083fee)" replaced by:
		spawnSimpleChildObjects(0x083d84, 1)
		if (_equal())
		{
			u8[A1 + 0x2c] = 0x04
		}
	}
}







// Allow SOZ2 ghosts immediately for all characters
//# address-hook(0x08f0ca) end(0x08f116)
function void fn08f0ca()
{
	// Ghost spawning can be disabled altogether
	if (!isGhostSpawnEnabled() && !original_mode)
		return

	// For Sonic & Tails, the ghosts are not free from the start already
	// if (!isMainCharacter(CHARACTER_KNUCKLES) && checkpoint.number == 0)
	//	return

	// Check light state
	if (u8[0xfffff7c3] != 0)
	{
		D0 = u8[0xfffff7c3]
		D0.u8 = u8[0x08f118 + D0.s16]
		D1.u8 = u8[0xfffffaad]
		if (D1.u8 >= D0.u8)
			return

		--u16[A0 + 0x3a]
		if (s16[A0 + 0x3a] >= 0)
			return

		++D1.u8
		u8[0xfffffaad] = D1.u8
		if (D1.u8 < D0.u8)
		{
			u16[A0 + 0x3a] = 0x3f
		}

		spawnSimpleChildObjects(0x08f674)
	}
	else
	{
		u8[0xfffffaad] = 0
	}
}



// Do not enable fix to SOZ2 boss Egg Mobile priority in Original Mode
// Function taken from bosses\boss_soz2.lemon
//# address-hook(0x077822) end(0x077842)
function void fn077822()
{
	MoveWithGravity20()
	if (objA0.velocity.y >= 0x0200)
	{
		objA0.update_address = 0x077848
		objA0.flags2a &= ~0x80
		objA0.render_flags |= render_flag.FLIP_X

	#if STANDALONE
		// Change priority of Egg Mobile so it isn't underneath its own exhaust flame, #contributed by mrgrassman14
		if (!original_mode)
			objA0.sprite_priority = 0x100
	#endif
	}
	DrawObject()
}






// Do not enable fix to SOZ2 boss damage palette flash in Original Mode
// Function taken from bosses\boss_soz2.lemon
//# address-hook(0x0781e4) end(0x078266)
function void fn0781e4()
{
	if (u8[A0 + 0x28] != 0)
		return

	if (boss.remaining_hits == 0)
	{
		objA0.update_address = 0x085668
		objA0.countdown_callback = 0x07780a
		u16[0xffffeec6] = 0x55

		// "spawnSimpleChildObjects(0x083fee)" replaced by:
		spawnSimpleChildObjects(0x083d84, 1)

		D0.u16 = camera.position.x.u16
		move_area.left = D0.u16
		AddScoreForBossEnemy()
		return
	}

	if (objA0.state == 0)
	{
		objA0.flags2a |= 0x40
		objA0.state = 0x20
		playSound(0x6e)
	}

	// Fix for boss palette damage flash, #contributed by mrgrassman14
	if (!original_mode)
		Boss.updateHitFlashing(5, 0x07826c, 0x078276, 0x078280)
	else
		Boss.updateHitFlashing(3, 0x07826c, 0x078276, 0x078284)

	--objA0.state
	if (objA0.state == 0)
	{
		objA0.flags2a &= ~0x40
		u8[A0 + 0x28] = u8[A0 + 0x25]
	}
}




// In Original Mode, restore one of the Death Egg appearances in the LRZ1 background for Knuckles.
// Function taken from level\10_lrz\level_lrz.lemon
//# address-hook(0x056b64) end(0x056bb4)
function void InitLevelScrolling.LRZ1()
{
	D0.u16 = u16[A3]
	D1.u16 = 0x1c
	D2 = 0x18
	while (D2.s16 >= 0)
	{
		u16[A3 + D1.s16] = D0.u16
		D1.u16 += 4
		--D2.s16
	}

	if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		// This removes the Death Egg usually visible in the background
		//  -> It is visible in two locations, remove both in standalone
		A1 = 0xffff0000 + u16[A3 + 0x04]
		u8[A1 + 0x04] = 0xf6
		if (!original_mode)
		{
			u8[A1 + 0x08] = 0xf6
		}
	}

	UpdateBackground.LRZ1()
	fn04f2f6()

	u32[0xffffa800] = 0
	u16[0xffffa806] = D2.u16
	u32[0xffffa808] = 0

	A4 = 0x056f68
	A5 = 0xffffa800
	fn04ecec()

	A4 = 0x056f6e
	A5 = 0xffffa80c
	fn04f0ce()
}





// Display controls inputs when the character is on a dash elevator
// Function taken from objects\10_lrz\lrz_dashelevator.lemon
//# address-hook(0x04301c) end(0x043094)
function void fn04301c()
{
	if (u8[A2] == 0 && objA0.flags2a & (1 << D6.u8) && A1 == 0xffffb000 && display_inputs && !original_mode)
	{
		Renderer.drawCustomSprite("@input_icon_button_down", getScreenWidth()/2 - 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
		Renderer.drawCustomSprite("@input_icon_button_A", getScreenWidth()/2 + 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
	}

	base.fn04301c()
}



// Revert behavior for enemies that drain rings in Original Mode, and display control inputs when relevant
// Function taken from script\enemies\hcz_piranha.lemon, but it is much more noticeable on an LRZ Toxomister
//# address-hook(0x0881fe) end(0x08826a)
function void fn0881fe()
{
#if STANDALONE
	// Invulnerability frames should shake off the piranha / toxomister cloud, as should being dead
	if ((u8[A1 + 0x34] > 0 || objA1.base_state >= 0x06) && !original_mode)	// base state check: objA1.base_state is base_state.DIED, base_state.INACTIVE, or base_state.DROWNED
	{
		D0 = 1
	}
	else if (objA1.base_state >= 0x06 && !original_mode)
	{
		// Same if the character just died (e.g. drowned)
		//  -> This prevents an original game issue in case the character drowns and gets killed by a piranha at almost the same time,
		//     which would remove two lives, and in worst case could lead to the live counter falling below 0 (resulting in 255 lives)
		D0 = 1
	}
	else
#endif
	{
		if (display_inputs && A1 == 0xffffb000 && !original_mode)	// u16[A0 + 0x44] holds the last two bytes of the character's object address. It would be 0x004a for sidekick Tails.
		{
			if (level.framecounter.low & 0x08)	// display alternating left and right inputs
				Renderer.drawCustomSprite("@input_icon_button_left", getScreenWidth()/2, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
			else
				Renderer.drawCustomSprite("@input_icon_button_right", getScreenWidth()/2, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
			/*	
			Renderer.drawCustomSprite("@input_icon_button_left", getScreenWidth()/2 - 0x28, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
			Renderer.drawCustomSprite("@input_icon_button_right", getScreenWidth()/2 - 0x18, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
			Renderer.drawCustomSprite("@input_icon_button_left", getScreenWidth()/2 - 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
			Renderer.drawCustomSprite("@input_icon_button_right", getScreenWidth()/2 + 0x08, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
			Renderer.drawCustomSprite("@input_icon_button_left", getScreenWidth()/2 + 0x18, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
			Renderer.drawCustomSprite("@input_icon_button_right", getScreenWidth()/2 + 0x28, 0x38, 0, SPRITE_FLAG_PRIO, 0xffff)
			*/
		}
		--objA0.countdown_value
		if (objA0.countdown_value < 0)
		{
			objA0.countdown_value = 0x3b
			hud.dirty.rings |= 0x01
			objA0.flags38 |= 0x80

			if (ring_counter == 0)
			{
				A2 = A0
				A1 = 0xffff0000 + u16[A0 + 0x44]
				A0 = A1
				Character.Die()
				A0 = A2
				D0 = 1
			}
			else
			{
				D0.u16 = ring_counter - 1
				if (D0.u16 == 0 || ring_counter == 10 || ring_counter == 100)
				{
					hud.dirty.rings |= 0x80
				}
				ring_counter = D0.u16
				playSound(SFX_RING)
				D0 = 0
			}
		}
		else
		{
			if (objA0.flags38 & 0x80)
			{
				objA0.flags38 &= ~0x80
				hud.dirty.rings &= 0xfe
			}
			D0 = 0
		}
	}

	_setZeroFlagByValue(D0)
}



// Restore Iwamodoki point display and award points outside of Original Mode
// Function taken from enemies\lrz_iwamodoki.lemon
//# address-hook(0x08fb76) end(0x08fb8a)
function void fn08fb76()
{
	objA0.update_address = addressof(SmallExplosion.BaseUpdate)
	objA0.flags2a |= 0x80
// #if STANDALONE
	// Do not spawn an animal & floating points, as you won't get points...
//	objA0.base_state = 0x02
// #else
//	objA0.base_state = 0
// #endif

	objA0.base_state = 0
	if (!original_mode)
		addScore(10)

	// Spawn flying explosion debris
	// "spawnProjectileChildObjects(0x08fbd6)" replaced by:
	spawnProjectileChildObject(0x08fb90, 0x00, -4, 4, -1024, -512, 0x08fbd0, 0x08fc8b, 0x08fbb8)
	spawnProjectileChildObject(0x08fb90, 0x02, 4, 4, 1024, -512, 0x08fbd0, 0x08fc8b, 0x08fbb8)
	spawnProjectileChildObject(0x08fb90, 0x04, -8, -8, -512, -1024, 0x08fbd0, 0x08fc87, 0x08fbb8)
	spawnProjectileChildObject(0x08fb90, 0x06, 8, -8, 512, -1024, 0x08fbd0, 0x08fc87, 0x08fbb8)
}



// Removes call to move the lava floor in LRZ1
// and loads chunks, blocks, and tiles during transition to LRZ2.
// Function taken from level\10_lrz\level_lrz.lemon
//# address-hook(0x056bd2) end(0x056c2c)
function void fn056bd2()
{
	if (u16[0xffffeec6] != 0)
	{
		u16[0xffffeec6] = 0

		u32 backupD7 = D7
		u32 backupA0 = A0
		u32 backupA2 = A2
		u32 backupA3 = A3

	//	Kosinski.addToDecompressionQueue(0x1bc738, 0xffff0180)	// Act 2 chunks
		System.loadExternalRawData(stringformat("lrz2_chunks_s", global.act + 1), KosinskiRawdataBuffer)		// copy Secondary chunks to shared memory
		Kosinski.addToDecompressionQueue(KosinskiRawdataBuffer, 0xffff0180)									// decompress them to their proper RAM (see above)

		Kosinski.addToDecompressionQueue(0x1b8a96, 0xffff9128)

		Kosinski.addToDMAQueue(0x1b97d6, 0x1200)

		requestLoadingPatterns(0x30)

		D7 = backupD7
		A0 = backupA0
		A2 = backupA2
		A3 = backupA3

		level.scrolling_routine = 0x0c
		fn056d16()
	}
	else
	{
		// fn056dca()					// Commenting this out removes the call to the moving floor
		if (checkForMultiReturn())
			return

		UpdateBackground.LRZ1()
		fn056c30()
	}
}






// Restore the crushing behavior to the LRZ1 boss in Original Mode
// Function taken from bosses\boss_lrz1.lemon
//# address-hook(0x07871a) end(0x078734)
function void fn07871a()
{
	if (original_mode)
	{
		// Removed the character crushing code in base AIR, as it seems unnecessary and
		// can lead to Super/Hyper Tails getting killed for no obvious reason.
		// But for Original Mode it's baaaaaaack!
		D1 = 0x33
		D2 = 0x04
		D3 = 0
		D4.u16 = objA0.position.x.u16
		fn01dc56()
	}

	fn078c14()
	AddAsDynamicObject()
	Object.CountdownAndTrigger()
}






// Expand a sprite mask to the appropriate size at the LRZ1 boss.
// Function taken from objects\level\spritemask.lemon
//# address-hook(0x0862fe) end(0x086302)
function void fn0862fe()
{
	u8[0xffffef3a] = 0xff

	#if STANDALONE
		s16 px = objA0.position.x.u16 - objA0.box_size.x - 0x80
		s16 py = objA0.position.y.u16 - objA0.box_size.y

		Renderer.addSpriteMaskWorld(px, py, getScreenWidth(), objA0.box_size.y * 2, 0xa000 - objA0.sprite_priority, 1)	// previously set to 320 instead of getScreenWidth()
		//debugDrawRect(px, py, 320, objA0.box_size.y * 2, 0xc0c0c0c0)

		checkForUnloadObjectAtPosition(objA0.position.x.u16)
	#else
		DrawOrUnloadObject()
	#endif
}



//# address-hook(0x056bba) end(0x056bbe)
function void UpdateLevelScrolling.LRZ1()
{
	LRZ1_CustomSprites()

	// Call targets:
	//  - 0x056bc2	-> level.scrolling_routine == 0x00	-> Default
	//  - 0x056bc6	-> level.scrolling_routine == 0x04	-> Lava lake area
	//  - 0x056bca	-> level.scrolling_routine == 0x08	-> Temporary state when leaving lava lake area (loads the background again)
	//  - 0x056bce	-> level.scrolling_routine == 0x0c	-> ?
	call 0x056bc2 + level.scrolling_routine
}




function void LRZ1_CustomSprites()
{
	Renderer.drawCustomSprite("lrz1_wallpathcover", 0x1340 , 0x08a0, 0, SPRITE_FLAG_PRIO | SPRITE_FLAG_WORLDSPACE, 0x9f01)
	if (global.game.paused)	// somehow these sprite masks from fn055b70() are missed in Original Mode
	{
		Renderer.addSpriteMaskWorld(camera.position.x.u16, 0x0710 + 176, getScreenWidth(), getScreenHeight() - 176, 0x9e00, 1)	
	}
}

// Note that this function is NOT currently called by typical level routines; they are ONLY called in DAGE pausing!
// The pause checks here are superfluous but left in for easier calls from a level routine in the future.
function void LRZ2_CustomSprites()
{
	if (global.game.paused)	// somehow these sprite masks from fn055b70() are missed in Original Mode
	{
		Renderer.addSpriteMaskWorld(camera.position.x.u16, 0x0710 + 176, getScreenWidth(), getScreenHeight() - 176, 0x9e00, 1)	
	}
}







// Removes the solidity on the stationary platforms in the LRZ2 boss lava fall (we use invisible objects instead) in non-Original Mode.
// Function taken from objects\10_lrz\lrz_lavafallplatform.lemon
//# address-hook(0x079d08) end(0x079d22)
function void fn079d08()
{
	Object.animationProgress(0x07a1e9)

	if (original_mode)	// only use the original solidity in Original Mode
	{
		D1 = 0x2b
		D2 = 0x18
		D3 = 0x19
		D4.u16 = objA0.position.x.u16
		fn01dc56()	// this is SolidObjectFull in the disassembly
	}

	Object.DrawOrUnload()
}



// Disable the granted extra lives flags fix in LRZ boss act for Original Mode
// Function taken from level\10_lrz\level_lrz.lemon
//# address-hook(0x059b1c) end(0x059b42)
function void fn059b1c()
{
	// Reset ring counter and time to LRZ 2 values after entering LRZ boss act
	D0.u16 = level.backup.rings
	if (D0.u16 != 0)
	{
		level.backup.rings = 0
		ring_counter = D0.u16
		hud.dirty.rings = 0x01
	}

#if STANDALONE
	if (!original_mode)
	{
		// Update the bitmask for granted extra lives, in case the player had 100 or more rings already
		extra_lives_granted = (ring_counter / 100) << 1
	}
#endif

	D0 = level.backup.timer.alldata
	if (D0 != 0)
	{
		level.backup.timer.alldata = 0
		timer.alldata = D0
		hud.dirty.timer = 0xff
	}

	u16[0xffffeec0] += 4
	fn059b46()
}



// In Original Mode, allow players to move while falling into the LRZ boss act
// and use the original sloping lava behavior.
// Functions taken from bosses\boss_lrz2.lemon
//# address-hook(0x059fc4) end(0x059fd6)
function void fn059fc4()
{
	objA0.update_address = 0x059fdc
	objA0.box_size.y = 0xc0
	objA0.position.y.u16 = 0x0640
	objA0.flags2a |= 0x80
	fn059fdc()

	if (camera.position.x.u16 < 0x0100 && !original_mode)
	{
		// Only purpose of this is to disable control
		//  -> We can't do it right here, as initializeMainGame would overwrite the value
		objA0.update_address = 0x059fda
	}
}

//# address-hook(0x059fdc) end(0x05a104)
function void fn059fdc()
{
	if (level.scrolling_routine == 0x0c)
	{
		// Update lava heights
		D0.u16 = u16[0xffffeedc]
		if (u8[0xffffeedb] != 0)
		{
			if (D0.u16 < 0x80)
			{
				++D0.u16
			}
		}
		else
		{
			if (D0.u16 != 0)
			{
				--D0.u16
			}
		}

		u16[0xffffeedc] = D0.u16
		u32 result

		D0 = (D0 << 16)
		D0.s32 >>= 8
		D1.u16 = D0.u16
		D0 = (D0 << 16) + (D0 >> 16)
		if (!original_mode)
			D2 = 0x30 - (D0 >> 26)	// Move lava down on Robotnik's side
		else
			D2 = 0x30
		D3 = 0
		D4.u16 = getScreenWidth() / 2 + 0x0f
		if (u8[0xffffeeda] == 0)
		{
			// Lava height increasing from left to right (Robotnik on the left side)
			A1 = 0xffffa910
			while (D4.s16 >= 0)
			{
				u8[A1] = D2.u8

				result = u32(D3.u16) + u32(D1.u16)
				D3.u16 = result
				D2.u16 += D0.u16
				if (result & 0x10000)	// Carry flag
					++D2.u16

				++A1
				--D4.s16
			}

			D2 = 0x30
			D3 = 0
			D4 = 0x0f
			A1 = 0xffffa910
			while (D4.s16 >= 0)
			{
				result = u32(D3.u16) - u32(D1.u16)
				D3.u16 = result
				D2.u16 -= D0.u16
				if (result & 0x10000)	// Carry flag
					--D2.u16

				--A1
				u8[A1] = D2.u8
				--D4.s16
			}
		}
		else
		{
			// Lava height increasing from right to left (Robotnik on the right side)
			A1 = 0xffffa9b0 + getScreenExtend()
			while (D4.s16 >= 0)
			{
				--A1
				u8[A1] = D2.u8

				result = u32(D3.u16) + u32(D1.u16)
				D3.u16 = result
				D2.u16 += D0.u16
				if (result & 0x10000)	// Carry flag
					++D2.u16

				--D4.s16
			}

			D2 = 0x30
			D3 = 0
			D4 = 0x0f
			A1 = 0xffffa9b0 + getScreenExtend()
			while (D4.s16 >= 0)
			{
				result = u32(D3.u16) - u32(D1.u16)
				D3.u16 = result
				D2.u16 -= D0.u16
				if (result & 0x10000)	// Carry flag
					--D2.u16

				u8[A1] = D2.u8
				++A1
				--D4.s16
			}
		}

		// Collision check against the lava
		D1.u16 = getScreenWidth() / 2
		A2 = 0xffffa910
		D4.u16 = 0x0a00 + getScreenWidth() / 2
		objA0.position.x.u16 = D4.u16
		fn01e2fe()
	}
	else
	{
		D1.u16 = 0x0180
		D2.u16 = 0x40
		D3.u16 = 0x30
		D4.u16 = 0x0b80
		objA0.position.x.u16 = D4.u16
		PlatformCheckClimbOn()
	}

	D0.u16 = u16[0xffffeedc]
	D0 = (D0 << 16)
	D0 >>= 7
	D1 = D0 >> 1
	D0 += D1
	if (u8[0xffffeeda] == 0)
	{
		D0.s32 = -D0.s32
	}

	u32[0xffffeee6] = D0
	if (objA0.flags2a & object.flag.P1_ON_OBJECT)
	{
		A1 = 0xffffb000
		if (!level.results_done && (u8[A1 + 0x2b] & char.bonus.SHIELD_FIRE) == 0 && !level.capsule_opened)
		{
			DamageCharacter()
		}

		D0 = u32[0xffffeee6]
		u32[A1 + 0x10] += D0
	}

	if (objA0.flags2a & object.flag.P2_ON_OBJECT)
	{
		A1 = 0xffffb04a
		if (!level.results_done && !level.capsule_opened)
		{
			DamageCharacter()
		}

		D0 = u32[0xffffeee6]
		u32[A1 + 0x10] += D0
	}
}









// Change exit position from the LRZ2 tube on the top path to lessen subpixel issues on the following quarterpipe.
// Function taken from objects\06_lbz\lbz_boostertube.lemon but is used for LRZ2 tubes as well.
//# address-hook(0x0296d4) end(0x029766)
function void fn0296d4()
{
	--u8[A4 + 0x02]
	if (s8[A4 + 0x02] <= 0)
	{
		A2 = u32[A4 + 0x06]
		D4.u16 = u16[(A2+=2)-2]
		objA1.position.x.u16 = D4.u16
		D5.u16 = u16[(A2+=2)-2]
		objA1.position.y.u16 = D5.u16
		if (s8[A0 + 0x2c] < 0)
		{
			A2 -= 8
		}
		u32[A4 + 0x06] = A2
		u16[A4 + 0x04] -= 4
		if (u16[A4 + 0x04] != 0)
		{
			D4.u16 = u16[(A2+=2)-2]
			D5.u16 = u16[(A2+=2)-2]
			D2.u16 = 0x1000
			fn029818()
			return
		}

		u8[A4] += 2
		u8[A4 + 0x02] = 0x02
		objA1.position.y.u16 &= 0x0fff
		if ((objA0.subtype2c & 0x40) == 0)
		{
			objA1.velocity.x = 0
			objA1.velocity.y = 0
		}

		playSound(0x81)		// tube exit SFX

		if (objA0.subtype2c & 0x20)
		{
			A2 = A1
			if (allocDynamicObjectAfterA0())
			{
				objA1.update_address = 0x029896
				objA1.position.x.u16 = u16[A2 + 0x10]
				objA1.position.y.u16 = u16[A2 + 0x14]
				objA1.velocity.x = u16[A2 + 0x18]
				objA1.velocity.y = u16[A2 + 0x1a]
			}
			A1 = A2
		}
		if (global.zone_act == 0x0901 && objA1.position.x.u16 == 0x2448 && objA1.position.y.u16 == 0x01f0 && !original_mode)	// right end of pipe in LRZ2 with quarterpipe afterward
		{
			objA1.position.x.u16 += 2	// minor position shift
			objA1.position.x.frac = 0x0000		// set subpixels
			objA1.position.y.u16 += 2	// minor position shift
			objA1.position.y.frac = 0x0000		// set subpixels
		}
	}

	fn029768()
}







// Shift the camera to the right when approaching the LRZ2 Knuckles scene to prevent flying under it and softlocking.
// Function taken from level\10_lrz\lrz_knucklescutscene.lemon
//# address-hook(0x063c66) end(0x063c7a)
function void fn063c66()
{
	if (move_area.left < 0x3800)
	{
		move_area.left &= 0xfffe	// set final bit of camera position to 0
		move_area.left += 2			// move camera position to next even number
	}
	base.fn063c66()
}









// Enforce 8 hits on LRZ2 boss in Original Mode
// Function taken from bosses\boss_lrz2.lemon
//# address-hook(0x07981e) end(0x079852)
function void fn07981e()
{
	setupObjectAttributesFull(0x07a140)

	objA0.position.x.u16 = 0x0b10 + getScreenExtend() * 2
	objA0.position.y.u16 = 0x0640
	boss.remaining_hits = 14
#if STANDALONE
	if (Game.getSetting(SETTING_LRZ2_BOSS) || original_mode)
	{
		// Reduced number of hits for this boss
		boss.remaining_hits = 8
	}
#endif

	u16[A0 + 0x26] = 0xffee
	objA0.velocity.y = -0x580
	playSound(0x7a)

	// "spawnChildObjects(0x07a18c)" replaced by:
	spawnChildObject(0x079be6, 0x00, 0, -18)
	spawnChildObject(0x079c0c, 0x02, -21, 1)
}


// Do not use unused boss defeat sprite for LRZ2 boss in Original Mode
// Function taken from bosses\boss_lrz2.lemon
//# address-hook(0x079c1c) end(0x079c4c)
function void fn079c1c()
{
	MoveAndFlipWithParent()

	A1 = 0xffff0000 + u16[A0 + 0x46]
	objA0.animation.sprite = 0x0f	// Normal face

	if (!original_mode)
	{
		// Swapped if statements to make the otherwise unused defeat face appear when defeated, #contributed by mrgrassman14
		if (u8[A1 + 0x2a] & 0x80)
		{
			objA0.animation.sprite = 0x11	// Defeat face
		}
		else if (u8[A1 + 0x2a] & 0x40)
		{
			objA0.animation.sprite = 0x10	// Damage face
		}
	}
	else
	{
		if (u8[A1 + 0x2a] & 0x40)
		{
			objA0.animation.sprite = 0x10	// Damage face
		}
		else if (u8[A1 + 0x2a] & 0x80)
		{
			objA0.animation.sprite = 0x11	// Defeat face
		}
	}

	fn08498c()
}




// Remove the level music between LRZ2 boss death and opening the Egg Prison in Original Mode.
// Function taken from bosses\boss_lrz2.lemon
//# address-hook(0x079988) end(0x0799da)
function void fn079988()
{
	--objA0.countdown_value
	if (objA0.countdown_value >= 0)
	{
		++objA0.position.y.u16
		DrawObject()
		return
	}

	objA0.update_address = 0x0799e0
	objA0.flags38 |= 0x30
	objA0.render_flags &= ~render_flag.VISIBLE
	level.wait_for_results = 0xff
	level.boss_encounter = 0

	if (allocDynamicObjectStd())
	{
		// Spawn capsule
		objA1.update_address = 0x086540
		objA1.render_flags |= render_flag.FLIP_Y
	}

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x07a100
	}

	addPatternLoadingCue(0x083d74)

	if (!original_mode)
	{
		// Fade out
		playMusic(MUSIC_CTRL_FADEOUT)

		// And spawn the object that will start playing LRZ 2 music
		if (allocDynamicObjectStd())
		{
			objA1.update_address = 0x085b0a
		}
	}
}





// Ignore an AIR change that zeroes out some chunks right at the start of Knuckles' layout.
// Function taken from level\11_hpz\level_hpz.lemon
//# address-hook(0x05a12e) end(0x05a152)
function void InitLevelTiles.HPZ()
{
	if (isMainCharacter(CHARACTER_KNUCKLES) && (level.start_location != 1 || original_mode))
	{
		move_area.right = 0x0aa0 + getScreenExtend()

	//	#if STANDALONE
			// Hide some chunks to the right
	//		u8[0xffff8170] = 0
	//		u8[0xffff81a4] = 0
	//	#endif
	}
	else
	{
		if (u16[0xffffb000 + 0x14] < 0x0480 && camera.position.x.u16 >= (0x0aa0 - getScreenExtend()) && level.start_location < 2)
		{
			move_area.left = 0x0aa0 - getScreenExtend()
		}
	}

	Level.GetCameraPosition()
	Level.InitialTilesFill()
}




// If Knuckles ends up in Sonic's HPZ, appropriately set the right camera boundary when he uses the first teleporter.
// Function taken from objects\level\teleporter.lemon
//# address-hook(0x0456f4) end(0x0457b8)
function void fn0456f4()
{
	fn045856()

	A1 = 0xffffb000
	if (!original_mode)
	{
		// Check if character got hurt right while entering the beam
		if (u8[A1 + 0x05] == 0x04)
		{
			u8[A1 + 0x05] = 0x02
			objA1.velocity.x = 0
			objA1.velocity.y = 0
			objA1.groundspeed = 0
		}
	}

	A2 = 0xffff0000 + u16[A0 + 0x3c]
	if (s8[A2 + 0x46] >= 0x08)
	{
		if (u8[A2 + 0x46] == 0x08)
		{
			objA1.flags2a &= ~char.flag.ON_OBJECT
			objA1.flags2a |= char.flag.ROLLING
			objA1.state = char.state.ROLLING
		#if STANDALONE
			objA1.groundspeed = 0	// Kill drop dash effect
		#endif
			u8[0xffffeed6] = 0xff
		}
		else if (u8[A2 + 0x46] < 0x18)
		{
			if (level.framecounter.low & 0x01)
			{
				--objA1.position.y.u16
				if (level.framecounter.low & 0x02)
				{
					D0.u16 = objA1.position.x.u16
					if (D0.u16 != objA0.position.x.u16)
					{
						s16 dx = (D0.u16 >= objA0.position.x.u16) ? -1 : 1
						objA1.position.x.u16 += dx
					}
				}
			}
		}
		else	// if (u8[A2 + 0x46] >= 0x18)
		{
			objA0.update_address = 0x0457be
			D0.u8 = objA0.subtype2c
			if (global.zone != 0x16)
				D0.u16 &= 0x3f
			u8[A0 + 0x2d] = D0.u8

			u8[A1 + 0x2e] = 3
			objA1.state = char.state.RUNNING
			u8[A1 + 0x22] = 0

			if (global.zone == 0x16)
			{
				move_area.left = 0x0aa0 - getScreenExtend()
				if (isMainCharacter(CHARACTER_KNUCKLES) && !original_mode)
					move_area.right = 0x0aa0 + getScreenExtend()
			}
			else
			{
				level.vertical_wrap = 0xff00
				D0.u16 = 0x1000
				move_area.bottom.current = D0.u16
				move_area.bottom.target = D0.u16
			}

			u8[0xffffeed7] = 0
			playSound(0x73)
		#if STANDALONE
			Input.setControllerRumble(-1, 0.0f, 0.5f, 500)
		#endif

			player1.camera_lock = 0xff
		}
	}

	DrawObject()
}




// Do not move Knuckles from HPZ to SSZ if he is not being held by the teleporter beam.
// Function taken from objects\level\teleporter.lemon
//# address-hook(0x045b94) end(0x045bf2)
function void fn045b94()
{
	if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		// Knuckles' HPZ teleporter
		if (camera.position.y.u16 >= 0x0240 || u16[0xffffb000 + 0x10] < 0x0b00)
			return

		// New check to ensure the teleporter beam is holding the character
		if (u8[0xffffeed6] != 0xff && !original_mode)
			return

		playMusic(MUSIC_CTRL_FADEOUT)

		sram.block_interrupts.u8 = 0xff
		SaveGameOnLevelFinished()

		TriggerNextZone(0x0a01)		// Knuckles' Sky Sanctuary act
	}
	else
	{
		// Sonic's / Tails' HPZ teleporter (part of the HPZ cutscene)
		A1 = 0xffff0000 + u16[A0 + 0x2e]
		if (objA1.position.x.u16 < 0x1000)
		{
			UnloadObject()
			return
		}

		u32[0xfffffc62] = 0x040c0408
		level.palettefx.state = 0xff
		objA1.update_address = 0x045ad6
		objA0.update_address = 0x045bf4
	}
}






// In Original Mode, force the S&K Knuckles theme when fighting him
// Function taken from bosses\boss_hpz_knuckles.lemon
function u8 BossHPZKnuckles.chooseMusicTrack()
{
	if (original_mode)
		return MUSIC_KNUCKLES_FORCED_SK
	
	u8 option = Game.getSetting(SETTING_AUDIO_HPZ_MUSIC)
	if (option == 0)
		return MUSIC_KNUCKLES_FORCED_S3		// Knuckles' theme from S3
	else if (option == 1)
		return MUSIC_KNUCKLES_FORCED_SK		// Knuckles' theme from S&K
	else if (option == 2)
		return MUSIC_MINIBOSS_FORCED_S3		// Mini-boss theme from S3
	else if (option == 3)
		return MUSIC_KNUCKLES_FORCED_PROTO		// Knuckles' theme from S3 prototype
	return MUSIC_KNUCKLES		// Fallback value, should not get reached
}





// Force the HPZ emerald theft scene and SSZ bosses to use S3&K music in Original Mode
// Function taken from scripts\objects\shared.lemon
//# address-hook(0x085b44) end(0x085b5a)
function void fn085b44()
{
	// This function is used for music changes before boss fights, but also in Sonic's intro and Knuckles' outro
	--objA0.countdown_value
	if (objA0.countdown_value < 0)
	{
	#if STANDALONE
		if (Game.getSetting(SETTING_SSZ_BOSS_TRACKS) && objA0.subtype2c == MUSIC_MAINBOSS && global.zone_act == 0x0a00 && !original_mode)
		{
			if (camera.position.x.u16 < 0x0400)
			{
				objA0.subtype2c = MUSIC_BOSS_S1		// Sonic 1 boss music
			}
			else if (camera.position.x.u16 < 0x1800)
			{
				objA0.subtype2c = MUSIC_BOSS_S2		// Sonic 2 boss music
			}
		}
		else if (objA0.subtype2c == MUSIC_MINIBOSS_2)
		{
			// In HPZ emerald theft cutscene, consider config option
			if (global.zone_act == 0x1601)
			{
				u8 option = Game.getSetting(SETTING_AUDIO_HPZ_MUSIC)
				if (option == 0 && !original_mode)
					objA0.subtype2c = MUSIC_MINIBOSS_FORCED_S3		// Enforce mini-boss theme from S3
				else
					objA0.subtype2c = MUSIC_MINIBOSS_FORCED_SK		// Enforce mini-boss theme from S&K
			}
		}
	#endif

		level.default_music.u8 = objA0.subtype2c
		playMusic(objA0.subtype2c)

	#if STANDALONE
		// Credits in Knuckles' outro?
		if (objA0.subtype2c == MUSIC_CREDITSMEDLEY)
		{
			// Reset frame counter so we can use it to get the current credits music playback position
			level.framecounter = 0

			// Start skippable cutscene again, to reset the timer
			Game.startSkippableCutscene()
		}
	#endif

		UnloadObject()
	}
}




// Make HPZ boss (Knuckles) behaviors match the original game / ROM hack in Original Mode
// Functions taken from bosses\boss_hpz_knuckles.lemon
//# address-hook(0x063e7c) end(0x063eba)
function void fn063e7c()
{
	fn084688()
	if (D2.s16 < 0 && u8[0xfffffab8] & 0x01)
	{
		D0.u8 = objA0.value39 + 1
		// Reduce wait time in standalone
		if (D0.u8 >= 2 && original_mode)		// Number of additional animation loops until Knuckles starts a spindash
		{
			fn0641c4()
			return
		}
		objA0.value39 = D0.u8
	}

	CheckDistanceToPlayers()
	fn066094()
	if (D3.u16 < 0x40 && D2.u16 < 0x30)
	{
		fn063f20()
	}
}

//# address-hook(0x06401c) end(0x064034)
function void fn06401c()
{
	objA0.base_state = 0x0a
	objA0.velocity.y = -0x600
	// Sometimes jump less high
	if (getRandomNumber() % 3 == 0 && !original_mode)
		objA0.velocity.y = -0x540
	playSound(SFX_JUMP)

	A1 = 0x0667c1
	fn084580()
}

//# address-hook(0x06429e) end(0x0642ea)
function void fn06429e()
{
	// Do nothing if character can't deal damage right now
	if (u8[A1 + 0x34] > 0 && !original_mode)	// "char.invuln.countdown"
		return

	// Knuckles got hit
	objA0.flags38 |= 0x01
	playSound(0x5d)

	D1.u16 = objA1.position.x.u16 - objA0.position.x.u16
	objA0.velocity.x = (D1.s16 >= 0) ? -0x300 : 0x300
	objA0.velocity.y = -0x300

	--boss.remaining_hits
	if (boss.remaining_hits == 0)
	{
		// Defeated
		fn064310()
	}
	else
	{
		objA0.base_state = 0x16
		u16[A0 + 0x44] = 0
		objA0.mapping_offset = 0x14a8d6
		objA0.animation.sprite = 0x8d

		A1 = 0x0667bc
		fn084580()
	}
}

function void fn0660e2()
{
	if (objA0.flags38 & 0x10)
		return

	A1 = 0xffff0000 + D0.u16
	s16 diffX = s16(objA1.position.x.u16 - objA0.position.x.u16)
	s16 diffY = s16(objA1.position.y.u16 - objA0.position.y.u16)

	bool facingToPlayer = ((objA0.render_flags & render_flag.FLIP_X) != 0) != (diffX < 0)
	bool hitByPlayer = (facingToPlayer || abs(diffY) >= 0x10)

	if (objA0.animation.sprite == 0xc0 && !original_mode)
	{
		hitByPlayer = facingToPlayer
	}


	if (hitByPlayer)
	{
		// Hit by player
		fn066134()
	}
	else if ((u8[A1 + 0x2b] & char.bonus.INVINCIBLE) && (u8[A1 + 0x20] != char.state.ROLLING))
	{
		// Oh no! Knuckles hurt himself attacking the invincible player
		fn06429e()
	}
	else
	{
		// Hit player

		// Targets:
		//  - 0x0660a6
		A4 = u32[A3]
		call A4
	}
}

//# address-hook(0x06615a) end(0x066188)
function void fn06615a()
{
//	if (original_mode)
//	{
//		fn06615a_Orig()		// Kept for posterity in case there are issues with new A.I.R. preview movement boundary calculations
//		return
//	}

	if (objA0.velocity.x != 0)
	{
		if (objA0.velocity.x > 0)
		{
			// Right movement boundary for Knuckles
			u16 rightBoundary = move_area.right + 320 - 0x18
			if (original_mode)
				rightBoundary = camera.position.x.u16 + getScreenWidth() - 0x10
			if (objA0.position.x.u16 >= rightBoundary)
			{
				objA0.velocity.x = 0
			}
		}
		else
		{
			// Left movement boundary for Knuckles
			u16 leftBoundary = camera.position.x.u16 + 0x18	// Just for the sake of symmetry
			if (original_mode)
				leftBoundary = camera.position.x.u16 + 0x10
			if (objA0.position.x.u16 <= leftBoundary)
			{
				objA0.velocity.x = 0
			}
		}

	}
}

/*
function void fn06615a_Orig()
{
	if (objA0.velocity.x != 0)
	{
		u16 borderDistance = 0x10	// the screen extension is 0 in Original Mode, which centers Knuckles on the screen's edge (half of him off screen)

		if (objA0.velocity.x > 0)
		{
			D0.u16 = camera.position.x.u16 + getScreenWidth() - borderDistance
			if (D0.u16 <= objA0.position.x.u16)
			{
				objA0.velocity.x = 0
			}
		}
		else
		{
			D0.u16 = camera.position.x.u16 + borderDistance
			if (D0.u16 >= objA0.position.x.u16)
			{
				objA0.velocity.x = 0
			}
		}
	}
}
*/




// Remove AIR's custom rearrangement of HPZ chunks as done in boss_hpz_knuckles.lemon
//# address-hook(0x063cfc) end(0x063d14)
function void fn063cfc()
{
	A1 = A0
	objA1.update_address = 0x063d1a

	A2 = 0xffffbde0
	u16[0xfffffaa4] = A2.u16
	copyMemory(A2, A1, 0x4a)

	UnloadObject()

// #if STANDALONE
	// Change the level chunks a little bit, so the prophecy picture is only there once
	// u8[0xffff81e5] = 0x48
	// u8[0xffff8218] = 0x42
	// u8[0xffff8219] = 0x49
	// u8[0xffff824d] = 0x4a
	// u8[0xffff824e] = 0x4c
// #endif
}




// Draw HUD digits under gray Super Emeralds to indicate S&K special stage order.
// Function taken from level\11_hpz\hpz_emeraldcave.lemon
//# address-hook(0x05aa78) end(0x05aa9c)
function void UpdateLevelScrolling.EC()
{
	HPZ.hub_CustomSprites()

	base.UpdateLevelScrolling.EC()
}

function void HPZ.hub_CustomSprites()
{
	constant u8 superemerald.inactive = 2
	s8 theme.x = (theme.hud == theme.south) ? -1 : 0
	s8 theme.y = (theme.hud == theme.s3k || theme.hud == theme.south || theme.hud == theme.westside) ? 2 : 0
	if (!original_mode && global.stage_type == 2 && global.game_mode == 0x0c)
	{
		if (u8[0xffffffb2] == superemerald.inactive)
			HUD.drawDigit(1, 0x1640 - camera.position.x.u16 - 3 + theme.x, 0x0368 - camera.position.y.u16 - camera.screenshake.offset + 0x20 + theme.y, 0x4000)
		if (u8[0xffffffb3] == superemerald.inactive)
			HUD.drawDigit(2, 0x15e0 - camera.position.x.u16 - 3 + theme.x, 0x03a0 - camera.position.y.u16 - camera.screenshake.offset + 0x20 + theme.y, 0xa000)
		if (u8[0xffffffb4] == superemerald.inactive)
			HUD.drawDigit(3, 0x16a0 - camera.position.x.u16 - 3 + theme.x, 0x03a0 - camera.position.y.u16 - camera.screenshake.offset + 0x20 + theme.y, 0xa000)
		if (u8[0xffffffb5] == superemerald.inactive)
			HUD.drawDigit(4, 0x15a0 - camera.position.x.u16 - 3 + theme.x, 0x0350 - camera.position.y.u16 - camera.screenshake.offset + 0x20 + theme.y, 0x4000)
		if (u8[0xffffffb6] == superemerald.inactive)
			HUD.drawDigit(5, 0x16e0 - camera.position.x.u16 - 3 + theme.x, 0x0350 - camera.position.y.u16 - camera.screenshake.offset + 0x20 + theme.y, 0x4000)
		if (u8[0xffffffb7] == superemerald.inactive)
			HUD.drawDigit(6, 0x1550 - camera.position.x.u16 - 3 + theme.x, 0x0390 - camera.position.y.u16 - camera.screenshake.offset + 0x20 + theme.y, 0x4000)
		if (u8[0xffffffb8] == superemerald.inactive)
			HUD.drawDigit(7, 0x1730 - camera.position.x.u16 - 3 + theme.x, 0x0390 - camera.position.y.u16 - camera.screenshake.offset + 0x20 + theme.y, 0x4000)
	}
}


// Undo AIR fixes to the HPZ cutscene in Original Mode.
// Functions taken from level\11_hpz\hpz_cutscene.lemon
//# address-hook(0x06471a) end(0x064752)
function void fn06471a()
{
	u8[A1 + 0x2a] |= 0x40
	objA0.base_state = 0x34
	u16[A0 + 0x44] = 0
	objA0.mapping_offset = 0x14a8d6
	objA0.animation.sprite = 0x9a
	objA0.velocity.x = -0x200
	objA0.velocity.y = -0x200
	if (original_mode)		// Removed playSound(SFX_JUMP) as it is not appropriate here, #contributed by mrgrassman14
		playSound(SFX_JUMP)

	A1 = 0x0667c1
	fn084580()
}

//# address-hook(0x06478e) end(0x0647c0)
function void fn06478e()
{
	if (!original_mode)
		objA0.position.y.u16 = 0x03ac	// Change from 0x03ab so Knuckles doesn't float 1 pixel above the ground, #contributed by mrgrassman14
	else
		objA0.position.y.u16 = 0x03ab
	objA0.base_state = 0x36
	u8[A0 + 0x0a] &= ~0x80
	u16[A0 + 0x44] = 0
	objA0.mapping_offset = 0x14a8d6
	objA0.animation.sprite = 0x07
	objA0.velocity.x = 0
	objA0.velocity.y = 0

	A1 = 0x06682f
	fn084580()
}

//# address-hook(0x066348) end(0x066370)
function void fn066348()
{
	if (objA0.flags2a & 0x40)
	{
		if (objA0.state == 0)
		{
			objA0.state = 0x30
			playSound(0x6e)
		}

 	// Fix for Egg Mobile palette damage flash, #contributed by mrgrassman14
	if (!original_mode)
		Boss.updateHitFlashing(3, 0x07a622, 0x07a628, 0x07a62e)
	else
		Boss.updateHitFlashing(3, 0x07a622, 0x07a628, 0x07a62c)

		--objA0.state
		if (objA0.state == 0)
		{
			objA0.flags2a &= ~0x40
		}
	}
}





// Custom function to draw a background wall in certain areas of SSZ
function void SSZ.drawBackgroundWall(u16 px, u16 py, u16 width)
{
	for (u16 i = 0; i < width; i += 0x80)
	{
		Renderer.drawCustomSprite("ssz_wall", px + i - camera.foreground.x.u16, py - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xce00)
	}
}





// Create fake walls and sprite masks to provide a better sense of direction in SSZ
// Function taken from level\12_ssz\level_ssz.lemon
//# address-hook(0x05729e) end(0x0572aa)
function void UpdateLevelTiles.SSZ()
{
	if (original_mode)
	{
		base.UpdateLevelTiles.SSZ()
		return
	}
	camera.foreground.y.u16 += camera.screenshake.offset

	u8[0xffff830b] = 0x40
	u8[0xffff83e7] = 0x40
	u8[0xffff84c3] = 0x40
	u8[0xffff8531] = 0x40
	u8[0xffff859c] = 0x40
	u16[0xffff8608] = 0x0000

	SSZ_CustomSprites()

	call 0x0572ae + s16[0xffffeec0]
}


function void SSZ_CustomSprites()
{
	// Make sure the rising Death Egg at the start of Act 1 has its sprite mask active during game pause.
	// This is otherwise handled by function void fn065b24() and the preceding function in level\12_ssz\ssz_start.lemon
	if (global.game.paused)
	{
		u32 i = 0
		u32 backupA0 = A0
		A0 = 0xffffb000
		while (i <= 0x6d && camera.position.x.u16 < 0x0330)
		{
			A0 = 0xffffb000 + (0x4a * i)
			if (u32[A0] == 0x065b24)
			{
				Renderer.addSpriteMaskWorld(objA0.position.x.u16 - 64, objA0.position.y.u16 - 47, 128, 100, 0xa000 - objA0.sprite_priority, 1)
				break
			}
			i++
		}
		A0 = backupA0
	}

	Renderer.drawCustomSprite("ssz_pillar_front", 0x0800 - camera.foreground.x.u16, 0x0b20 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0xce00)
	if (u16[0xffffb010] < 0x1380 && u16[0xffffb014] > 0x06c0 && u16[0xffffb014] <= 0x0b00)
	{
		SSZ.drawBackgroundWall(0x1380, 0x0580, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1380, 0x0600, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1380, 0x0680, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1380, 0x0700, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1380, 0x0780, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1380, 0x0800, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1380, 0x0880, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1380, 0x0900, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1380, 0x0980, 3 * 0x80)
	}
	else if (u16[0xffffb010] > 0x1380 && u16[0xffffb014] > 0x0480) 
	{
		u8[0xffff830b] = 0x39
		u8[0xffff83e7] = 0x39
		u8[0xffff84c3] = 0x39
		u8[0xffff8531] = 0x39
		SSZ.drawBackgroundWall(0x1180, 0x0400, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0480, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0500, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0580, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0600, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0680, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0700, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0780, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0800, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0880, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0900, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0980, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0a00, 3 * 0x80)
		SSZ.drawBackgroundWall(0x1180, 0x0a80, 3 * 0x80)
		Renderer.addSpriteMaskWorld(0x1300, 0x400, 0x0080, 0x0680, 0xcf00, 7)
	}
	else if (u16[0xffffb014] > 0x0c80 || (u16[0xffffb010] > 0x1200 && u16[0xffffb014] > 0x0b00)) 
	{
		u8[0xffff859c] = 0x39
		u16[0xffff8608] = 0x4b4b
		SSZ.drawBackgroundWall(0x1080, 0x0a80, 2 * 0x80)
		SSZ.drawBackgroundWall(0x1080, 0x0b00, 2 * 0x80)
		SSZ.drawBackgroundWall(0x1080, 0x0b80, 2 * 0x80)
		SSZ.drawBackgroundWall(0x1080, 0x0c00, 2 * 0x80)
	//	Renderer.addSpriteMaskWorld(0x1180, 0xb80, 0x0080, 0x0080, 0xcf00, 7)
	}
}





// Remove rendering fix for Knuckles on SSZ button in Original Mode
// Functions taken from level\12_ssz\ssz_start.lemon
//# address-hook(0x065af6) end(0x065b08)
function void fn065af6()
{
	--objA0.countdown_value
	if (objA0.countdown_value >= 0)
	{
		fn08459c()
		return
	}
	else
	{
	#if STANDALONE
		// Signal to the sprite masking object that it's not needed any more
		if (!original_mode)
			u8[0xfffffab8] |= 0x04
	#endif
		fn0851e4()
		Object.TriggerUnloading()
	}
}






// Removes call to make background collision in SSZ
// Function taken from objects\12_ssz\ssz_unknown.lemon
//# address-hook(0x057b8e) end(0x057bb2)
function void fn057b8e()
{
}






// If your x velocity is greater than an SSZ bouncy cloud's captured velocity, (likely from touching where two overlap),
// don't have the cloud force your exit velocity outside of Original Mode.
// Function taken from objects\12_ssz\ssz_bouncycloud.lemon
//# address-hook(0x045170) end(0x0452d8)
function void fn045170()
{
#if STANDALONE
	if (debug_mode.state)
		return
#endif
	
	u8 bit = (1 << D6.u8)

	D1 = 0x20
	D2 = 0x10
	D3 = 0
	D4.u16 = objA0.position.x.u16
	PlatformCheckClimbOnForCharacterA1()

	if (u8[A2] == 0)
	{
		if (objA0.flags2a & bit)
		{
			u16[A2 + 0x02] = objA1.velocity.x
			u16[A2 + 0x04] = u16[A1 + 0x1c]
			objA1.velocity.x = 0
			u16[A1 + 0x1c] = 0
			objA0.state = 0x01
			u8[A0 + 0x2d] = 0x01
			D0.u8 = objA0.base_state
			if (D0.u8 == 0)
			{
				D0 = 7
				objA0.base_state = D0.u8
			}
			u8[A2] = D0.u8
			u8[A2 + 0x06] = u8[0x04669f]
		}
	}
	else if (s8[A2] >= 0)
	{
		--u8[A2]
		if (u8[A2] != 0)
		{
			D0.s16 = s8[A2]
			A3 = 0x046698
			u8[A2 + 0x06] = u8[A3 + D0.s16]
		}
		else
		{
			playSound(0x8a)
		#if STANDALONE
			Input.setControllerRumbleByAddress(A1, 0.25f, 0.0f, 200)
		#endif
			if ((abs(u16[A2 + 0x02]) > abs(objA1.velocity.x)) || original_mode)		// If in Original Mode or if the recorded speed is faster than current speed,
				objA1.velocity.x = u16[A2 + 0x02]									// restore previous speed.
			u16[A1 + 0x1c] = u16[A2 + 0x04]
			objA1.velocity.y = -0x700
			u8[A1 + 0x2a] |= char.flag.IN_AIR
			u8[A1 + 0x2a] &= ~char.flag.ON_OBJECT
			u8[A1 + 0x40] = 0
			u8[A1 + 0x3d] = 0
			u8[A1 + 0x05] = 0x02
			u8[A1 + 0x20] = 0

			u8[A2] = 0xff
			D0 = -0x1c
			if ((u8[A1 + 0x2a] & char.flag.FACING_LEFT) == 0)
			{
				D0.s16 = -D0.s16
				u8[A2] &= ~0x01
			}
			u8[A1 + 0x26] = D0.u8
			u8[A0 + 0x2d] = 0
			u8[A2 + 0x06] = 0
			u8[A2 + 0x01] = 0x26

			A3 = 0x0466c8
			D1.u16 = objA1.position.x.u16

			if (allocDynamicObjectAfterA0())
			{
				D2 = 3
				while (D2.s16 >= 0)
				{
					objA1.update_address = 0x0452da
					u16[A1 + 0x2e] = A0.u16
					D3.u16 = u16[(A3+=2)-2]
					D3.u16 += D1.u16
					objA1.position.x.u16 = D3.u16
					D3.u16 = u16[(A3+=2)-2]
					D3.u16 += objA0.position.y.u16
					objA1.position.y.u16 = D3.u16
					objA1.velocity.x = u16[(A3+=2)-2]
					objA1.velocity.y = u16[(A3+=2)-2]

					if (!allocDynamicObjectAfterA1())
						break

					--D2.s16
				}
			}
		}
	}
	else
	{
		if (u8[A1 + 0x2e] == 0)
		{
			D0.u8 = u8[A1 + 0x2a]
			if (D0 & 0x02)
			{
				D0.u16 &= 0x28
				if (D0.u16 == 0)
				{
					D0.s16 = s8[A2 + 0x01]
					A3 = 0x0466a0
					u8[A2 + 0x07] = u8[A3 + D0.s16]

					--D0.u8
					if (D0.s8 >= 0)
					{
						u8[A2 + 0x01] = D0.u8
					}
					D0.u8 = u8[A1 + 0x26]
					D1 = 0x00060002
					if ((u8[A2] & 0x01) == 0)
					{
						if (D0.s8 >= 0)
						{
							D1 = (D1 << 16) + (D1 >> 16)
						}

						u16 result = u16(D0.u8) + u16(D1.u8)
						D0.u8 = (result & 0x100) ? 0 : result
					}
					else
					{
						if (D0.s8 < 0)
						{
							D1 = (D1 << 16) + (D1 >> 16)
						}

						u16 result = u16(D0.u8) - u16(D1.u8)
						D0.u8 = (result & 0x100) ? 0 : result
					}

					u8[A1 + 0x26] = D0.u8
					if (u8[A1 + 0x26] != 0)
					{
						return
					}
				}
			}
		}
		u8[A2] = 0
	}
}




// Do not enable SSZ boss damage palette flash fix in Original Mode
// Functions taken from boss\boss_ssz_mecha.lemon, boss_ssz_mid1.lemon, and boss_ssz_mid2.lemon.
//# address-hook(0x07d312) end(0x07d358)
//# translated(0x07d3be) end(0x07d3c6)
function void fn07d312()
{
	if (u8[A0 + 0x28] != 0)
		return

	D0.u8 = boss.remaining_hits
	if (D0.u8 == 0)
	{
		// Targets:
		//  - 0x07d35a
		//  - 0x07d39e
		call A4
		return
	}

	if (objA0.state == 0)
	{
		objA0.state = 0x20
		playSound(0x6e)
		objA0.flags2a |= 0x40
	}

	// Fix for boss palette damage flash, #contributed by mrgrassman14
	if (!original_mode)
		Boss.updateHitFlashing(5, 0x07d3cc, 0x07d3d6, 0x07d3e0)
	else
		Boss.updateHitFlashing(5, 0x07d3cc, 0x07d3d6, 0x07d3de)

	--objA0.state
	if (objA0.state == 0)
	{
		objA0.flags2a &= ~0x40
	}
}




// In Original Mode, allow original game glitch in which midbosses would disappear for one frame as they started flaying away upon defeat.
// Functions taken from boss\boss_ssz_mid1.lemon and boss_ssz_mid2.lemon.
//# address-hook(0x07a3ce) end(0x07a3e4)
function void fn07a3ce()
{
	objA0.update_address = 0x07a3e6
	objA0.render_flags |= render_flag.FLIP_X
	objA0.velocity.x = 0x0400
	objA0.velocity.y = 0
#if STANDALONE
	// Draw Egg Mobile so it doesn't disappear for 1 frame, #contributed by mrgrassman14
	if (!original_mode)
		DrawObject()
#endif
}

//# address-hook(0x07ac7a) end(0x07ac90)
function void fn07ac7a()
{
	objA0.update_address = 0x07ac92
	objA0.render_flags |= render_flag.FLIP_X
	objA0.velocity.x = 0x400
	objA0.velocity.y = 0
#if STANDALONE
	// Draw Egg Mobile so it doesn't disappear for 1 frame, #contributed by mrgrassman14
	if (!original_mode)
		DrawObject()
#endif
}



// Edit functions that change GHZ boss speed in AIR for Original Mode
// Functions taken from bosses\boss_ssz_mid1.lemon
function u16 BossMidSSZ1.getMoveTime()
{
	// Note that this refers to the move time from center to an edge
	if (getScreenExtend() > 0 && !original_mode)
	{
		// Make him cover more distance in widescreen, and take into account the velocity
		//  -> Using a value of 0x24 instead of the correct 0x20 to avoid a dead spot where boss can't hit you on the left
		u16 distanceToCover = 0x24 + getScreenExtend() / 2
		return distanceToCover * 0x100 / abs(objA0.velocity.x)
	}
	else
	{
		return 0x20
	}
}

//# address-hook(0x07a2fc) end(0x07a32a)
function void fn07a2fc()
{
	objA0.base_state = 0x04
	objA0.velocity.x = -0x100 // Fixed speed here for the first horizontal movement, independent of screen extend

	// "spawnChildObjects(0x07a69e)" replaced by:
	spawnChildObject(0x07a558, 0x00, 30, 0)

	D0.u16 = 0xc0
	objA0.value3e = D0.u16
	objA0.velocity.y = D0.u16
	u16[A0 + 0x40] = 0x10
	objA0.flags38 &= ~0x01
}

//# address-hook(0x07a35e) end(0x07a386)
function void fn07a35e()
{
	if (objA0.flags38 & 0x04)
	{
		objA0.base_state = 0x08
		objA0.flags38 &= ~0x40
		objA0.velocity.x = -BossMidSSZ1.getMovementSpeed()
		objA0.countdown_value = BossMidSSZ1.getMoveTime() - 1
		if (!original_mode)
		{
			// Original S3&K version moves with usual speed here, but shorter time
			//  -> S3AIR changes that to use double time, but moving much slower, as this is closer to Sonic 1 GHZ boss
			objA0.velocity.x /= 4
			objA0.countdown_value = objA0.countdown_value * 4 + 3
		}
		objA0.countdown_callback = 0x07a39a
	}
}

//# address-hook(0x07a39a) end(0x07a3a6)
function void fn07a39a()
{
	objA0.base_state = 0x0a
	objA0.flags38 |= 0x40

	if(!original_mode)
		objA0.render_flags ^= render_flag.FLIP_X
}

//# address-hook(0x07a3a8) end(0x07a3cc)
function void fn07a3a8()
{
	if (!original_mode)
	{
		// Keep on hovering
		fn0847e6()
		char.position.y += s32(char.velocity.y) << 8
	}

	if (objA0.flags38 & 0x08)
	{
		objA0.flags38 &= ~0x08
		objA0.base_state = 0x08
		objA0.flags38 &= ~0x40
		if (!original_mode)
			objA0.velocity.x = (objA0.velocity.x < 0) ? BossMidSSZ1.getMovementSpeed() : -BossMidSSZ1.getMovementSpeed()
		else
		{
			objA0.velocity.x = -objA0.velocity.x
			objA0.render_flags ^= render_flag.FLIP_X
		}
		objA0.countdown_value = BossMidSSZ1.getMoveTime() * 2 - 1
	}
}

//# address-hook(0x07a496) end(0x07a4ca)
function void fn07a496()
{
	// s8[A0 + 0x3c] is the current angle of the chain link and wrecking ball, inside range -0x40 .. 0x40
	// s8[A0 + 0x3a] is the current direction of angular movement (can be only -1 or 1)

	bool directionChange = (u8[A0 + 0x3c] <= 0x40)
	D0.u8 = u8[A0 + 0x3c] - 0x40
	if (D0.u8 < 0x80)
	{
		s8[A0 + 0x3a] = -s8[A0 + 0x3a]
		A1 = 0xffff0000 + u16[A0 + 0x44]
		if ((s16[A1 + 0x18] > 0 && !original_mode) || (original_mode && (objA1.render_flags & render_flag.FLIP_X)))
		{
			directionChange = !directionChange
		}
		if (!directionChange)
		{
			// Make Mecha Sonic turn around now and fly over to the other side
			u8[A1 + 0x38] |= 0x08
		}
	}
	s8[A0 + 0x3c] += s8[A0 + 0x3a]

	MoveWithParent()
}

//# address-hook(0x07a500) end(0x07a50e)
function void fn07a500()
{
	A1 = 0xffff0000 + u16[A0 + 0x46]
	if (objA1.update_address == 0x07a428 && !original_mode)
	{
		// This is the first chain link element, directly connected to the capsule
		// ...and a good place to translate the linear angular movement into something more like actual Sonic 1 GHZ boss
		s8[A0 + 0x3c] = lookupSin(s8[A1 + 0x3c]) / 4
	}
	else
	{
		// Get angle from parent object in linked list
		s8[A0 + 0x3c] = s8[A1 + 0x3c]
	}
	D2.u8 = objA0.value3a
	fn084c42()
}








// Edit functions that change MTZ boss collision and position in AIR for Original Mode
// Functions taken from bosses\boss_ssz_mid2.lemon
//# address-hook(0x07a72c) end(0x07a7e0)
function void fn07a72c()
{
	objA0.mapping_offset = 0x06820c
	objA0.sprite_attributes = 0x052e
	objA0.render_flags |= render_flag.WORLD
	objA0.sprite_priority = 0x0180
	objA0.position.x.u16 = 0x1700
	objA0.position.y.u16 = 0x0300
	objA0.animation.sprite = 0x0a
	objA0.base_state += 2
	objA0.collision_attributes = collision.size.16x24
	boss.remaining_hits = 8
	u8[A0 + 0x3c] = 0x07

	u16[0xfffffaf0] = objA0.position.x.u16
	u16[0xfffffaf4] = objA0.position.y.u16
	s16[0xfffffaf8] = 0
	s16[0xfffffafa] = 0x100

	objA0.box_size.x = 0x20
	if (!original_mode)
		objA0.box_size.y = 0x20
	objA0.flags2e = 0
	u8[A0 + 0x30] = 0
	u8[A0 + 0x1d] = 0x40
	objA0.flags38 = 0x27
	objA0.value3a = 0x27

	// "spawnChildObjects(0x0681bc)" replaced by:
	spawnChildObject(0x067d0a, 0x00, 0, -32)

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x07ad8a
		u32[A1 + 0x34] = A0
	}

	A2 = 0xfffffa82
	u8[(A2+=1)-1] = 0x10
	u8[(A2+=1)-1] = 0
	u8[(A2+=1)-1] = 3
	u8[(A2+=1)-1] = 0
	u8[(A2+=1)-1] = 1
	u8[(A2+=1)-1] = 0
}

//# address-hook(0x07a98a) end(0x07a9d0)
function void fn07a98a()
{
	if (objA0.value3a != 0)
	{
		--objA0.value3a
	}
	else
	{
		objA0.value3b = 0xff
	}

	if (objA0.flags38 >= 0x27)
	{
		--objA0.flags38
	}

	fn07b12e()

	if (u16[0xfffffaf4] < 0x03b0)
	{
		if (!original_mode)
		{
		// Move down if hit while entering from above, i.e. before reaching his normal height
			++u16[0xfffffaf4]
		}
		u16[0xfffffafa] = 0
	}

	if (u8[A0 + 0x30] == 0)
	{
		if (objA0.value3b != 0)
		{
			objA0.value3b = 0x80
		}
		objA0.value26 += 2
	}

	fn07a8da()
}

//# address-hook(0x07afa4) end(0x07aff0)
function void fn07afa4()
{
	if (!original_mode)
	{
		// Avoid the decoy being culled too long while coming in from above
		objA0.box_size.y = 0x20
	}

	if (s8[A0 + 0x3c] >= 0)
	{
		--u8[A0 + 0x3c]
		if (s8[A0 + 0x3c] < 0)
		{
			objA0.collision_attributes = (collision.flag.SPECIAL | collision.size.16x16)
		}
	}

	UpdateMovementSimple()

	objA0.velocity.y -= 0x20
	if (objA0.velocity.y >= 0x0180)
		objA0.velocity.y = 0x0180

	if (objA0.velocity.y >= 0 && objA0.position.y.u16 >= 0x042c)
	{
		objA0.position.y.u16 = 0x042c
		u16[A0 + 0x38] = 0x042c
		u8[A0 + 0x32] = 1
		objA0.base_state += 2
		fn07b0a8()
	}

	fn07b0c2()
	fn07affc()
}






// Add a check for teleporter beams that cross the vertical wrap boundary in SSZ and make sure they follow the player.
// Function taken from objects\level\teleporter.lemon. It controls the teleporter beam, used in HPZ/SSZ as well as in the CNZ-to-ICZ teleporter.
// //# address-hook(0x0459b4) end(0x045a64)
/*
function void fn0459b4()
{
	if (level.framecounter.low & 0x01)
	{
		D0.u16 = u16[A0 + 0x44]
		D1.u16 = D0.u16 - camera.position.y.u16
		if (D1.s16 > 0x68)
		{
			D0.u16 = camera.position.y.u16 + 0x68
		}

		objA0.position.y.u16 = D0.u16
		D1.u16 = objA0.position.x.u16
		D2 = u8[A0 + 0x46]
		D3.u16 = D2.u16
		D2.u16 = min(D2.u16, 0x12) + 6
		D3.u16 <<= 3

		A1 = (global.zone == 0x0a || global.zone == 0x16) ? 0x046734 : 0x0467fc
		A1.u16 += D3.u16
		A2 = A0 + 0x18
		u16[A2] = D1.u16 - D2.u16
		u16[A2+2] = u16[(A1+=2)-2] + D0.u16
		u16[A2+4] = u16[(A1+=2)-2]
		u16[A2+6] = D1.u16 + D2.u16
		u16[A2+8] = u16[(A1+=2)-2] + D0.u16
		u16[A2+10] = u16[(A1+=2)-2]
		A2 += 12

		if (objA0.base_state != 0)
		{
			--u8[A0 + 0x46]
			if (s8[A0 + 0x46] >= 0)
			{
				DrawObject()
				return
			}

			objA0.animation.sprite = 0x09
			u16[A0 + 0x16] = 0
			objA0.update_address = 0x01abb6		// Function address of "UnloadObject"
			A1 = 0xffff0000 + objA0.respawn_entry
			u8[A1 + 0x38] = 0
		}
		else
		{
			if (level.framecounter.low & 0x02)
			{
				if (u8[A0 + 0x46] < 0x18)
				{
					++u8[A0 + 0x46]
				}
			}
		}
		DrawObject()
	}
}
*/








// Improve the "imprecise" x velocity calculations for large screen widths in some of Mecha Sonic's attacks.
// These are still very imprecise. The method of base + extend * coefficient is likely not practical.
// Functions taken from bosses\boss_ssz_mecha.lemon

// There is a new version of this in the 18 Nov 2023 preview.
// If a 2024 version of AIR becomes the earliest supported stable version, the new version should be modified for Original Mode and used to replace this.

//# address-hook(0x07b544) end(0x07b574)
function void fn07b544()
{
	if (getScreenWidth() <= 400)
	{
		base.fn07b544()
		return
	}

	// Start backslide
	objA0.base_state = 0x10
#if STANDALONE
//	if (getScreenWidth() > 400)
		D0.s16 = 0x820 + getScreenExtend() * 8
//	else
//		D0.s16 = 0x820 + getScreenExtend() * 5		// Not very precise, but works for both 320 and 400 pixels
#else
	D0.s16 = 0x820
#endif
	D1.s16 = -0x20
	if (objA0.render_flags & render_flag.FLIP_X)
	{
		D0.s16 = -D0.s16
		D1.s16 = -D1.s16
	}
	objA0.velocity.x = D0.u16
	u16[A0 + 0x40] = D1.u16
	objA0.velocity.y = 0
	objA0.flags38 |= 0x04

	// "spawnSimpleChildObjects(0x07d486)" replaced by:
	spawnSimpleChildObjects(0x07c8fe, 2)
}

//# address-hook(0x07b63a) end(0x07b67a)
function void fn07b63a()
{
	if (getScreenWidth() <= 400)
	{
		base.fn07b63a()
		return
	}

	fn08459c()
	UpdateMovementSimple()
	if (objA0.velocity.y < 0)
		return

	// Start mid-air dash
	objA0.base_state = 0x18
#if STANDALONE
	if (getScreenWidth() > 464)
		D0.s16 = 0x7a0 + getScreenExtend() * 5		// increased base speed, since 0x780 juuuuust doesn't reach the screen edge
	else	//	else if (getScreenWidth() > 400)
		D0.s16 = 0x780 + getScreenExtend() * 5
//	else
//		D0.s16 = 0x780 + getScreenExtend() * 3		// Not very precise, but works for both 320 and 400 pixels
#else
	D0.s16 = 0x780
#endif
	D1.s32 = -0x20
	if ((objA0.render_flags & render_flag.FLIP_X) == 0)
	{
		D0.s16 = -D0.s16
		D1.s16 = -D1.s16
	}
	objA0.velocity.x = D0.s16
	s16[A0 + 0x40] = D1.s16
	objA0.velocity.y = 0

	playSound(SFX_SPINDASH_RELEASE)
}

//# address-hook(0x07b790) end(0x07b7b8)
function void fn07b790()
{
	if (getScreenWidth() <= 400)
	{
		base.fn07b790()
		return
	}

	// Start spindash / drop dash
	objA0.base_state = 0x24
#if STANDALONE
//	if (getScreenWidth() > 400)
		D0.s16 = 0x640 + getScreenExtend() * 5
//	else
//		D0.s16 = 0x640 + getScreenExtend() * 3		// Not very precise, but works for both 320 and 400 pixels
#else
	D0.s16 = 0x640
#endif
	D1.u16 = -0x20
	if (objA0.velocity.x >= 0)
	{
		D0.s16 = -D0.s16
		D1.s16 = -D1.s16
	}
	objA0.velocity.x = D0.u16
	u16[A0 + 0x40] = D1.u16
	playSound(SFX_SPINDASH_RELEASE)
}




// Import a fix from newer AIR versions to ensure the crumbling tower at SSZ's end shows all pieces.
// This was added in v24.07.04.0. Once an appropriate version is DAGE's oldest supported version, this function can be removed.
// Function taken from level\12_ssz\ssz_postboss_st_cutscene.lemon
//# address-hook(0x057f3e) end(0x057fbe)
function void fn057f3e()
{
	if (s16[0xffffeec4] >= 0)
		return

	if (objA0.countdown_value != 0)
	{
		--objA0.countdown_value
		if (objA0.countdown_value != 0)
			return

	#if STANDALONE
		// Unload these weird collision objects (we don't need them any more), to make more place for the crumbling tower particles
		for (u32 address = 0xffffb0de; address <= 0xffffca98; address += 0x4a)
		{
			if (u32[address] == 0x057b8e)
				u32[address] = 0
		}
	#endif

		if (allocDynamicObjectStd())
		{
			objA1.update_address = 0x0583be
		}
	}

	if (camera.position.y.u16 < 0x05c0)
	{
		fn058048()
		if (((level.framecounter + 8) & 0x0f) == 0)
		{
			playSound(0xcd)
		}
	}

	D0.u16 = 0x0500
	D1 = u8[A0 + 0x30] - 1
	while (D1.s16 >= 0)
	{
		D0.u16 -= 0x70
		--D1.s16
	}

	D0.u16 -= u8[A0 + 0x31]
	D1.u16 = camera.position.y.u16 - D0.u16
	if (D1.s16 >= 0)
	{
		if (D1.u16 > 2)
			D1 = 2

		camera.position.y.u16 -= D1.u16
		if (camera.position.y.u16 < 0x0110)
			camera.position.y.u16 = 0x0110
	}
}









// When the final boss music starts in Knux SSZ2, edit the level layout for ultrawide resolutions.
// The level wrap causes the chunks to load one row too high past the normal right edge of the level.
// We edit a few chunks from the level's left edge since they're no longer accessible to remove this issue.
// Function taken from bosses\boss_ssz_supermecha.lemon
//# address-hook(0x07b996) end(0x07b9cc)
function void fn07b996()
{
	u8[0xffff80d9] = 0x07
	u8[0xffff80da] = 0x04
	u16[0xffff80e2] = 0x0605

	base.fn07b996()
}




// Let Mecha Sonic get destroyed no matter what after Knux SSZ2 in Original Mode
// Function taken from bosses\boss_ssz_supermecha.lemon
//# address-hook(0x07bc32) end(0x07bc6a)
function void fn07bc32()
{
	--objA0.countdown_value
	if (objA0.countdown_value >= 0)
	{
		DrawObject()
		return
	}

	objA0.countdown_value = 0x1f
	objA0.render_flags &= ~render_flag.VISIBLE
	playMusic(MUSIC_CTRL_FADEOUT)

	if (global.chaos_emeralds < 7 && !original_mode)
	{
		// Mecha Sonic does not get destroyed in this case, we need him to appear in the post-credits scene again
		objA0.update_address = 0x07bc34
		objA0.countdown_callback = 0x07bc36
		DrawObject()
	}
	else
	{
		objA0.update_address = 0x08488a		// Address of "Object.CountdownAndTrigger"
		objA0.position.y.u16 += 0x20
		objA0.countdown_callback = 0x07bc70

		// "spawnSimpleChildObjects(0x07d4ca)" replaced by:
		spawnSimpleChildObjects(0x07ce90, 16)
	}
}








// Adds vertical wrapping to DEZ1 as done in ICZ1
//# address-hook(0x059352) end(0x059358)
function void InitLevelTiles.DEZ1()
{
	u16[0xFFFFEEAA] = 0x07FF  // D.A. Garden added these three
	u16[0xFFFFEEAC] = 0x07F0  // lines in ASM to allow for
	u16[0xFFFFEEAE] = 0x003C  // vertical wrapping.

//	if (camera.position.x.u16 > 0x3300)
//	{
//		u16[0xFFFFEEAA] = 0x0FFF  // D.A. Garden added these three
//		u16[0xFFFFEEAC] = 0x0FF0  // lines in ASM to remove
//		u16[0xFFFFEEAE] = 0x007C  // vertical wrapping after Act 1.
//	}


	D0.u16 = -0x100
	level.vertical_wrap = D0.u16
	u16[0xffffee10] = D0.u16
	u16[0xffffee20] = D0.u16
	Level.GetCameraPosition()
	Level.InitialTilesFill()
}
//# address-hook(0x0593ec) end(0x059488)
// Function taken from level\13_dez\level_dez.lemon
function void fn0593ec()
{
	if (kosinski.waiting_modules == 0)
	{
		global.zone_act = 0x0b01
		camera.update_routine = 0
		dynobjects.routine = 0
		rings.update_routine = 0
		level.boss_encounter = 0
		global.in_extra_stage = 0
		fn04f8f8()

		push(A3)
		push(A2)
		push(A0)
		push(D7)

		fn01c362()
		fn0076a6()

		if (palette_set < 2 || original_mode)
			copyMemory(0xfffffc40, 0x0a993c, 0x40)	// used by original game. No color change needed for new palettes, which are shared between Acts 1 and 2.

		D7 = pop()
		A0 = pop()
		A2 = pop()
		A3 = pop()

		D0.u16 = 0x3600
		D1.u16 = -0x400
		u16[0xffffb010] -= D0.u16
		u16[0xffffb014] -= D1.u16
		u16[0xffffb05a] -= D0.u16
		u16[0xffffb05e] -= D1.u16

		fn04f3b0()

		camera.position.x.u16 -= D0.u16
		camera.position.y.u16 -= D1.u16
		camera.foreground.x.u16 -= D0.u16
		camera.foreground.y.u16 -= D1.u16
		move_area.left -= D0.u16
		move_area.right -= D0.u16
		level.vertical_wrap -= D1.u16
		move_area.bottom.current -= D1.u16
		move_area.bottom.target = move_area.bottom.current
		Level.GetCameraPosition()
		level.scrolling_routine = 0
		u16[0xFFFFEEAA] = 0x0FFF  // D.A. Garden added these three
		u16[0xFFFFEEAC] = 0x0FF0  // lines in ASM to remove
		u16[0xFFFFEEAE] = 0x007C  // vertical wrapping after Act 1.
	}

	WriteScrollOffsets()
}


// When new palettes are enabled, place a dimming plane in front of the background
// Function taken from level\13_dez\level_dez.lemon
//# address-hook(0x059398) end(0x05939c)
function void UpdateLevelScrolling.DEZ1()
{
	#if STANDALONE
		// Draw our own widescreen version of the background
		Renderer.enforceClearScreen(true)
		Renderer.enableDefaultPlane(0, false)
		DEZ1_CustomSprites()
	#endif

	call 0x0593a0 + level.scrolling_routine
}




//# address-hook(0x07ddb4) end(0x07de24)
function void fn07ddb4()
{
	A1 = 0x07dda4
	if (InitBoss(0x07ddbe))
		return

	objA0.value26 = MUSIC_MINIBOSS_2
	StartBossFight()

#if STANDALONE
	if (getScreenWidth() >= 400)
	{
		level.bossarea.left = 0x3740 - getScreenWidth() / 2
		level.bossarea.right = level.bossarea.left + getScreenExtend() * 2

		if (isMainCharacter(CHARACTER_KNUCKLES))
		{
			level.bossarea.right += 0x0a
			u8[0xffff82e0] = 0x8f
			u8[0xffff835a] = 0x8f
			u8[0xffff83d4] = 0x8f
		}
	}
	else if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		level.bossarea.right += 0x14
		u8[0xffff82e0] = 0x8f
		u8[0xffff835a] = 0x8f
		u8[0xffff83d4] = 0x8f
	}

#endif

	objA0.update_address = 0x07de28
	objA0.countdown_callback = 0x07de2c

	setupObjectAttributesFull(0x07ef46)

	objA0.base_state = 0
	boss.remaining_hits = 0
	u8[A0 + 0x42] = 0
	u16[A0 + 0x3a] = 0x4000
	u16[A0 + 0x3c] = 0x8000

	// "spawnChildObjects(0x07ef8e)" replaced by:
	spawnChildObject(0x07e768, 0x00, 0, -4)

	// "spawnSimpleChildObjects(0x07ef96)" replaced by:
	spawnSimpleChildObjects(0x07e80e, 8)

	requestLoadingPatterns(0x7b)
	Kosinski.addToDMAQueue(0x1805a0, 0x8000)

	loadPaletteLine1(0x07effc)
}



function u16 deltaByScreenWidth()
{
	if (getScreenWidth() <= 400)
		return 0
	else
 		return ((getScreenWidth() - 400) / 2)
}



function u32 scaleOnScreenWidth()
{
	u32 scale = 0x10000
	if (getScreenWidth() == 416)
		scale = 0x10a3d
	else if (getScreenWidth() == 432)
		scale = 0x1147b
	else if (getScreenWidth() == 448)
		scale = 0x11eb9
	else if (getScreenWidth() == 464)
		scale = 0x128f6
	else if (getScreenWidth() == 480)
		scale = 0x13334
	else if (getScreenWidth() == 496)
		scale = 0x13d70

	return scale
}




function void DEZ1_CustomSprites()
{
	DEZ1_DrawBackground()
	// Sprite mask introduced to hide the laser for the Act 1 boss must work during pause and must be made longer for ultrawide
	Renderer.addSpriteMaskWorld(0x3640, 0x340, 0x0200, 0x30, 0x9f80, 1)
}




function void DEZ1_DrawBackground()
{
	if (getScreenWidth() > 464)
		Renderer.drawCustomSprite("bg_dez1_496", getScreenWidth()/2, 0, 0x00, 0, 0x1100)
	else if (getScreenWidth() > 432)
		Renderer.drawCustomSprite("bg_dez1_464", getScreenWidth()/2, 0, 0x00, 0, 0x1100)
	else
		Renderer.drawCustomSprite("bg_dez1", getScreenWidth()/2, 0, 0x00, SPRITE_FLAG_FULLY_OPAQUE, 0x1100)
	if (palette_set >= 2 && !original_mode)											// if new palettes,
		Renderer.drawCustomSprite("blackscreen", 0, 0, 0x00, 0, 0x1101, 0, 0x40)	// dim background
}

function void DEZ2_DrawBackground()
{
	if (palette_set < 2 || original_mode)
	{
		if (original_mode)
			Renderer.drawCustomSprite("bg_dez2_classic", 0, 0, 0x00, 0, 0x1100)
		else
			Renderer.drawCustomSprite("bg_dez2", getScreenWidth()/2, 0, 0x00, SPRITE_FLAG_FULLY_OPAQUE, 0x1100)		
	}
	else
	{
		Renderer.drawCustomSprite("bg_dez2_new", getScreenWidth()/2, 0, 0x00, SPRITE_FLAG_FULLY_OPAQUE, 0x1100)		
	}

}




// Custom function to draw a background wall in certain areas of DEZ
function void DEZ.drawBackgroundWall(u16 px, u16 py, u16 width)
{
	for (u16 i = 0; i < width; i += 0x80)
	{
		Renderer.drawCustomSprite("bg_dez_wall", px + i - camera.foreground.x.u16, py - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x1c00)
	}
}





// Disable a camera fix between DEZ1 and DEZ2 in Original Mode
// Function taken from scripts\bosses\boss_dez1.lemon
//# address-hook(0x07e420) end(0x07e446)
function void fn07e420()
{
	fn07eeee()
	if (objA0.velocity.y >= 0)
	{
		objA0.update_address = 0x07e44c
		fn05fd88()

		A1 = 0xffffb000
	#if STANDALONE
		if (!original_mode)
			objA1.flags2e = 0 // Fixes the camera at the start of act 2; #contributed by iCloudius
	#endif
		objA1.render_flags &= ~render_flag.FLIP_X
		objA1.state = char.state.STANDING
		objA1.state.former = char.state.RUNNING
		objA1.flags2a &= ~char.flag.FACING_LEFT
	}
	fn07e44c()
}



// Add background changes to DEZ2 to return indoors in some areas
//# address-hook(0x05951e) end(0x059522)
// Function taken from level\13_dez\level_dez.lemon
function void UpdateLevelScrolling.DEZ2()
{
//	#if STANDALONE
		// Draw our own widescreen version of the background
		Renderer.enforceClearScreen(true)
		Renderer.enableDefaultPlane(0, false)

	DEZ2_CustomSprites()
//	#endif

	call 0x059526 + level.scrolling_routine
}


function void DEZ2_CustomSprites()
{
		// Post-boss floor adjustments for time attack modes are here.
		if (u16[0xffffb010] > 0x3400 && u16[0xffffb014] < 0x0350 && (time_attack == 1 || time_attack == 2))
		{
			level.vertical_wrap = 0x0280
			move_area.bottom.target = 0x0280
			zeroMemory(0xffff8328, 0x10)
			u16[0xffff8398] = 0x0b00	// remove the floor after the boss to replace it with the final boss floor
			zeroMemory(0xffff839a, 0x0e)
		//	u16[0xffff82b8] = 0x0f00	// put a right edge on the ceiling

			u64 key = "dez2_finalboss_floor_new"
			if (palette_set < 2 || original_mode)
				key = "dez2_finalboss_floor_old"
			for (u16 i = 0; i < 9 * 0x80; i += 0x80)
			{
				Renderer.drawCustomSprite(key, 0x3840 + i - camera.foreground.x.u16, 0x0340 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4c00)
			}
			Renderer.drawCustomSprite("dez2_finalboss_static", 0x3b0c - camera.foreground.x.u16, 0x02e0 - camera.foreground.y.u16, 0, SPRITE_FLAG_PRIO, 0x4c00)
		}


		// Calls to draw things other than just bg_dez2
		if (palette_set < 2 || original_mode)	// if we're not using new visuals,
		{
			DEZ2_DrawBackground()
			call 0x059526 + level.scrolling_routine	// ignore all code below regarding the indoor/outdoor swapping
			return
		}

		if (camera.position.x.u16 <= 0x0300)				// this check avoids a background drawing bug when transitioning from Act 1 to Act 2
		{
			DEZ2_DrawBackground()
		}
		
		// Background walls are generated here.
		DEZ.drawBackgroundWall(0x0f00, 0x0780, 0x0200)

		DEZ.drawBackgroundWall(0x1540, 0x07c0, 0x0100)
		DEZ.drawBackgroundWall(0x13c0, 0x0840, 0x0280)
		DEZ.drawBackgroundWall(0x13c0, 0x08c0, 0x0280)
		DEZ.drawBackgroundWall(0x1540, 0x0940, 0x0100)
		DEZ.drawBackgroundWall(0x1540, 0x09c0, 0x0100)
		DEZ.drawBackgroundWall(0x14c0, 0x0a40, 0x0180)
		DEZ.drawBackgroundWall(0x1540, 0x0ac0, 0x0100)

		DEZ.drawBackgroundWall(0x1d80, 0x0a40, 0x0080)
		DEZ.drawBackgroundWall(0x1cc0, 0x0ac0, 0x0200)
		DEZ.drawBackgroundWall(0x1c40, 0x0b40, 0x0300)
		DEZ.drawBackgroundWall(0x1c40, 0x0bc0, 0x0300)
		DEZ.drawBackgroundWall(0x1c40, 0x0c40, 0x0080)
		DEZ.drawBackgroundWall(0x1d80, 0x0c40, 0x0080)
		DEZ.drawBackgroundWall(0x1ec0, 0x0c40, 0x0080)

		DEZ.drawBackgroundWall(0x1d80, 0x0100, 0x0180)
		DEZ.drawBackgroundWall(0x1d80, 0x0180, 0x0180)
		DEZ.drawBackgroundWall(0x1d80, 0x0200, 0x0180)

		DEZ.drawBackgroundWall(0x2500, 0x0900, 0x0200)
		DEZ.drawBackgroundWall(0x2500, 0x0980, 0x0200)

		DEZ.drawBackgroundWall(0x3380, 0x0400, 0x0300)
		DEZ.drawBackgroundWall(0x3380, 0x0480, 0x0300)

		// The else and else if statements below account for the two acts' minor differences in palette.
		// DAGE uses identical palettes for both acts in v1.3.0, so the palette-swapping parts of this function are reserved for the S3&K / ROM hack palette.

		if (camera.position.x.u16 >= 0x20C0 && camera.position.y.u16 >= 0x08c0)
		{
//			if (palette_set < 2 || original_mode)
//			{
//				A3 = 0x0a98bc + 0x40	// find final palette line of DEZ1
//				u32[0xfffffc60] = u32[A3]
//				u32[0xfffffc64] = u32[A3 + 0x04]
//				u32[0xfffffc68] = u32[A3 + 0x08]
//				u32[0xfffffc6c] = u32[A3 + 0x0C]
//				u32[0xfffffc70] = u32[A3 + 0x10]
//				u32[0xfffffc74] = u32[A3 + 0x14]
		//	u32[0xfffffc78] = u32[A3 + 0x18]	// commented out to avoid overwriting the Act 1 palette cycle
		//	u32[0xfffffc7c] = u32[A3 + 0x1C]	// commented out to avoid overwriting the Act 1 palette cycle
//			}
			DEZ1_DrawBackground()
		}
		else if ((u16[0xffffb010] >= 0x0f00 && u16[0xffffb010] <= 0x15c0 && u16[0xffffb014] >= 0x0800) || (camera.position.x.u16 >= 0x0f08 && u16[0xffffb010] <= 0x13c0 && u16[0xffffb014] >= 0x0780))
		{
//			if (palette_set < 2 || original_mode)
//			{
//				A3 = 0x0a98bc + 0x40	// find final palette line of DEZ1
//				u32[0xfffffc60] = u32[A3]
//				u32[0xfffffc64] = u32[A3 + 0x04]
//				u32[0xfffffc68] = u32[A3 + 0x08]
//				u32[0xfffffc6c] = u32[A3 + 0x0C]
//				u32[0xfffffc70] = u32[A3 + 0x10]
//				u32[0xfffffc74] = u32[A3 + 0x14]
		//	u32[0xfffffc78] = u32[A3 + 0x18]	// commented out to avoid overwriting the Act 1 palette cycle
		//	u32[0xfffffc7c] = u32[A3 + 0x1C]	// commented out to avoid overwriting the Act 1 palette cycle
//			}
			DEZ1_DrawBackground()
		}
		else if (camera.position.x.u16 >= 0x1F40 && camera.position.y.u16 >= 0x0856 && camera.position.x.u16 < 0x2720 && camera.position.y.u16 < 0x0a30)
		{
//			if (palette_set < 2 || original_mode)
//			{
//				A3 = 0x0a98bc + 0x40	// find final palette line of DEZ1
//				u32[0xfffffc60] = u32[A3]
//				u32[0xfffffc64] = u32[A3 + 0x04]
//				u32[0xfffffc68] = u32[A3 + 0x08]
//				u32[0xfffffc6c] = u32[A3 + 0x0C]
//				u32[0xfffffc70] = u32[A3 + 0x10]
//				u32[0xfffffc74] = u32[A3 + 0x14]
		//	u32[0xfffffc78] = u32[A3 + 0x18]	// commented out to avoid overwriting the Act 1 palette cycle
		//	u32[0xfffffc7c] = u32[A3 + 0x1C]	// commented out to avoid overwriting the Act 1 palette cycle
//			}
			DEZ1_DrawBackground()
		}
		else
		{
//			if (palette_set < 2 || original_mode)
//			{
//				A3 = 0x0a991c + 0x40	// find final palette line of DEZ2
//				u32[0xfffffc60] = u32[A3]
//				u32[0xfffffc64] = u32[A3 + 0x04]
//				u32[0xfffffc68] = u32[A3 + 0x08]
//				u32[0xfffffc6c] = u32[A3 + 0x0C]
//				u32[0xfffffc70] = u32[A3 + 0x10]
//				u32[0xfffffc74] = u32[A3 + 0x14]
//				u32[0xfffffc78] = u32[A3 + 0x18]
//				u32[0xfffffc7c] = u32[A3 + 0x1C]
//				Renderer.drawCustomSprite("bg_dez2", getScreenExtend() - 40, 0, 0x00, 0, 0x1100)
//			}
//			else
				DEZ2_DrawBackground()
		}
}



// End lenient roll maintenance in DEZ centrifuge tubes to avoid strange behaviors.
// Function taken from objects\13_dez\dez_centrifugetube.lemon
function void fn048fa4()
{
	if (u8[A1 + 0x20] == char.state.ROLLING || u8[A1 + 0x20] == char.state.SPINDASH)
	{
		if (A1 == 0xffffb000)
			air_time = 5
		else
			air_time_p2 = 5
	}
	base.fn048fa4()
}





// In Original Mode, electric bolt hazards in DEZ still harm players with Lightning Shields as in S3&K.
// Function taken from objects\13_dez\dez_electricbolt.lemon
//# address-hook(0x047892) end(0x0478b8)
function void fn047892()
{
	objA0.mapping_offset = 0x04792e
	objA0.sprite_attributes = 0x0379
	objA0.render_flags |= render_flag.WORLD
	objA0.box_size.x = 0x08
	objA0.box_size.y = 0x18
	objA0.sprite_priority = 0x0280
	objA0.collision_attributes = (collision.flag.THREAT | collision.size.4x24)

	if (!original_mode)
	{
		// Lightning shield protects from the bolt damage
		objA0.flags2b = char.bonus.SHIELD_LIGHTNING
	}

	fn0478be()
}




// In Original Mode, remove fixes from the antigrav ball in DEZ.
// Function taken from objects\13_dez\dez_hovermachine.lemon
//# address-hook(0x04952a) end(0x0495d6)
function void fn04952a()
{
	D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + 0x40
	if (D0.u16 < 0x80)
	{
		LookupSinCos()
		D0.s16 = (D0.s16 >> 2) + 0x20
		D2.u16 = D0.u16 + 0x20
		D1 = objA1.position.y.u16 - objA0.position.y.u16 + D0.u16

		if (D1.u16 < D2.u16 && u8[A1 + 0x05] < 0x04 && u8[A1 + 0x2e] == 0)
		{
			D1.u16 -= D0.u16
			if (D1.s16 >= 0)
			{
				D1.u16 = (D1.u16 ^ 0xffff) * 2
			}
			D1.u16 += D0.u16
			D1.s16 = (-D1.s16) >> 4
			objA1.position.y.u16 += D1.u16
			objA1.velocity.y = 0
			objA1.flags2a |= char.flag.IN_AIR
			objA1.flags2a &= ~char.flag.CONTROL_LOCK
			u8[A1 + 0x2f] = 0
			u8[A1 + 0x40] = 0
			u16[A1 + 0x1c] = 0x01

			if (!original_mode)
			{
				// Remove spindash flag
				u8[A1 + 0x3d] = 0
			}

			if ((level.framecounter.low & 0x0f) == 0)
			{
				playSound(0xd9)
			}

			if (u8[A1 + 0x27] == 0)
			{
				objA1.state = char.state.RUNNING
				u8[A1 + 0x27] = 0x01
				u8[A1 + 0x30] = 0x7f
				u8[A1 + 0x31] = 0x08

			#if STANDALONE
				// Fix for bug when Tails carries other player and gets caught by the hover effect
				if (u8[A1 + 0x38] == CHARACTER_TAILS && tails.carrying && !original_mode)
				{
					u8[0xffffb000 + 0x2a] |= char.flag.IN_AIR
					u8[0xffffb000 + 0x2e] = 0
				}
			#endif
			}
		}
	}
}





// Import Legobouwer's version of the collapsing DEZ staircase for consistency with AIR, overwriting the hand-ported version from previous versions of DAGE.
// This staircase subtype vibrates for one second (60 frames) when hit from underneath, then becomes subtype 0x03 (which calls the same function as subtype 0x01)
// The original ROM hack uses these for a staircase that can get hit from below to drop it, so Original Mode needs them too.
// Other staircase functions are in objects\13_dez\dez_staircase.lemon
//# address-hook(0x047774) end(0x0477c0)
function void fn047774()
{
	if (u16[A0 + 0x30] == 0)
	{
		D0.u8 = u8[A0 + 0x32] & 0x0c
		if (D0.u8 != 0)
		{
			u16[A0 + 0x30] = 0x3c
		}
		return
	}
	else
	{
		--u16[A0 + 0x30]
		if (u16[A0 + 0x30] == 0)
		{
			++objA0.subtype2c
			playSound(0xc0)
			return
		}
	}

	A1 = A0 + 0x34
	D0.u16 = u16[A0 + 0x30]
	D0.u8 >>= 2
	D0.u8 &= 0x01
	u16[(A1+=2)-2] = D0.u16
	D0.u8 ^= 0x01
	u16[(A1+=2)-2] = D0.u16
	D0.u8 ^= 0x01
	u16[(A1+=2)-2] = D0.u16
	D0.u8 ^= 0x01
	u16[(A1+=2)-2] = D0.u16
}





// Revert DEZ energy tunnel launcher improvements put into AIR when playing Original Mode.
// Functions taken from objects\13_dez\dez_retracting spring.lemon
//# address-hook(0x048270) end(0x048316)
function void fn048270()
{
	A4 = A0 + 0x30
	A1 = 0xffffb000
	fn048370()

	A4 = A0 + 0x38
	A1 = 0xffffb04a
	fn048370()

	if (objA0.countdown_value != 0)
	{
		if (!original_mode)
		{
			objA0.flags2e = min(objA0.flags2e, 40)		// Use time intervals of 0.67 instead of 1.0 second
		}

		--objA0.flags2e
		if (objA0.flags2e == 0)
		{
			objA0.flags2e = 60
			if (objA0.value2f != 0)
			{
				--objA0.value2f
				playSound((objA0.value2f == 7) ? 0xad : 0xa7)
				if (objA0.value2f == 7)
				{
					// Create tunnel controller object
					if (allocDynamicObjectAfterA0())
					{
						objA1.update_address = 0x0484b0
						objA1.position.x.u16 = objA0.position.x.u16
						objA1.position.y.u16 = objA0.position.y.u16
						u8[A1 + 0x2c] = objA0.subtype2c
						u8[A1 + 0x30] = u8[A0 + 0x30]
						u8[A1 + 0x38] = u8[A0 + 0x38]
					}
					objA0.update_address = 0x04831c
				}
			}
		}

		--objA0.animation.sprite
		if (objA0.animation.sprite == 0)
			objA0.animation.sprite = 2

		objA0.compound.sprite1.animation.sprite = (objA0.flags2e & 0x01) ? objA0.value2f : 0
	}

	DrawOrUnloadObject()
}

//# address-hook(0x048370) end(0x048422)
function void fn048370()
{
	u16 dx = objA1.position.x.u16 - objA0.position.x.u16 + 8
	u16 dy = objA1.position.y.u16 - objA0.position.y.u16 + 0x10
	if (dx < 0x10 && dy < 0x20)
	{
		if ((u8[A1 + 0x2a] & char.flag.IN_AIR) == 0 && u8[A1 + 0x2e] == 0)
		{
			objA1.position.x.u16 = objA0.position.x.u16
			u8[A1 + 0x2a] = (u8[A1 + 0x2a] & ~char.flag.FACING_LEFT) | (objA0.flags2a & char.flag.FACING_LEFT)

			u32 backupA0 = A0
			A0 = A1
			Character.LandingOnGroundNoSpindash()
			A0 = backupA0

			objA1.state = char.state.SPINDASH
			u8[A1 + 0x2e] = 0x81
			u8[A4] = 2
			if (objA0.value2f == 0)
			{
				playSound(0xa6)
				if (A1 == 0xffffb000)
				{
					objA0.countdown_value = 0x3c0a
					u8[A0 + 0x1d] = 0x0a
					playSound(0xa7)
				}
				else
				{
					objA0.countdown_value = 0x3c00
				}

				if (objA0.animation.sprite == 0)
					objA0.animation.sprite = 7
			}
		}
	#if STANDALONE
		else if (u8[A4] == 2 && !original_mode)
		{
			bool jumpOff = (A1 == 0xffffb000) ? (control.player1 & CONTROL_ABC) : (control.tails & CONTROL_ABC)
			if (jumpOff)
			{
				objA1.hitbox_extends.x = 7
				objA1.hitbox_extends.y = 14
				objA1.velocity.x = (u8[A1 + 0x2a] & char.flag.FACING_LEFT) ? -0x200 : 0x200
				objA1.velocity.y = -0x600
				objA1.state = char.state.ROLLING
				objA1.flags2a |= char.flag.IN_AIR | char.flag.ROLLING
				u8[A1 + 0x2e] = 0
				u8[A1 + 0x40] = 1

				playSound(SFX_JUMP)

				u8[A4] = 0
				if (A1 == 0xffffb000)
				{
					objA0.countdown_value = 0
					u8[A0 + 0x1d] = 0
				}
				if (u8[A0 + 0x30] == 0 && u8[A0 + 0x38] == 0)		// Check if both characters left the launcher
				{
					objA0.update_address = 0x04831c
					objA0.flags2e = 30
				}
			}
		}
	#endif
	}
}





// Don't let the retracting spring at the start of DEZ2 make noise as the level starts.
// Function taken from objects\13_dez\dez_retracting spring.lemon
//# address-hook(0x0480d4) end(0x04819c)
function void fn0480d4()
{
	D0.u16 = u16[0xffffb000 + 0x14] - objA0.position.y.u16
	if (D0.s16 >= 0)
	{
		if (D0.s16 >= 0x20 && u16[A0 + 0x34] != objA0.value32)
		{
			if (u16[A0 + 0x34] == 0)
			{
				if (u16[0xffffb010] > 0x0180)	// don't make noise during level intro
					playSound(0x9a)
			}
			u16[A0 + 0x34] += 8
		}
	}
	else
	{
		if (D0.s16 < -0x20 && u16[A0 + 0x34] != 0)
		{
			D1.u16 = objA0.value32
			if (D1.u16 == u16[A0 + 0x34])
			{
				if (u16[0xffffb010] > 0x0180)	// don't make noise during level intro
					playSound(0x9a)
			}
			u16[A0 + 0x34] -= 8
		}
	}

	D0.s16 = u16[A0 + 0x34]
	if (((objA0.flags2a & 0x01) != 0) == ((objA0.flags2a & 0x02) != 0))
	{
		D0.s16 = -D0.s16
	}
	objA0.position.x.u16 = u16[A0 + 0x44] + D0.s16

	D1 = objA0.box_size.x
	D3 = 9
	D4.u16 = objA0.position.x.u16

	push(D4)
	push(D3)
	push(D2)
	push(D1)

	A1 = 0xffffb000
	D6 = 3		// object.flag.P1_ON_OBJECT
	PlatformCheckClimbOnForCharacterA1()
	if (objA0.flags2a & object.flag.P1_ON_OBJECT)
	{
		SpringVertical.ApplyToCharacter()
	}

	D1 = pop()
	D2 = pop()
	D3 = pop()
	D4 = pop()

	A1 = 0xffffb04a
	D6 = 4		// object.flag.P2_ON_OBJECT
	PlatformCheckClimbOnForCharacterA1()
	if (objA0.flags2a & object.flag.P2_ON_OBJECT)
	{
		SpringVertical.ApplyToCharacter()
	}

	Object.animationUpdate(0x0481a2)

	D0.u16 = u16[A0 + 0x44]
	DrawOrUnloadObjectByD0()
}





// Create functions for long (256 px) platform movements that Euka did not port to lemonscript, as they were unused in the vanilla game.
// Most similar routines are in objects\10_lrz\lrz_blockerplatform.lemon but are called from other levels too.
// The original ROM hack uses these platorm movements in DEZ2, so Original Mode needs them too.
//# address-hook(0x02594c) end(0x02595e)
function void fn02594c()
{
	D2.u16 = 0x7f
	fn025974()

	objA0.position.x.u16 = D0.u16 + u16[A0 + 0x30] - 0x80
}

//# address-hook(0x025960) end(0x025972)
function void fn025960()
{
	D2.u16 = 0x5f
	fn025974()

	objA0.position.y.u16 = D0.u16 + u16[A0 + 0x34] - 0x80
}




function void DEZBoss_CustomSprites()
{
	// Draw our own widescreen version of the background
	Renderer.enforceClearScreen(true)
	Renderer.enableDefaultPlane(0, false)
	if (!original_mode)
		DEZ2_DrawBackground()
	else
		Renderer.drawCustomSprite("bg_dezboss_classic", 0, 0, 0x00, 0, 0x1100)	// In base S3&K, the final boss background is actually slightly different
}




// Make greater floor solidity for the final boss in wider screen resolutions
// The extra width is stated by Euka to not have good support beyond 0x40 (must be multiple of 0x20),
// but there's no other way in the widest resolutions.
// Functions taken from level\13_dez\level_dez_boss.lemon
//# address-hook(0x05a7c8) end(0x05a7e6)
function void fn05a7c8()
{
	u16 extraWidth = 0x20
	if (getScreenWidth() >= 464)
		extraWidth = 0x60
	else if (getScreenWidth() > 400)
		extraWidth = 0x40

	objA0.update_address = 0x05a7ec
	objA0.box_size.y = 0x10
	objA0.position.x.u16 = 0x130 + extraWidth
	objA0.position.y.u16 = 0xf0
	objA0.flags2a |= 0x80
	objA0.countdown_value = 0x80
	fn05a7ec()
}

//# address-hook(0x05a7ec) end(0x05a86c)
function void fn05a7ec()
{
	if (global.zone != 0x17)
	{
		UnloadObject()
		return
	}

	u16 extraWidth = 0x20
	if (getScreenWidth() >= 464)
		extraWidth = 0x60
	else if (getScreenWidth() > 400)
		extraWidth = 0x40

	// u16[0xffffeeda] = Position of floor block to fall next (if != 0)
	// u16[0xffffeee8] = Left screen border

	if (u16[0xffffeeda] != 0)
	{
		D1.u16 = u16[0xffffeeda]
		u16[0xffffeeda] = 0
		if (D1.u16 >= u16[0xffffeee8])
		{
			if (allocDynamicObjectAfterA0())
			{
				objA1.update_address = 0x05a872
				objA1.position.x.u16 = D1.u16
				D2.u16 = objA0.countdown_value - 0x20
				if (D2.u16 <= D1.u16)
				{
					u16[0xffffeed8] = D1.u16
				}
			}

			u16[0xffffeee8] += 0x20
			if (D1.u16 >= objA0.countdown_value)
			{
				objA0.position.x.u16 += 0x20
			}
		}
	}

	D0.u16 = camera.foreground.x.u16 & 0xffe0
	D2.u16 = objA0.countdown_value
	if (D0.u16 != D2.u16)
	{
		if (D0.u16 >= D2.u16)
		{
			if (D2.u16 >= u16[0xffffeee8])
			{
				objA0.position.x.u16 += 0x20
			}
		}
		else
		{
			objA0.position.x.u16 -= 0x20
		}
		objA0.countdown_value = D0.u16
	}

	D1.u16 = 0xb0 + extraWidth
	D2 = 0x10
	D3 = 0x10
	D4.u16 = objA0.position.x.u16
	PlatformCheckClimbOn()
}



// Do not apply DEZ final boss finger position fix to Original Mode
// Functions taken from bosses\boss_dez_final1.lemon
//# address-hook(0x080b66) end(0x080b8a)
function void fn080b66()
{
	objA0.base_state = 0x02
	objA0.value39 = 0x03

	// "spawnChildObjects(0x081316)" replaced by:
	spawnChildObject(0x080ce2, 0x00, 0, -16)
	spawnChildObject(0x080ce2, 0x02, -32, -16)
	spawnChildObject(0x080ce2, 0x04, 32, -16)

	objA0.value42 = (objA0.subtype2c == 0) ? -0x80 : 0x80
	objA0.position.y.u16 = (original_mode) ? 0xe3 : 0xe4
	fn080b90()
}

//# address-hook(0x080cca) end(0x080ce0)
function void fn080cca()
{
	objA0.base_state = 0x02
	objA0.position.y.u16 = (original_mode) ? 0xe3 : 0xe4
	A1 = 0xffff0000 + u16[A0 + 0x46]
	u8[A1 + 0x38] &= ~0x02
}




// In Original Mode, revert DEZ final boss behaviors to base S3&K behaviors
// and allow players to rebound into a pit after the final blow
// Functions taken from bosses\boss_dez_final3.lemon
//# address-hook(0x0802b2) end(0x0802be)
function void fn0802b2()
{
	objA0.update_address = 0x0802c0
#if STANDALONE
	// Reset speed to the default one, to handle the case that the boss got defeated right while leaping forward
	if (!original_mode)
		objA0.velocity.x = 0x278

	if (!DEZFinalBoss3.shouldEscapeWithMasterEmerald())
#endif
	{
		u8[0xfffffab8] |= 0x10
	}
}

function bool DEZFinalBoss3.shouldEscapeWithMasterEmerald()
{
	if (original_mode)
		return false
	return DEZFinalBoss3.canPlayerEnterDoomsday()
}

//# address-hook(0x0804d2) end(0x0804ee)
function void fn0804d2()
{
	if ((u8[0xfffffab8] & 0x08) == 0)
	{
		MoveAndFlipWithParent()
	#if STANDALONE
		// This makes the claw in the third phase of the final boss use the proper grabbing frame instead of the opened one, #contributed by mrgrassman14
		if (!original_mode)
			objA0.animation.sprite = 2
	#endif
	}
	else
	{
		objA0.update_address = 0x08565e
		objA0.countdown_callback = 0x0852a0	// Address of "Object.TriggerUnloading()"
	}
}

//# address-hook(0x0801d8) end(0x080202)
function void fn0801d8()
{
	--objA0.position.y.u16
	if ((objA0.position.y.u16 % 3) == 0 && !original_mode)
		--objA0.position.y.u16	// Rise a bit faster
	if (objA0.position.y.u16 > camera.position.y.u16 + 0x50)
		return

	objA0.base_state = 0x04
	objA0.velocity.x = 0x500

	// "spawnChildObjects(0x0681b4)" replaced by:
	spawnChildObject(0x068062, 0x00, 30, 0)

	fn0685e2()
}

//# address-hook(0x0802c0) end(0x080308)
function void fn0802c0()
{
	fn0847e6()
	UpdateMovementStraightSimple()

	if (objA0.position.x.u16 <= camera.position.x.u16 + getScreenWidth() + 0x40)
	{
		DrawObject()
		return
	}

	objA0.update_address = 0x08030e
	u8[0xfffffab8] |= 0x20
	if(!original_mode)
		u8[0xfffffab8] |= 0x18	// Drop the Master Emerald outside; otherwise the hook & emerald fly in from the left again
	objA0.flags38 |= 0x30

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x08642e
	}

	Kosinski.addToDMAQueue(0x0db406, 0xb400)
}

//# address-hook(0x080e2c) end(0x080ede)
function void fn080e2c()
{
	if (u8[A0 + 0x28] != 0)
		return

	D0.u8 = boss.remaining_hits
	if (D0.u8 == 0)
	{
		// Defeated
		objA0.update_address = 0x08565e
		objA0.countdown_value = 0x2f
		objA0.countdown_callback = 0x08029c

		// "spawnSimpleChildObjects(0x083fee)" replaced by:
		spawnSimpleChildObjects(0x083d84, 1)
		if (_equal())
		{
			u8[A1 + 0x2c] = 0x04
		}

		addScore(100)

		if (!original_mode)
		{
			// Search for the floor object
			for (u32 address = 0xffffb094; address < 0xffffcfcb; address += 0x4a)
			{
				if (u32[address] == 0x05a7ec)
				{
					// Create blocker element
					if (allocDynamicObjectStd())
					{
						objA1.update_address = 0x01ec18
						objA1.position.x.u16 = u16[address + 0x2e] + 0xb8
						objA1.position.y.u16 = 0x0080
						objA1.subtype2c = 0x3f
					}
					break
				}
			}
		}
		return
	}

	if (objA0.state == 0)
	{
		objA0.state = 0x20
		playSound(0x6e)
		objA0.flags2a |= 0x40
		if (objA0.flags38 & 0x80)
		{
			A1 = (u8[A0 + 0x1c] == 0) ? 0xffffb000 : 0xffffb04a
			objA1.velocity.x = 0
			u16[A1 + 0x1c] = 0
		}
	}

	// Fix for boss palette damage flash, #contributed by mrgrassman14
	if (!original_mode)
		Boss.updateHitFlashing(3, 0x080ee2, 0x080ee8, 0x080eee)
	else
		Boss.updateHitFlashing(3, 0x080ee2, 0x080ee8, 0x080eec)

	--objA0.state
	if (objA0.state == 0)
	{
		objA0.flags2a &= ~0x40
		u8[A0 + 0x28] = u8[A0 + 0x25]
		if (objA0.base_state >= 0x08)
		{
			// Accelerate after hit
			objA0.velocity.x = 0x800 + getScreenExtend() * 3
		}
	}
}

//# address-hook(0x08029c) end(0x0802b0)
function void fn08029c()
{
	objA0.countdown_value = 0x0f
	objA0.countdown_callback = 0x0802b2

#if STANDALONE
	// Reset speed to the default one, to handle the case that the boss got defeated right while leaping forward
	if (!original_mode)
		char.velocity.x = 0x278

	if (!DEZFinalBoss3.shouldEscapeWithMasterEmerald())
#endif
	{
		u8[0xfffffab8] |= 0x08
	}
}




// Do not set the ring counter to 50 at the start of DDZ in Original Mode.
// Function taken from level\14_ddz\level_ddz.lemon
//# address-hook(0x081554) end(0x0815fc)
function void fn081554()
{
	objA0.base_state = 0x02
	u16[0xfffffa8e] = A0.u16
	objA0.countdown_value = 0x17
	objA0.velocity.x = 0x0400
	player1.camera_lock = 0xff
	level.boss_encounter = 1
	u32[0xfffffa82] = 0x010000
	u32[0xfffffa8a] = 0x0800

	A1 = 0xffffb000
	u8[A1 + 0x0a] |= 0x80
	objA1.state = char.state.ROLLING
	u8[A1 + 0x2a] = 0
	u8[A1 + 0x2e] = 0x81
	objA0.position.x.u16 = camera.position.x.u16 - 0x20
	objA0.position.y.u16 = camera.position.y.u16 + 0x20

	copyMemory(0xfffffab0, 0x081602, 8)
	level.vertical_wrap = 0
	move_area.bottom.current = 0x0120
	move_area.bottom.target = 0x0120

	A1 = 0xffffb04a
	zeroMemory(0xffffb04a, 0x48)

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x082722
	}

	Kosinski.addToDMAQueue(0x18322a, 0x5b60)

	if (!original_mode)
	{
		// Start with 50 rings now already, that looks better and prevents an unnecessary music tempo change
		ring_counter = 50
	}
}





// Play the sound effect from base S3&K when transforming in DDZ in Original Mode.
// Also set the ring counter to 50 "late" in Original Mode.
// Note that several STANDALONE references are left here as bug fixes.
// Function taken from level\14_ddz\level_ddz.lemon
//# address-hook(0x08160a) end(0x081676)
function void fn08160a()
{
	MoveWithGravity20()

	--objA0.countdown_value
	if (objA0.countdown_value >= 0)
		return

	// Hyper transformation
	objA0.base_state = 0x04
	objA0.flags38 |= 0x80

	if (original_mode)
	{
		// Rings already got set to 50 in standalone, see "fn081554"
		ring_counter += 50
	}

	super.palettefx.state = 1
	super.palettefx.timer = 0x0f
#if STANDALONE
	if (isMainCharacter(CHARACTER_TAILS))
	{
		super.active.tails = 1
	}
	else
#endif
	{
		super.active = 1
	}
	super.ring_dec.frames = 60
	u32[0xffffb000 + 0x0c] = 0x146816		// "char.mapping_offset"
#if STANDALONE
	if (isMainCharacter(CHARACTER_TAILS))
	{
		u8[0xffffb000 + 0x20] = char.state.TAILS_TRANSFORM
	}
	else
#endif
	{
		u8[0xffffb000 + 0x20] = char.state.TRANSFORMING
	}
	u8[0xffffb000 + 0x2e] = 0x81
	global.move.speedcap = 0xa00
	global.move.acceleration = 0x30
	global.move.deceleration = 0x100
	u8[0xffffb000 + 0x35] = 0
	u8[0xffffb000 + 0x2b] |= char.bonus.INVINCIBLE

	if (!original_mode)
		playSound(SFX_SUPERTRANSFORM)
	else
		playSound(0x46)
}






// Remove DDZ movement speed adjustment introduced by AIR when playing in Original Mode
// Function taken from level\14_ddz\level_ddz.lemon
//# address-hook(0x082772) end(0x082830)
function void fn082772()
{
	bool goto0827a8 = false
	A1 = 0xffffb000
	if (u8[A1 + 0x34] != 0)
	{
		u8[A1 + 0x26] += 0x10
		if (u8[A1 + 0x34] < 0x1e)
		{
			goto0827a8 = true
		}
		else
		{
			objA0.velocity.x = 0
			objA0.velocity.y = 0
			D2 = u32[0xfffffa82] >> 8
			D2.s16 = -D2.s16
			D3 = 0
		}
	}
	else
	{
		u8[A1 + 0x26] = 0
		u8[A1 + 0x2a] = 0
		goto0827a8 = true
	}

	if (goto0827a8)
	{
		D0 = 0x40
		D2 = objA0.velocity.x
		D3 = 0
		if (D2.u16 != 0)
		{
			if (D2.s16 >= 0)
			{
				D0.s16 = -D0.s16
				D2.u16 += D0.u16
				if (D2.s16 < 0)
				{
					D2 = 0
				}
			}
			else
			{
				D2.u16 += D0.u16
				if (D2.s16 > 0)
				{
					D2 = 0
				}
			}
			objA0.velocity.x = D2.u16
		}

		D0 = 0x40
		D3.u16 = objA0.velocity.y
		if (D3.u16 != 0)
		{
			if (D3.s16 >= 0)
			{
				D0.s16 = -D0.s16
				D3.u16 += D0.u16
				if (D3.s16 < 0)
				{
					D3 = 0
				}
			}
			else
			{
				D3.u16 += D0.u16
				if (D3.s16 > 0)
				{
					D3 = 0
				}
			}
			objA0.velocity.y = D3.u16
		}

		// Evaluate player input
		if (control.pad1 != 0 && player1.control_override == 0)
		{
			D0.u16 = (control.pad1.state & CONTROL_DPAD) * 4

			// Check if jump button pressed
			if (control.pad1.pressed & CONTROL_ABC)
			{
				if (u8[A1 + 0x34] == 0)
				{
					// Values there are vectors in the pressed direction of length 0x0600 (incl. diagonals, and with opposites cancelling out)
					D2.s16 = s16[0x082872 + D0.u16]
					D3.s16 = s16[0x082874 + D0.u16]
					if (!original_mode)
					{
						// Weaken the effect to make the boss fights harder
						D2.s16 = D2.s16 * 3/5
						D3.s16 = D3.s16 * 3/5
					}
					objA0.velocity.x = D2.s16
					objA0.velocity.y = D3.s16
				}
			}
			if (D0.u16 != 0)
			{
				D4.s16 = u16[0x082832 + D0.u16]
				D5.s16 = u16[0x082834 + D0.u16]
				D2.s16 += D4.s16
				D3.s16 += D5.s16
			}
		}
	}

	objA1.velocity.x = D2.u16
	objA1.velocity.y = D3.u16
}






// Remove a change to DDZ Boss 1 missiles in Original Mode.
// Function taken from level\14_ddz\ddz_missile.lemon
//# address-hook(0x082a82) end(0x082aa4)
function void fn082a82()
{
	if (global.framecounter.low & 0x03)
	{
		// Rotate towards player
		A1 = A0
		A2 = 0xffffb000
		fn08622c()

		D0.u8 -= u8[A0 + 0x3c]
	
		if (D0.s8 == 0 && !original_mode)	// originally an if statement for STANDALONE
			return
	
		D1.s16 = (D0.s8 < 0) ? -2 : 2
		u8[A0 + 0x3c] += D1.u8
	}
}





// Load SSZ chunks/blocks/tiles in outro
// Function taken from level\outro\level_outro.lemon
//# address-hook(0x05adc0) end(0x05ae06)
function void fn05adc0()
{
	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x05e18a
	}

	push(A3)
	push(A2)
	push(A0)
	push(D7)

//	Kosinski.addToDecompressionQueue(0x1d17a6, 0xffff0000)	// SSZ2 chunks
	System.loadExternalRawData(stringformat("ssz2_chunks_p", global.act + 1), KosinskiRawdataBuffer)		// copy Primary chunks to shared memory
	Kosinski.addToDecompressionQueue(KosinskiRawdataBuffer, 0xffff0000)									// decompress them to their proper RAM (see above)

	Kosinski.addToDecompressionQueue(0x1cf2d4, 0xffff9000)

	Kosinski.addToDMAQueue(0x1cfb44, 0x0000)

	D7 = pop()
	A0 = pop()
	A2 = pop()
	A3 = pop()

	u16[0xffffeec0] += 4
	fn05ae0a()
}




// Undo Outro fixes in Original Mode
// Functions taken from maingame\outro\outro_sonic_tails.lemon
//# address-hook(0x05ded4) end(0x05dfea)
function void fn05ded4()
{
	if ((u8[0xfffffab8] & 0x01) == 0)
		return

	objA0.base_state = 0x04

	// Adjusted velocity to help Master Emerald fall properly into place, #contributed by mrgrassman14
	if (!original_mode)
	{
		objA0.velocity.x = -0x1fb
		objA0.velocity.y = 0x120 - min(getScreenExtend(), 40) / 2
	}
	else
	{
		objA0.velocity.x = -0x200
		objA0.velocity.y = 0x100
	}

	fn05def0()
}

//# address-hook(0x05def0) end(0x05df0c)
function void fn05def0()
{
	if (u16[0xfffffaa4] == 0)
	{
		UpdateMovementStraightSimple()
		return
	}

	objA0.base_state = 0x06
	u16[A0 + 0x46] = u16[0xfffffaa4]

	// Adjust final position of Master Emerald so it appears properly attached, #contributed by mrgrassman14
	if (!original_mode)
	{
		u8[A0 + 0x42] = 0xdf
		u8[A0 + 0x43] = 0x09
	}
	else
	{
		u8[A0 + 0x42] = 0xe0
		u8[A0 + 0x43] = 0x01
	}

	fn05df12()
}

//# address-hook(0x05dfee) end(0x05e084)
function void fn05dfee()
{
	objA0.update_address = 0x05e08a
	objA0.mapping_offset = 0x060486
	objA0.sprite_attributes = 0x026e
	objA0.sprite_priority = 0x0380
	objA0.animation.sprite = 0x01
	objA0.box_size.x = 0x20
	objA0.box_size.y = 0x14
	objA0.render_flags |= render_flag.FLIP_X
	objA0.position.x.u16 = 0x0220 + getScreenExtend()
	objA0.position.y.u16 = 0xb0
	objA0.velocity.x = -0x100 - (getScreenExtend() * 0x40 / 40)		// Faster plane needed

	fn06001e()

	playMusic(MUSIC_CREDITSMEDLEY)

#if STANDALONE
	// Reset frame counter so we can use it to get the current credits music playback position
	level.framecounter = 0

	// Start skippable cutscene again, to reset the timer
	Game.startSkippableCutscene()
#endif

	// "spawnSimpleChildObjects(0x0601ca)" replaced by:
	spawnSimpleChildObjects(0x05ecb4, 2)

	// "spawnChildObjects(0x0601d0)" replaced by:
	spawnChildObject(0x05ebf0, 0x00, 28, 0)

	u8[0xfffffab8] &= ~0x01

	// Spawn the Master Emerald
	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x05de60
		u16[A1 + 0x46] = A0.u16
		objA1.position.x.u16 = 0x0190 + getScreenExtend()
		objA1.position.y.u16 = 0xdc
		u8[A1 + 0x2c] = 0xff
	}

	Kosinski.addToDMAQueue(0x162914, 0x4dc0)

#if STANDALONE
	// Add missing Tornado flame, #contributed by mrgrassman14
	if (!original_mode)
		spawnChildObject(0x05ec3c, 0x00, -10, 12)
#endif
}

//# address-hook(0x05e3c0) end(0x05e3e8)
function void fn05e3c0()
{
	// Medium end pose sprite

#if STANDALONE
	u32 targetAddress = 0x802000 + getMainCharacter() * 0x40
	loadCharacterEndPosePalette(getMainCharacter(), targetAddress, 0)
	targetAddress += 0x180
	loadCharacterEndPosePalette(getMainCharacter(), targetAddress, 0)
#endif

	objA0.base_state = 0x08
	objA0.countdown_value = 0x05
	if (isMainCharacter(CHARACTER_TAILS))
	{
		objA0.render_flags |= render_flag.FLIP_X
	}

#if STANDALONE
	// Flip sprite horizontally to reflect larger sprite's hand/foot position, #contributed by mrgrassman14
	if (isMainCharacter(CHARACTER_SONIC) && objA0.animation.sprite == 0 && !original_mode)
		objA0.render_flags &= ~render_flag.FLIP_X
#endif

	A1 = 0xffffb000
	u8[A1 + 0x2e] = (control_flag.DISABLE_INTERACTION | control_flag.DISABLE_ANIMATION | control_flag.DISABLE_UPDATE)
	objA1.animation.sprite = 0
	DrawObject()
}

//# address-hook(0x05e3ee) end(0x05e40c)
function void fn05e3ee()
{
	// Big end pose sprite

	--objA0.countdown_value
	if (objA0.countdown_value < 0)
	{
		objA0.base_state = 0x12
		++objA0.animation.sprite

	#if STANDALONE
		// Flip sprite horizontally to original position as it was affected by the change in fn05e3c0()
		if (isMainCharacter(CHARACTER_SONIC) && !original_mode)
			objA0.render_flags |= render_flag.FLIP_X
	#endif

		if (allocDynamicObjectStd())
		{
			objA1.update_address = 0x05ef68
		}
	}
	DrawObject()
}






// Move Hyper Sonic end game cutscene, force original AIZ1 palette, and load external chunk data
// Functions taken from level\outro\level_outro.lemon
//# address-hook(0x05abc0) end(0x05ac6c)
function void fn05abc0()
{
	u32 backupA0 = A0
	FadeOutPalette()
	A0 = backupA0

	--u16[0xffffeeda]
	if (s16[0xffffeeda] >= 0)
	{
		LoadTileContentDefault()
		return
	}

	zeroMemory(0xffffac00, 0x400)
	zeroMemory(0xffffb04a, 0x1fb4)

	if (global.super_emeralds < 7)
	{
		u16[0xffffeec0] = 0x24
		fn05adc0()
		return
	}

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x05dfee
	}

	push(A3)
	push(A2)
	push(A0)
	push(D7)

	// Kosinski.addToDecompressionQueue(0x3abc40, 0xffff0000)	// load chunks
	System.loadExternalRawData("aiz1_chunks_s", KosinskiRawdataBuffer)		// copy chunks to shared memory
	Kosinski.addToDecompressionQueue(KosinskiRawdataBuffer, 0xffff0000)		// queue to decompress them to their proper RAM
	Kosinski.addToDecompressionQueue(0x3a374a, 0xffff9000)
	Kosinski.addToDecompressionQueue(0x3a458a, 0xffff9268)

	Kosinski.addToDMAQueue(0x3a566a, 0x0000)
	Kosinski.addToDMAQueue(0x3a944e, 0x17c0)

	D7 = pop()
	A0 = pop()
	A2 = pop()
	A3 = pop()

	u16[0xffffeec0] += 4
	fn05ac70()
}

//# address-hook(0x05ac70) end(0x05acf8)
function void fn05ac70()
{
	if (kosinski.waiting_modules != 0)
	{
		LoadTileContentDefault()
		return
	}

	push(A3)
	push(A2)
	push(A0)
	push(D7)

	global.zone_act = 0
	checkpoint.number = 0x01
	fn01c362()		// loads AIZ1 (Load_Level)
	fn0076a6()		// loads AIZ1 (LoadSolids)
	global.zone_act = 0x0d01
	checkpoint.number = 0

	Level.loadNonfadingPaletteData(0x03)
	Level.loadNonfadingPaletteData(0x2a)
	copyMemory(0xfffffca0, 0x0a97bc, 0x20)	// get Master Emerald palette from SSZ2 palette and put in fade-in palette RAM

	fn04fa4c()		// This loads Knuckles' AIZ background and applies the palette patch.

	// These lines were necessary when new palettes were ROM injections instead of external rawdata.
//	copyMemory(0xfffffcc0, 0x28c374 + 0x20, 0x40)	// new lines: get AIZ1 original palette from the Sonic 3 cartridge and put last two lines in fade-in palette RAM
//	u32[0xfffffcf0] = 0x0ee40ea6					// load Knuckles' sky palette values as in the original ROM
//	u32[0xfffffcf4] = 0x0e620e40					// load Knuckles' sky palette values as in the original ROM

	D7 = pop()
	A0 = pop()
	A2 = pop()
	A3 = pop()

	D0.u16 = 0x2630 - getScreenExtend()			// changed x position to 0x2630 to match ROM hack. Normal is 0x1eb8.
	camera.position.x.u16 = D0.u16				// Any further to the left will make Knuckles float in midair as he walks off an edge. Normal is 0x1eb8.
	camera.foreground.x.u16 = D0.u16			
	D0.u16 = 0x00fc								// changed y position to 0x00fc to match ROM hack. Normal is 0x01e0.
	camera.position.y.u16 = D0.u16
	camera.foreground.y.u16 = D0.u16			

	Level.GetCameraPosition()
	D0.u16 = (D0.u16 + 0xe0) & level.height.tilemask
	u16[0xffffeec8] = D0.u16
	u16[0xffffeeca] = 0x0f
	u16[0xffffeec0] += 4

	fn05acfc()
}





// Correct some garbage graphics that appears beside credits in best ending for Sonic/Tails
//# address-hook(0x05b1a2) end(0x05b1e6)
function void fn05b1a2()
{
	u16[0xfffffa86] += 0x02
	u8[0xfffffacc] = 0
#if STANDALONE
	camera.position.x.u16 = -getScreenExtend()		// Center the credits
#endif
	camera.position.y = 0
	scrolloffset.y.both = 0
	u16[0xfffffaae] = 0

	if (global.characters == CHARS_KNUCKLES_ALONE)
	{
		// Create the object that fades out music and starts the credits medley afterwards
		if (allocDynamicObjectStd())
		{
			objA1.update_address = 0x085b30
			u8[A1 + 0x2c] = 0xdc
		}
	}

	fn05b514()

	u16[0xfffffc02] = 0x0eee
	u16[0xfffffc22] = 0x00ee

	addPatternLoadingCue(0x05b1ec)

	if (!isMainCharacter(CHARACTER_KNUCKLES))
	{
		Nemesis.loadDataToVRAM(0x2d1800, 0x0f80)	// overwrite graphics that are no longer needed with blank tiles to prevent garbage showing during credits
		Nemesis.loadDataToVRAM(0x2d18e0, 0x08a0)	// overwrite a shorter section of such graphics
	}
}




// Add DAGE's name to the end logos
//# address-hook(0x05b29e) end(0x05b2d2)
function void fn05b29e()
{
	u16[0xfffffa86] += 2
	timer.alldata = 0
	u8[0xffffeec4] = 0xff
	u8[0xfffffacc] = 0xff

	if (global.characters == CHARS_KNUCKLES_ALONE)
	{
		if (outro.ending_type >= 0)
		{
			if (allocDynamicObjectStd())
			{
				objA1.update_address = 0x05ef68
			}
		}
		else
		{
			u8[0xfffffab9] = 0
		}
	}
	Nemesis.loadDataToVRAM(0x2d1920, 0x7de0)	// overwrite old art with the DAGE name
}















// Alter the locations in which multi-sample collision is used.
// This is only being used against types of terrain that have "sucked players inside"
// or that have proven to be otherwise unreliable based on player character subpixels.
function bool Standalone.useMultiSampleCollision()
{
	if (!Game.getSetting(SETTING_FIX_GLITCHES) || original_mode)
		return false

	u32 tablePointer = 0x817000

	// Setup the lookup table if not done already
	if (u16[tablePointer] != (global.zone_act | 0x8080) || unlock_act == 2)		// Add 0x8080 mainly to avoid having 0x0000 for AIZ 1
	{
		u32 backupA1 = A1
		u16[tablePointer] = (global.zone_act | 0x8080)
		A1 = tablePointer + 4

//		if (global.zone_act == 0x0001)
//		{
//			// AIZ 2
//			Standalone.MultiSampleCollision.addRect(0x3900, 0x01e0, 0x4000, 0x02a0)
//		}
//		else if (global.zone_act == 0x0100)
		if (global.zone_act == 0x0100)
		{
			// HCZ 1
			Standalone.MultiSampleCollision.addRect(0x0EA0, 0x0920, 0x0F30, 0x09B0)
			Standalone.MultiSampleCollision.addRect(0x1220, 0x04A0, 0x12B0, 0x0530)
			Standalone.MultiSampleCollision.addRect(0x14A0, 0x0620, 0x1530, 0x06B0)	
			Standalone.MultiSampleCollision.addRect(0x15A0, 0x0220, 0x1630, 0x02B0)
			Standalone.MultiSampleCollision.addRect(0x1CA0, 0x0720, 0x1D30, 0x07B0)
			Standalone.MultiSampleCollision.addRect(0x22A0, 0x0A20, 0x2330, 0x0AB0)
			Standalone.MultiSampleCollision.addRect(0x2D20, 0x03A0, 0x2DB0, 0x0430)
			Standalone.MultiSampleCollision.addRect(0x2DA0, 0x0620, 0x2E30, 0x06B0)
			Standalone.MultiSampleCollision.addRect(0x3020, 0x0220, 0x30B0, 0x02B0)
			Standalone.MultiSampleCollision.addRect(0x3240, 0x0320, 0x32E0, 0x03B0)
		}
		else if (global.zone_act == 0x0101)
		{
			// HCZ 2
			Standalone.MultiSampleCollision.addRect(0x12C0, 0x0920, 0x1360, 0x09B0)
			Standalone.MultiSampleCollision.addRect(0x2040, 0x01A0, 0x20E0, 0x0230)
			Standalone.MultiSampleCollision.addRect(0x38C0, 0x01A0, 0x3960, 0x0230)
			Standalone.MultiSampleCollision.addRect(0x38C0, 0x04A0, 0x3960, 0x0530)
		}
		else if (global.zone_act == 0x0200)
		{
			if (unlock_act == 2)
				CPZ.MultiSampleCollision()
			
			// MGZ 1
//			Standalone.MultiSampleCollision.addRect(0x0880, 0x04c0, 0x0960, 0x0540)
//			Standalone.MultiSampleCollision.addRect(0x11c0, 0x01c0, 0x1240, 0x0240)
		}
		else if (global.zone_act == 0x0300)
		{
			// CNZ 1
			Standalone.MultiSampleCollision.addRect(0x0300, 0x0B50, 0x03E0, 0x0BF0)
			Standalone.MultiSampleCollision.addRect(0x09C0, 0x0650, 0x0A80, 0x0700)
		}
		else if (global.zone_act == 0x0301)
		{
			// CNZ 2
			Standalone.MultiSampleCollision.addRect(0x0500, 0x09E0, 0x05B0, 0x0A60)
			Standalone.MultiSampleCollision.addRect(0x0A50, 0x07D0, 0x0B00, 0x0880)
			Standalone.MultiSampleCollision.addRect(0x18A0, 0x03E0, 0x1920, 0x0460)
			Standalone.MultiSampleCollision.addRect(0x2b50, 0x0750, 0x2c00, 0x0800)
		}
		else if (global.zone_act == 0x0501)
		{
			// ICZ 2

			// Do not use this for the quarter-pipes (note: there are few more than those out-commented below),
			// it leads to some unwanted behavior:
			//  - The character is is most cases launched up into the air in a 90� angle instead of something like 85�
			//  - When coming from right quickly (e.g. when spindashing), the character often directly follows the terrain instead of going over the 90� edge

			// Standalone.MultiSampleCollision.addRect(0x0b70, 0x0460, 0x0bf0, 0x04e0)
			// Standalone.MultiSampleCollision.addRect(0x18f0, 0x05e0, 0x1970, 0x0660)
			// Standalone.MultiSampleCollision.addRect(0x1ef0, 0x05e0, 0x1f70, 0x0660)
			// Standalone.MultiSampleCollision.addRect(0x25f0, 0x01e0, 0x2670, 0x0260)
			// Standalone.MultiSampleCollision.addRect(0x2b70, 0x0460, 0x2bf0, 0x04e0)
			// Standalone.MultiSampleCollision.addRect(0x2b70, 0x0a60, 0x2bf0, 0x0ae0)
			// Standalone.MultiSampleCollision.addRect(0x2df0, 0x04e0, 0x2e70, 0x0560)
			// Standalone.MultiSampleCollision.addRect(0x3570, 0x0460, 0x35f0, 0x04e0)
			// Standalone.MultiSampleCollision.addRect(0x3ef0, 0x06e0, 0x3f70, 0x0760)

			// Standalone.MultiSampleCollision.addRect(0x3a80, 0x05b0, 0x3b80, 0x06a0)
		}
		else if (global.zone_act == 0x0600)
		{
			// LBZ 1
			Standalone.MultiSampleCollision.addRect(0x09E0, 0x01A0, 0x0AC0, 0x0300)
			Standalone.MultiSampleCollision.addRect(0x1180, 0x0680, 0x1480, 0x0900)	// this covers a large room built of quarterpipes
		}
		else if (global.zone_act == 0x0601)
		{
			// LBZ 2
			Standalone.MultiSampleCollision.addRect(0x1AD0, 0x0260, 0x1B80, 0x0300)
			Standalone.MultiSampleCollision.addRect(0x2560, 0x0390, 0x2600, 0x0400)
			Standalone.MultiSampleCollision.addRect(0x3340, 0x0960, 0x3400, 0x09E0)
			Standalone.MultiSampleCollision.addRect(0x3860, 0x0610, 0x3900, 0x0680)
		}
		else if (global.zone_act == 0x0901)
		{
			// LRZ 2
			Standalone.MultiSampleCollision.addRect(0x2580, 0x01c0, 0x26d0, 0x0260)		// Added so that ramps make you go straight up here, and especially not under the block that crushes you
		}

		u16[tablePointer + 2] = (A1 - (tablePointer + 4)) / 8

		A1 = backupA1
	}

	// Ignore if character is going slow anyway
	s16 vx = char.velocity.x >> 8
	s16 vy = char.velocity.y >> 8
	if (abs(vx) < 4 && abs(vy) < 4)
		return false

	// Check for defined locations
	u16 px = char.position.x.u16 + vx / 2
	u16 py = char.position.y.u16 + vy / 2
	u16 count = u16[tablePointer + 2]
	u32 ptr = tablePointer + 4
	for (u16 i = 0; i < count; ++i)
	{
		if (px >= u16[ptr] && px < u16[ptr+4] && py >= u16[ptr+2] && py < u16[ptr+6])
		{
			return true
		}
		ptr += 8
	}
	return false


	// Old code that checks for chunk type
	//  -> Unfortunately, this is not that reliable, so we don't use it any more
	//u16 offset = ((char.position.y.u16 + (char.velocity.y >> 8)) >> 5) & level.chunksize.bitmask
	//u32 address = 0xffff0000 + u16[0xffff8008 + offset] + ((char.position.x.u16 + (char.velocity.x >> 8)) >> 7)
	//u8 chunkType = u8[address]
	//if (global.zone_act == 0x0100)
	//{
	//	// HCZ 1
	//	return (chunkType == 0x2d || chunkType == 0x2e)
	//}
	//else if (global.zone_act == 0x0501)
	//{
	//	// ICZ 1
	//	return (chunkType == 0x20)
	//}
}

function void CPZ.MultiSampleCollision()
{
	if (layout.part == 0)
	{
		Standalone.MultiSampleCollision.addRect(0x0780, 0x04c0, 0x0780 + 0x0080, 0x04c0 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x09c0, 0x05a0, 0x09c0 + 0x0100, 0x05a0 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x0d80, 0x0440, 0x0d80 + 0x0080, 0x0440 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x0f20, 0x0220, 0x0f20 + 0x0100, 0x0220 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x0f20, 0x06a0, 0x0f20 + 0x0100, 0x06a0 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x1500, 0x0640, 0x1500 + 0x0080, 0x0640 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x1900, 0x0140, 0x1900 + 0x0080, 0x0140 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x1c00, 0x0140, 0x1c00 + 0x0080, 0x0140 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x2920, 0x0320, 0x2920 + 0x0100, 0x0320 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x2c20, 0x0620, 0x2c20 + 0x0100, 0x0620 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x2d80, 0x0240, 0x2d80 + 0x0080, 0x0240 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x2ea0, 0x02a0, 0x2ea0 + 0x0100, 0x02a0 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x3000, 0x0420, 0x3000 + 0x0100, 0x0420 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x3300, 0x0680, 0x3300 + 0x0080, 0x0680 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x3340, 0x0590, 0x3340 + 0x0080, 0x0590 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x30a0, 0x02a0, 0x30a0 + 0x0100, 0x02a0 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x3780, 0x05c0, 0x3780 + 0x0080, 0x05c0 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x3980, 0x05c0, 0x3980 + 0x0080, 0x05c0 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x3e00, 0x0280, 0x3e00 + 0x0100, 0x0280 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x4100, 0x0500, 0x4100 + 0x0080, 0x0500 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x43c0, 0x0680, 0x43c0 + 0x0080, 0x0680 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x45c0, 0x0680, 0x45c0 + 0x0080, 0x0680 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x4940, 0x07a0, 0x4940 + 0x0280, 0x07a0 + 0x0080)
	}
	else if (layout.part == 1)
	{
		Standalone.MultiSampleCollision.addRect(0x0380, 0x02c0, 0x0380 + 0x0080, 0x02c0 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x03e0, 0x0220, 0x03e0 + 0x0060, 0x0220 + 0x0060)
		Standalone.MultiSampleCollision.addRect(0x0bc0, 0x0190, 0x0bc0 + 0x00a0, 0x0190 + 0x0100)
		Standalone.MultiSampleCollision.addRect(0x1200, 0x0540, 0x1200 + 0x0080, 0x0540 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x1380, 0x0380, 0x1380 + 0x0080, 0x0380 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x1680, 0x0180, 0x1680 + 0x0080, 0x0180 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x1a80, 0x0180, 0x1a80 + 0x01a0, 0x0180 + 0x0220)
		Standalone.MultiSampleCollision.addRect(0x1c00, 0x0500, 0x1c00 + 0x0080, 0x0500 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x1d00, 0x04c0, 0x1d00 + 0x0080, 0x04c0 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x1e80, 0x0480, 0x1e80 + 0x0080, 0x0480 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x2000, 0x0100, 0x2000 + 0x0100, 0x0100 + 0x0100)
		Standalone.MultiSampleCollision.addRect(0x2600, 0x0200, 0x2600 + 0x0080, 0x0200 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x2600, 0x0510, 0x2600 + 0x0100, 0x0510 + 0x0100)
	}
	else
	{
		Standalone.MultiSampleCollision.addRect(0x02c0, 0x01c0, 0x02c0 + 0x0080, 0x01c0 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x0f00, 0x02c0, 0x0f00 + 0x0080, 0x02c0 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x1680, 0x0180, 0x1680 + 0x0080, 0x0180 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x2780, 0x0500, 0x2780 + 0x0080, 0x0500 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x2800, 0x0400, 0x2800 + 0x0080, 0x0400 + 0x0040)
		Standalone.MultiSampleCollision.addRect(0x2900, 0x0200, 0x2900 + 0x0080, 0x0200 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x3170, 0x0330, 0x3170 + 0x0080, 0x0330 + 0x0120)
		Standalone.MultiSampleCollision.addRect(0x3a00, 0x0280, 0x3a00 + 0x0080, 0x0280 + 0x0080)
		Standalone.MultiSampleCollision.addRect(0x3a80, 0x0400, 0x3a80 + 0x0080, 0x0400 + 0x0040)
	}
}







//-------------------------------------------------------//
// Red Star Ring (based on debug mode ring)              //
//-------------------------------------------------------//

//# address-hook(0x047776)
function void RedStarRing()
{
	// Do not show Red Star Rings in Debug Mode or with modded characters using the template
	if ((debug_mode.enabled && !time_attack) || System.getGlobalVariableValueByName("DAGE_characterName") || Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") || u8[0xffffe654])
	{
		UnloadObject()
		return
	}

	// Do not show Red Star Rings if a sidekick Tails is present
	if (global.characters == 0 || (global.characters == 3 && useKnucklesAndTails))
	{
		UnloadObject()
		return
	}

	// We set the most significant bit for Knux's rings, the next bit for Tails's, and the last bit for Sonic's.
	// The lower 5 bits represent the rings themselves, with the least significant bit representing the first ring.
	// Sonic: 0x21, 0x22, 0x24, 0x28, 0x30
	// Tails: 0x41, 0x42, 0x44, 0x48, 0x50
	// Knux:  0x81, 0x82, 0x84, 0x88, 0x90
	u8 ringNum = objA0.subtype2c & 0x1f

	// Check to see if the red star ring is meant for another character and mark byte 0x26 with an offset if so.
	if (global.characters == 1 && objA0.subtype2c > 0x30)							// max subtype for Sonic's red star rings
	{
		s8[A0 + 0x26] = 24	// assume a Tails red star ring, 24 bytes ahead
		if (objA0.subtype2c > 0x40 && objA0.subtype2c <= 0x50 && (u8[redstarring_address + 24] & ringNum))	// a Tails red star ring
		{
			UnloadObject()		// only display other character's red star rings if we haven't picked them up yet
			return
		}
		s8[A0 + 0x26] = 48	// set as a Knuckles red star ring, 48 bytes ahead
		if (objA0.subtype2c > 0x80 && objA0.subtype2c <= 0x90 && (u8[redstarring_address + 48] & ringNum))	// a Knuckles red star ring
		{
			UnloadObject()		// only display other character's red star rings if we haven't picked them up yet
			return
		}
	}
	else if (global.characters == 2 && (objA0.subtype2c <= 0x40 || objA0.subtype2c > 0x50))	// range of Tails's red star rings
	{
		s8[A0 + 0x26] = -24	// assume a Sonic red star ring, 24 bytes prior
		if (objA0.subtype2c > 0x20 && objA0.subtype2c <= 0x30 && (u8[redstarring_address - 24] & ringNum))	// a Sonic red star ring
		{
			UnloadObject()		// only display other character's red star rings if we haven't picked them up yet
			return
		}
		s8[A0 + 0x26] = 24	// set as a Knuckles red star ring, 24 bytes ahead
		if (objA0.subtype2c > 0x80 && objA0.subtype2c <= 0x90 && (u8[redstarring_address + 24] & ringNum))	// a Knuckles red star ring
		{
			UnloadObject()		// only display other character's red star rings if we haven't picked them up yet
			return
		}
	}
	else if (global.characters == 3 && objA0.subtype2c < 0x80)						// min subtype for Knux's red star rings
	{
		s8[A0 + 0x26] = -48	// assume a Sonic red star ring, 48 bytes prior
		if (objA0.subtype2c > 0x20 && objA0.subtype2c <= 0x30 && (u8[redstarring_address - 48] & ringNum))	// a Sonic red star ring
		{
			UnloadObject()		// only display other character's red star rings if we haven't picked them up yet
			return
		}
		s8[A0 + 0x26] = -24	// set as a Tails red star ring, 24 bytes prior
		if (objA0.subtype2c > 0x40 && objA0.subtype2c <= 0x50 && (u8[redstarring_address - 24] & ringNum))	// a Tails red star ring
		{
			UnloadObject()		// only display other character's red star rings if we haven't picked them up yet
			return
		}
	}

	call 0x047778 + objA0.base_state	// Each function in order is 0x02 apart in address hooks.
										// 0x047776 is in the middle of the code for collapsing staircases in DEZ. Addresses in here are free for hook use.

//	if (objA0.base_state == 0)
//		RedStarRing_Init()
//	else if (objA0.base_state == 2)
//		RedStarRing_Animate()
//	else if (objA0.base_state == 4)
//		RedStarRing_Collect()
//	else if (objA0.base_state == 6)
//		RedStarRing_CollectAnimate()
//	else
//		UnloadObject()
}


//# address-hook(0x047778)
function void RedStarRing_Init()
{
	objA0.base_state += 2
	objA0.mapping_offset = 0x01a99a
	objA0.sprite_attributes = 0xa6bc
	objA0.render_flags = render_flag.WORLD
	objA0.sprite_priority = 0x0100

	u8[A0 + 0x28] = 0x4e	// 0x47	// collision response bitfield
	if (objA0.value26)
		u8[A0 + 0x28] = 0	// empty collision response bitfield

	objA0.box_size.x = 0x0c
	objA0.box_size.y = 0x0c		// added to hopefully cut down on pop in/out
//	if (objA0.subtype2c == 1)
//	{
//		objA0.box_size.x = 0x20
//		objA0.box_size.y = 0x40		// added to hopefully cut down on pop in/out
//		objA0.hitbox_extends.x = 0x10
//		objA0.hitbox_extends.y = 0x10
//		u8[A0 + 0x28] = 0x56	// Collision response bitfield.
								// The first two bits are type: 00 for enemy, 01 for increment objA0.base_state by 2 (next routine), 10 harms player, 11 is for star post.
								// The last six bits map to table entries in Touch_Sizes in the disassembly, which give widths and heights. (Here, width = height = 0x20.)
//	}

	RedStarRing_Animate()
}


//# address-hook(0x04777a)
function void RedStarRing_Animate()
{
	// Smoother ring animations taken from maingame\static_rings.lemon. This doesn't render without more hooked up to it.
//	u8 animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8
//	u64 key = stringformat("ring_0%d", animFrame)
//	u16 x = D0.u16 - 0x80
//	u16 y = D1.u16 - 0x80
//	Renderer.drawCustomSprite(key, objA0.position.x.u16, objA0.position.y.u16, 0x00, 0, 0xa000)

//	objA0.animation.sprite = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 4 // spin twice as fast as normal rings with only 4 animation frames
//	u64 key = stringformat("ring_0%d", objA0.animation.sprite * 2)
//	Renderer.drawCustomSprite(key, objA0.position.x.u16 - camera.foreground.x.u16, objA0.position.y.u16 - camera.foreground.y.u16, 0x00, 0, 0xa000)

	objA0.animation.sprite = static_rings.animframe
	fn01b662()
}


//# address-hook(0x04777c)
function void RedStarRing_Collect()
{
	objA0.base_state += 2
	u8[A0 + 0x28] = 0
	objA0.sprite_priority = 0x80
	u8 ringNum = objA0.subtype2c & 0x1f

	if (ringNum == 0x01 || ringNum == 0x02 || ringNum == 0x04 || ringNum == 0x08 || ringNum == 0x10)
	{
		if (u8[redstarring_address] & ringNum)			// If collected already,
			objA0.value39 = 1							// set a flag that says to use blue/grey sparkles.
		u8[redstarring_address] |= ringNum				// Mark the red star ring as collected
		Audio.playAudio("redstarring", AudioContext.CONTEXT_SOUND)		// play Red Star Ring collection sound
		if (!objA0.value39)
		{
			u16 total_stars_old = total_stars
			countTotalStars()	// forces the counter to update
			Unlock.checkForNewUnlock(total_stars_old, total_stars)
			Input.setControllerRumble(-1, 0.25f, 0x6000, 200)	// identical to rumble from fire shield dash sound
		}
		else
		{
			Input.setControllerRumble(-1, 0.0f, 0.2f, 200)	// identical to rumble from either ring sound
		}

		u32 rsrAddress = (unlock_act) ? 0x840580 : 0x840280
		u64 key = (unlock_act) ? "RtWI_RSR" : "DAGE_RSR"
		u8 rsrArraySize = 72
		System.savePersistentData(rsrAddress, key, rsrArraySize)
	}
	else	// the subtype wasn't set in the level object data properly, so play a warning sound
	{
		playSound(0x46)
	}

	// Alternating twinkle sound mimics and switches the ring sound panning state.
	// This functionality is not hooked up to the sound test.
//	if (objA0.subtype2c == 0)
//	{
//		alternatingRingSoundState = !alternatingRingSoundState
//		if (!alternatingRingSoundState)
//			playSound(0xde)
//		else
//			playSound(0xdd)

//		freeze_time += 60	// freeze time for 1 second (60 frames)
//	}
//	else if (objA0.subtype2c == 1)
//	{
//		playSound(0xe0)		// formerly 0xb8
//		freeze_time += 420	// freeze time for 7 seconds (420 frames)
//	}

	RedStarRing_CollectAnimate()
}


//# address-hook(0x04777e)
function void RedStarRing_CollectAnimate()
{
	Object.animationUpdate(0x01a992)
	DrawObject()
}


//# address-hook(0x047780)
function void RedStarRing_Unload()
{
	UnloadObject()
}

function void loadRSR()
{
	u32 rsrAddress = 0x840280
	u8 rsrArraySize = 72
	if (!System.loadPersistentData(rsrAddress, "DAGE_RSR", rsrArraySize))	// load DAGE red star rings
	{
		zeroMemory(rsrAddress, rsrArraySize)		// should default to zero, but another mod may have tried to use this memory
	}
	rsrAddress += 0x300
	if (!System.loadPersistentData(rsrAddress, "RtWI_RSR", rsrArraySize))	// load RtWI red star rings
	{
		zeroMemory(rsrAddress, rsrArraySize)		// should default to zero, but another mod may have tried to use this memory
	}
}




function void Unlock.checkForNewUnlock(u16 total_stars_old, u16 total_stars)
{
	if (total_stars_old < unlock.theme.south && total_stars >= unlock.theme.south)
		unlock.show = true
	else if (total_stars_old < unlock.level.ehz && total_stars >= unlock.level.ehz)
		unlock.show = true
	else if (total_stars_old < unlock.level.cpz && total_stars >= unlock.level.cpz)
		unlock.show = true
}

function void Unlock.showUnlock()
{
	bool validGameMode = (((global.game_mode & 0x7f) == 0x0c) || ((global.game_mode & 0x7f) == 0x34))
	if (!validGameMode || level.restart || !timer.alldata)	// Rendering this currently slows menus, title cards, and game mode changes, so check we're fully in a level. Will need updating if special stages allow star collection.
	{
		unlock.show = false
		unlock.timer = 0
		return
	}

	if (!unlock.timer)	// this is the first frame of the unlock announcement
		playSound(0x68)	// sound from text saying you can now be super/hyper or go to Hidden Palace

	u64 unlockTypeString
	u64 unlockString
	// We compare to the *next* unlockable, as multiple stars can be earned at once via Challenges.
	if (total_stars < unlock.theme.westside)
	{
		unlockTypeString = "Theme Unlocked:"
		unlockString = "South Island"
	}
	else if (total_stars < unlock.level.cpz)
	{
		unlockTypeString = "Zone & Theme Unlocked:"
		unlockString = "Emerald Hill Zone & West Side Island"
	}
	else
	{
		unlockTypeString = "Zone Unlocked:"
		unlockString = "Chemical Plant Zone"
	}

	constant u16 py_target = 32
	u16 py = (unlock.timer < 30) ? (getScreenHeight() - (py_target * unlock.timer / 30)) : (unlock.timer > 270) ? (getScreenHeight() - (py_target * (300 - unlock.timer) / 30)) : (getScreenHeight() - py_target)
	py += 6
	u8 flags = ((global.game_mode & 0x7f) == 0x34) ? SPRITE_FLAG_PRIO : (SPRITE_FLAG_PRIO | SPRITE_FLAG_NO_GLOBAL_TINT)		// allow rectangle to handle fade to white on special stage entrance properly
	Renderer.drawText("sonic_r_credits_small:shadow(1,1,0,1)", getScreenWidth()/2, py, unlockTypeString, 0x80b0ffff, 2, 0, 0xffff, 0)
	Renderer.drawText("sonic_r_credits_small:shadow(1,1,0,1)", getScreenWidth()/2, py + 13, unlockString, 0xffffffff, 2, 0, 0xffff, 0)
	if (unlockString == "Emerald Hill Zone & West Side Island")
		Renderer.drawCustomSprite("blackscreen_optionsdim", getScreenWidth()/2, py + 24, 0x00, flags, 0xfffe, 0, 180)
	else
		Renderer.drawCustomSprite("blackscreen_besttimesdim_rect", getScreenWidth()/2, py + 24, 0x00, flags, 0xfffe, 0, 180)

	++unlock.timer
	if (unlock.timer == 300)
	{
		unlock.show = false
		unlock.timer = 0
	}
}

constant array<u16> GiantRings.maxPossible =
{
//		S+T	S	T	K	K+T
		2,	2,	2,	2,	2,	// AIZ1
		2,	2,	2,	2,	2,	// AIZ2
		5,	5,	5,	6,	6,	// HCZ1
		5,	5,	5,	3,	8,	// HCZ2
		5,	5,	5,	4,	4,	// MGZ1
		5,	5,	5,	5,	5,	// MGZ2
		4,	4,	4,	4,	4,	// CNZ1
		7,	7,	7,	8,	9,	// CNZ2
		4,	4,	4,	5,	5,	// FBZ1
		5,	5,	5,	5,	5,	// FBZ2
		2,	2,	2,	2,	2,	// ICZ1
		4,	3,	4,	4,	5,	// ICZ2		// Sonic alone cannot get a giant ring on the "Knux" path near the end (that Tails can also reach)
		4,	4,	3,	4,	4,	// LBZ1		// Tails alone cannot get a giant ring on a path the first tube transport takes Sonic/Knux to
		4,	4,	4,	2,	2,	// LBZ2
		6,	6,	6,	7,	7,	// MHZ1
		3,	3,	3,	6,	6,	// MHZ2		// two giant rings on the Sonic/Tails path are difficult with Knux alone but still possible
		6,	5,	6,	4,	4,	// SOZ1		// Sonic alone cannot get a giant ring to the right of a Knux-breakable wall beside a freefall Tails can fly up from below
		3,	3,	3,	3,	3,	// SOZ2
		3,	3,	3,	2,	2,	// LRZ1
		6,	6,	6,	3,	8	// LRZ2		// Knux doesn't get to see results in this act. Add results at a later date, or perhaps show counter when end of act is approached.
										// We *must* update giantRingsCollected.array before showing any counter if we don't make results!
}
constant array<u16> GiantRings.highestSubtype =
{
	2,	// AIZ1
	6,	// AIZ2
	6,	// HCZ1
	14,	// HCZ2
	8,	// MGZ1
	13,	// MGZ2
	6,	// CNZ1
	15,	// CNZ2
	6,	// FBZ1
	11,	// FBZ2
	2,	// ICZ1
	7,	// ICZ2
	4,	// LBZ1
	10,	// LBZ2
	7,	// MHZ1
	13,	// MHZ2
	6,	// SOZ1
	9,	// SOZ2
	4,	// LRZ1
	12	// LRZ2
}

function void GiantRings.displayNumberCollected(u16 px, u16 py, u16 renderQueue)
{
	u8 charID = global.characters + useKnucklesAndTails
	u8 zoneID = (global.zone == 0x16) ? 0x09 : global.zone
	u8 actID = (global.zone == 0x16) ? 0x01 : global.act.apparent

	u8 maxGiantRings = GiantRings.maxPossible[(10 * zoneID) + (5 * actID) + charID]

	// Additional checks for using Knuckles and either Tails or damage boosts to take multiple paths in some acts by restarting from Data Select.
	// When DAGE gets its own saves that occur every act, some of these will no longer be necessary if the level start location is saved.
	// None of these checks account for using debug mode to collect more rings than normally allowed!
	if (charID >= 3)
	{
		if (global.zone_act.apparent == 0x0001)
		{
			u16 AIZ2.SonicTailsPath = (giantRingsCollected.array & 0x0018)
			u16 AIZ2.KnuxPath = (giantRingsCollected.array & 0x0060)
			if (AIZ2.SonicTailsPath && AIZ2.KnuxPath)		// giant rings were obtained on both paths
				maxGiantRings = 4
		}
		else if (global.zone_act.apparent == 0x0100)
		{
			u16 HCZ1.KnuxPath = (giantRingsCollected.array & 0x0002)
			if (!HCZ1.KnuxPath && level.start_location == 1)	// started from the Sonic/Tails path, never collected the Knux path giant ring
				maxGiantRings = 5
		}
		else if (global.zone_act.apparent == 0x0200)
		{
			u16 MGZ1.SonicTailsPath = (giantRingsCollected.array & 0x002e)
			if (MGZ1.SonicTailsPath || level.start_location == 1)
				maxGiantRings = 5
			u16 MGZ1.KnuxPath = (giantRingsCollected.array & 0x01c0)
			if (MGZ1.SonicTailsPath && MGZ1.KnuxPath)		// giant rings were obtained on both paths
				maxGiantRings = 8
		}
		else if (global.zone_act.apparent == 0x0300)
		{
			u16 CNZ1.SonicTailsPath = (giantRingsCollected.array & 0x0006)
			u16 CNZ1.KnuxPath = (giantRingsCollected.array & 0x0060)
			if (CNZ1.SonicTailsPath && CNZ1.KnuxPath)		// giant rings were obtained on both paths
				maxGiantRings = 6
		}

		// ICZ2, LBZ2, FBZ1, SOZ1, and LRZ1 do not need checks at this time, but this may change someday.

		else if (zoneID == 0x09 && actID == 1)	// should be fine to check global.zone_act.apparent, but we use IDs in case a mod allows access to the LRZ2 boss
		{
			u16 LRZ2.SonicTailsPath = (giantRingsCollected.array & 0x0dc0)		// ring IDs 5, 9, and 12 are on the Knux path, but 6-8, 10, and 11 require sidekick Tails or damage boosting
			if (LRZ2.SonicTailsPath)
				maxGiantRings = 8		// damage boosting allows access to every giant ring
		}
	}

	u8 highestSubtype.act1 = GiantRings.highestSubtype[2 * zoneID]
	u8 highestSubtype.act2 = GiantRings.highestSubtype[2 * zoneID + 1]
	u8 giantRingsCollected.number

	u16 bit
	if (actID == 0)
	{
		// Count Act 1 giant rings
		for (u8 i = 1; i <= highestSubtype.act1; ++i)	// D.A. Garden never uses subtype 0 for a giant ring, so this must start from i = 1 and use <= instead of <.
		{
			bit = (1 << i)
			if (giantRingsCollected.array & bit)
				giantRingsCollected.number += 1
		}
	}
	else
	{
		// Count Act 2 giant rings
		for (u8 i = highestSubtype.act1 + 1; i <= highestSubtype.act2; ++i)	// D.A. Garden never uses subtype 0 for a giant ring, so this must start from i = 1 and use <= instead of <.
		{
			bit = (1 << i)
			if (giantRingsCollected.array & bit)
				giantRingsCollected.number += 1
		}
	}

	s16 y_offset = (getScreenWidth() - 400)/16	// we base the y position on TOTAL text x value, which changes with screen width at a rate of deltaY/deltaX = -1/16.
	Renderer.drawCustomSprite("hud_giantring", px - 26, py - y_offset - 7, 0x00, SPRITE_FLAG_PRIO, renderQueue)
	u64 giantRingsObtained = stringformat("             * %d/%d", giantRingsCollected.number, maxGiantRings)
	u32 tint = (giantRingsCollected.number == maxGiantRings) ? 0xffff60ff : 0xffffffff
	Renderer.drawText("sonic_r_credits_small:shadow(1,1,0,1)", px - 6, py - y_offset, giantRingsObtained, tint, 2, 0, renderQueue, 0, 1)
	Renderer.drawCustomSprite("mgz_pillar_knuxshading", px, py - y_offset + 29, 0x00, SPRITE_FLAG_PRIO, renderQueue - 1, 0, 180)
}





// Do not save score in save slots in Original Mode. (Loading is handled in fn00d458() in cmf_main.lemon.)
// Function taken from general\saveslots.lemon
//# address-hook(0x00c434) end(0x00c4d0)
function void SaveGameOnLevelFinished()
{
	// Save game slot
	if (global.lock_on_state == 0 && global.active_saveslot != 0)
	{
		A1 = global.active_saveslot

		// Get the number of the next zone (using the usual internal zone numbering, see definition of global.zone.apparent)
		u8 offset = global.zone * 2 + global.act
		u8 nextZone = u8[0x00c404 + offset]

		bool gameCompleted = false
		if (u8[A1] & 0x03)
		{
			// This gets entered only for already completed games
			if (nextZone < u8[A1 + 0x03])
			{
				gameCompleted = true
			}
			else
			{
				// This is a weird case, supposedly needed for unlocking DDZ after collecting all Super Emeralds in an formerly complete game?
				u8[A1] &= 0xfc
			}
		}

		if (!gameCompleted)
		{
			u8[A1 + 0x03] = nextZone
			if (isMainCharacter(CHARACTER_KNUCKLES))
			{
				gameCompleted = (nextZone >= 0x0c)
			}
			else if (isMainCharacter(CHARACTER_TAILS))
			{
				gameCompleted = (nextZone >= 0x0d)
			}
			else
			{
				gameCompleted = (nextZone >= 0x0e) || (nextZone == 0x0d && global.chaos_emeralds < 7)
			}

			if (gameCompleted)
			{
				u8[A1] = (global.chaos_emeralds < 7) ? 1 : (global.super_emeralds < 7) ? 2 : 3
			}

			u16[A1 + 0x04] = 0
		}

		lives_counter = min(lives_counter, 99)
		u8[A1 + 0x08] = lives_counter

		if (!original_mode)		// we don't want to alter saved score in Original Mode, as it always starts from 0.
		{
			// Store additional data
			u32 slotIndex = (A1 - 0xffffe6ac) / 0x0a
			u32 address = 0x801100 + slotIndex * 0x20
			u32[address] = player.score
		}

		SaveGameSlot()
	}

	level.giantrings_clear = 0
}
