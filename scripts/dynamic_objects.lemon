// Formerly 0xffffe380 .. 0xffffe3ff, now 0x8ae380 .. 0x8ae3ff
// Table of dynamic objects in range
//  - First word ("size") is twice the number of objects in the table
//  - After that, each entry is word per object, telling us the RAM address of a dynamic object (lower u16 part only)
define global.dynamic_objects.size_new	= u16[0x8ae380]
constant u32 global.dynamic_objects.array_newstartloc = 0x8ae380

//# address-hook(0x01040c) end(0x01041c)
function void AddAsDynamicObject()
{
	if (global.dynamic_objects.size_new < 0x7e)
	{
		global.dynamic_objects.size_new += 2
		u16[global.dynamic_objects.array_newstartloc + global.dynamic_objects.size_new] = A0.u16
	}
}

//# address-hook(0x006c2c) end(0x006c32)
function void ResetDynamicObjectList()
{
	global.dynamic_objects.size_new = 0
}

//# address-hook(0x00ff06) end(0x00ff5e)
function void Character.CheckCollisionsWithDynamicObjects_partial()
{
#if STANDALONE
	// Bounding box of player
	if (DEBUG_DYNAMIC_COLLISIONS)
		debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ff00)
#endif

	u16 numObjects = global.dynamic_objects.size_new		// Actually it's twice the number of dynamic objects
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Offset into a list of hitbox sizes (the list looks a bit random)
		u16 offset = objA1.collision_attributes
		if (offset != 0)
		{
			// Targets:
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4
			//  - 0x14 x 0x14  -> (offset & collision_attributes.size) = collision.size.20x20
			//  - 0x0c x 0x14  -> (offset & collision_attributes.size) = collision.size.12x20
			//  - 0x14 x 0x0c  -> (offset & collision_attributes.size) = collision.size.20x12
			//  - 0x04 x 0x10  -> (offset & collision_attributes.size) = collision.size.4x16
			//  - 0x0c x 0x12  -> (offset & collision_attributes.size) = collision.size.12x18
			//  - 0x10 x 0x10  -> (offset & collision_attributes.size) = collision.size.16x16
			//  - 0x06 x 0x06  -> (offset & collision_attributes.size) = collision.size.6x6
			//  - 0x18 x 0x0c  -> (offset & collision_attributes.size) = collision.size.24x12
			//  - 0x0c x 0x10  -> (offset & collision_attributes.size) = collision.size.12x16
			//  - 0x10 x 0x08  -> (offset & collision_attributes.size) = collision.size.16x8
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8
			//  - 0x14 x 0x10  -> (offset & collision_attributes.size) = collision.size.20x16
			//  - 0x14 x 0x08  -> (offset & collision_attributes.size) = collision.size.20x8
			//  - 0x0e x 0x0e  -> (offset & collision_attributes.size) = collision.size.14x14
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24
			//  - 0x28 x 0x10  -> (offset & collision_attributes.size) = collision.size.40x16
			//  - 0x10 x 0x18  -> (offset & collision_attributes.size) = collision.size.16x24
			//  - 0x08 x 0x10  -> (offset & collision_attributes.size) = collision.size.8x16
			//  - 0x20 x 0x70  -> (offset & collision_attributes.size) = collision.size.32x112
			//  - 0x40 x 0x20  -> (offset & collision_attributes.size) = collision.size.64x32
			//  - 0x80 x 0x20  -> (offset & collision_attributes.size) = collision.size.128x32
			//  - 0x20 x 0x20  -> (offset & collision_attributes.size) = collision.size.32x32
			//  - 0x08 x 0x08  -> (offset & collision_attributes.size) = collision.size.8x8_2
			//  - 0x04 x 0x04  -> (offset & collision_attributes.size) = collision.size.4x4_2
			//  - 0x20 x 0x08  -> (offset & collision_attributes.size) = collision.size.32x8
			//  - 0x0c x 0x0c  -> (offset & collision_attributes.size) = collision.size.12x12
			//  - 0x08 x 0x04  -> (offset & collision_attributes.size) = collision.size.8x4
			//  - 0x18 x 0x04  -> (offset & collision_attributes.size) = collision.size.24x4
			//  - 0x28 x 0x04  -> (offset & collision_attributes.size) = collision.size.40x4
			//  - 0x04 x 0x08  -> (offset & collision_attributes.size) = collision.size.4x8
			//  - 0x04 x 0x18  -> (offset & collision_attributes.size) = collision.size.4x24
			//  - 0x04 x 0x28  -> (offset & collision_attributes.size) = collision.size.4x40
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_2
			//  - 0x18 x 0x18  -> (offset & collision_attributes.size) = collision.size.24x24_3
			//  - 0x0c x 0x18  -> (offset & collision_attributes.size) = collision.size.12x24
			//  - 0x48 x 0x08  -> (offset & collision_attributes.size) = collision.size.72x8
			//  - 0x18 x 0x28  -> (offset & collision_attributes.size) = collision.size.24x40
			//  - 0x10 x 0x04  -> (offset & collision_attributes.size) = collision.size.16x4
			//  - 0x20 x 0x02  -> (offset & collision_attributes.size) = collision.size.32x2
			//  - 0x10 x 0x1c  -> (offset & collision_attributes.size) = collision.size.16x28
			//  - 0x0c x 0x24  -> (offset & collision_attributes.size) = collision.size.12x36
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2
			//  - 0x04 x 0x40  -> (offset & collision_attributes.size) = collision.size.4x64
			//  - 0x18 x 0x40  -> (offset & collision_attributes.size) = collision.size.24x64
			//  - 0x20 x 0x10  -> (offset & collision_attributes.size) = collision.size.32x16
			//  - 0x1c x 0x14  -> (offset & collision_attributes.size) = collision.size.28x20
			//  - 0x10 x 0x02  -> (offset & collision_attributes.size) = collision.size.16x2_2
			//  - 0x10 x 0x01  -> (offset & collision_attributes.size) = collision.size.16x1
			//  - 0x02 x 0x08  -> (offset & collision_attributes.size) = collision.size.2x8
			//  - 0x10 x 0x40  -> (offset & collision_attributes.size) = collision.size.16x64
			//  - 0x0c x 0x04  -> (offset & collision_attributes.size) = collision.size.12x4
			//  - 0x08 x 0x0c  -> (offset & collision_attributes.size) = collision.size.8x12
			//  - 0x28 x 0x20  -> (offset & collision_attributes.size) = collision.size.40x32
			//  - 0x40 x 0x02  -> (offset & collision_attributes.size) = collision.size.64x2
			//  - 0x60 x 0x02  -> (offset & collision_attributes.size) = collision.size.96x2
			//  - 0x28 x 0x28  -> (offset & collision_attributes.size) = collision.size.40x40
			A2 = 0x00ff62 + (offset & collision_attributes.size) * 2
			s16 hitbox.x = u8[A2]
			s16 hitbox.y = u8[A2+1]

			u16 px = objA1.position.x.u16 - hitbox.x
			u16 py = objA1.position.y.u16 - hitbox.y
			u16 sx = hitbox.x * 2
			u16 sy = hitbox.y * 2

		#if STANDALONE
			if (DEBUG_DYNAMIC_COLLISIONS)
			{
				if ((offset & collision_attributes.flags) == collision.flag.ITEM)
					debugDrawRect(px, py, sx, sy, 0x8000ff00)
				else if ((offset & collision_attributes.flags) == collision.flag.SPECIAL)
					debugDrawRect(px, py, sx, sy, 0x80ff0000)
				else if ((offset & collision_attributes.flags) == collision.flag.THREAT)
					debugDrawRect(px, py, sx, sy, 0x800000ff)
				else
					debugDrawRect(px, py, sx, sy, 0x80ff00ff)
			}
		#endif

			if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
			{
				// Collision found
				Character.OnCollisionWithDynamicObject()
				return
			}
		}

		numObjects -= 2
	}
}

//# address-hook(0x01041e) end(0x0104e8)
function void UpdateShieldDeflecting()
{
	// Any shield active?
	if ((char.bonus_effect & char.bonus.ALL_SHIELDS) == 0)
		return

	// Bounding box of shield, or projectile deflection range
	D2.u16 = char.position.x.u16 - 0x18
	D3.u16 = char.position.y.u16 - 0x18
	D4.u16 = 0x30
	D5.u16 = 0x30

#if STANDALONE
	if (DEBUG_DYNAMIC_COLLISIONS >= 2)
		debugDrawRect(D2.u16, D3.u16, D4.u16, D5.u16, 0x8000ffff)
#endif

	u16 numObjects = global.dynamic_objects.size_new		// Actually it's twice the number of dynamic objects
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (numObjects != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		// Check for deflectable object
		u8 collisionFlags = (objA1.collision_attributes & collision_attributes.flags)
		if (collisionFlags == collision.flag.THREAT)
		{
			// Offset into a list of hitbox sizes?
			u16 offset = (objA1.collision_attributes & collision_attributes.size)
			if (offset != 0)
			{
				// Targets:
				//  - 0x04 x 0x04  -> offset = collision.size.4x4
				//  - 0x14 x 0x14  -> offset = collision.size.20x20
				//  - 0x0c x 0x14  -> offset = collision.size.12x20
				//  - 0x14 x 0x0c  -> offset = collision.size.20x12
				//  - 0x04 x 0x10  -> offset = collision.size.4x16
				//  - 0x0c x 0x12  -> offset = collision.size.12x18
				//  - 0x10 x 0x10  -> offset = collision.size.16x16
				//  - 0x06 x 0x06  -> offset = collision.size.6x6
				//  - 0x18 x 0x0c  -> offset = collision.size.24x12
				//  - 0x0c x 0x10  -> offset = collision.size.12x16
				//  - 0x10 x 0x08  -> offset = collision.size.16x8
				//  - 0x08 x 0x08  -> offset = collision.size.8x8
				//  - 0x14 x 0x10  -> offset = collision.size.20x16
				//  - 0x14 x 0x08  -> offset = collision.size.20x8
				//  - 0x0e x 0x0e  -> offset = collision.size.14x14
				//  - 0x18 x 0x18  -> offset = collision.size.24x24
				//  - 0x28 x 0x10  -> offset = collision.size.40x16
				//  - 0x10 x 0x18  -> offset = collision.size.16x24
				//  - 0x08 x 0x10  -> offset = collision.size.8x16
				//  - 0x20 x 0x70  -> offset = collision.size.32x112
				//  - 0x40 x 0x20  -> offset = collision.size.64x32
				//  - 0x80 x 0x20  -> offset = collision.size.128x32
				//  - 0x20 x 0x20  -> offset = collision.size.32x32
				//  - 0x08 x 0x08  -> offset = collision.size.8x8_2
				//  - 0x04 x 0x04  -> offset = collision.size.4x4_2
				//  - 0x20 x 0x08  -> offset = collision.size.32x8
				//  - 0x0c x 0x0c  -> offset = collision.size.12x12
				//  - 0x08 x 0x04  -> offset = collision.size.8x4
				//  - 0x18 x 0x04  -> offset = collision.size.24x4
				//  - 0x28 x 0x04  -> offset = collision.size.40x4
				//  - 0x04 x 0x08  -> offset = collision.size.4x8
				//  - 0x04 x 0x18  -> offset = collision.size.4x24
				//  - 0x04 x 0x28  -> offset = collision.size.4x40
				//  - 0x18 x 0x18  -> offset = collision.size.24x24_2
				//  - 0x18 x 0x18  -> offset = collision.size.24x24_3
				//  - 0x0c x 0x18  -> offset = collision.size.12x24
				//  - 0x48 x 0x08  -> offset = collision.size.72x8
				//  - 0x18 x 0x28  -> offset = collision.size.24x40
				//  - 0x10 x 0x04  -> offset = collision.size.16x4
				//  - 0x20 x 0x02  -> offset = collision.size.32x2
				//  - 0x10 x 0x1c  -> offset = collision.size.16x28
				//  - 0x0c x 0x24  -> offset = collision.size.12x36
				//  - 0x10 x 0x02  -> offset = collision.size.16x2
				//  - 0x04 x 0x40  -> offset = collision.size.4x64
				//  - 0x18 x 0x40  -> offset = collision.size.24x64
				//  - 0x20 x 0x10  -> offset = collision.size.32x16
				//  - 0x1c x 0x14  -> offset = collision.size.28x20
				//  - 0x10 x 0x02  -> offset = collision.size.16x2_2
				//  - 0x10 x 0x01  -> offset = collision.size.16x1
				//  - 0x02 x 0x08  -> offset = collision.size.2x8
				//  - 0x10 x 0x40  -> offset = collision.size.16x64
				//  - 0x0c x 0x04  -> offset = collision.size.12x4
				//  - 0x08 x 0x0c  -> offset = collision.size.8x12
				//  - 0x28 x 0x20  -> offset = collision.size.40x32
				//  - 0x40 x 0x02  -> offset = collision.size.64x2
				//  - 0x60 x 0x02  -> offset = collision.size.96x2
				//  - 0x28 x 0x28  -> offset = collision.size.40x40
				A2 = 0x00ff62 + offset * 2
				s16 hitbox.x = u8[A2]
				s16 hitbox.y = u8[A2+1]

				u16 px = objA1.position.x.u16 - hitbox.x
				u16 py = objA1.position.y.u16 - hitbox.y
				u16 sx = hitbox.x * 2
				u16 sy = hitbox.y * 2

			#if STANDALONE
				if (DEBUG_DYNAMIC_COLLISIONS >= 2)
					debugDrawRect(px, py, sx, sy, 0x8000ffff)
			#endif

				if (checkBoxOverlap(D2.u16, D3.u16, D4.u16, D5.u16, px, py, sx, sy))
				{
					if (u8[A1 + 0x2b] & char.bonus.DEFLECTABLE)
					{
						deflectProjectile()
						return
					}
				}
			}
		}

		numObjects -= 2
	}
}

function void Character.clearEnemiesOnScreen(u16 minY)
{
	push(A4)
	push(A3)
	push(A2)

	// Go through all the badniks to destroy
	D6.u16 = global.dynamic_objects.size_new
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	while (D6.u16 != 0)
	{
		// Get address of dynamic object
		A1 = 0xffff0000 + u16[A4]
		A4 += 2

		D0 = objA1.collision_attributes
		if (D0.u8 != 0)
		{
		#if STANDALONE
			// Assuming minY is only set for lightning shield touching water
			if (minY > 0)
			{
				if (objA1.position.y.u16 >= minY)
				{
					fn01050c()
				}
			}
			else
		#endif
			{
				fn01050c()
			}
		}
		D6.u16 -= 2
	}

	A2 = pop()
	A3 = pop()
	A4 = pop()
}

//# address-hook(0x02d638) end(0x02d68a)
function void fn02d638()
{
	global.dynamic_objects.size_new = 0
	if ((objA0.animation.sprite & 0x01) == 0)
	{
		D0.u8 = (control.pad1.pressed | control.pad2.pressed) & (CONTROL_START | CONTROL_ABC)
		if (D0.u8 == 0 && u16[A0 + 0x24] != 0)
		{
			--u16[A0 + 0x24]
		}
		else
		{
			if (global.time_over)
			{
				checkpoint.time = 0
				level.restart = 1

			#if STANDALONE
				Standalone.onDeath()
			#endif
			}
			else
			{
				global.game_mode = (continues_counter == 0) ? 0 : 0x14		// Initialization/Continue Screen
			}
		}
	}
	DrawObject()
}

//# address-hook(0x01a3fe) end(0x01a432)
function void fn01a3fe()
{
	D1 = 0

	// Go through all the badniks to destroy
	D6.u16 = global.dynamic_objects.size_new
	A4 = addressof(global.dynamic_objects.size_new) + 2		// Resulting address: 0x8ae382
	if (D6.u16 != 0)
	{
		u8[0xfffff66c] += 2
		if (u8[0xfffff66c] >= D6.u8)
		{
			u8[0xfffff66c] = 0
		}

		D0 = u8[0xfffff66c]
		D6.u16 -= D0.u16
		A4 += D0.s16
		while (D6.u16 != 0)
		{
			// Get address of dynamic object
			A1 = 0xffff0000 + u16[A4]
			A4 += 2

			D0.u8 = objA1.collision_attributes
			if (D0.u8 != 0)
			{
				fn01a434()
			}
			D6.u16 -= 2
		}
	}
}
