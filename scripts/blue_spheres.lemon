global u16 BS_remainingTime
global u16 bluespheres.blue_collected
global u16 bluespheres.blue_total
global u8 showTimeGain
global u8 showTimeGainTarget

// In Original Mode, the ring counter should always count up regardless of AIR setting.
// Function taken from level\special\bluespheres.lemon
//# address-hook(0x00881a) end(0x0088b4)
function void fn00881a()
{
	A1 = 0x0088b6
	D0.u16 = u16[0xffffe420]
	if (D0.u8 != u8[0xffffe42c])
	{
		u8[0xffffe42c] = D0.u8
		D0.u16 <<= 3
		A3 = u32[A1 + D0.s16]

		// Direct VRAM write
		VDP.setupVRAMWrite(0xc19e)
		VDP.copyToVRAM(A3 + 0x010e, 0x14)

		A3 += 0x0140
		u16 vramAddress = 0xc200
		for (u8 y = 0; y < 0x18; ++y)
		{
			VDP.setupVRAMWrite(vramAddress)
			VDP.copyToVRAM(A3, 0x50)
			vramAddress += 0x80
			A3 += 0x50
		}
	}

	if (bluespheres.bs_hud_dirty)
	{
		bluespheres.bs_hud_dirty = 0
		D0 = 0x40860003
		D1.u16 = bluespheres.blue_remaining
		fn008c5e()
	}

	if (bluespheres.rings_flags & 0x80)
	{
		bluespheres.rings_flags &= ~0x80
		D0 = 0x40be0003
		D1.u16 = (!original_mode && (bluespheres.minigame_mode || Game.getSetting(SETTING_BS_COUNTDOWN_RINGS))) ? bluespheres.rings_remaining : bluespheres.rings_collected
		fn008c5e()
	}
}


// Direct saving and loading for Green Sphere Game to use custom saved data.
// Functions taken from general\bluesphere\bluespheregame.lemon
// We also remove the white screen assumption in fn04c97e(), else the new Perfect results background flashes white on exit.
//# address-hook(0x04c97e) end(0x04cb18)
function void fn04c97e()
{
	Renderer.setScreenSize(screen_width, 224)
	original_mode = 0					// Remove original mode in Green Sphere menu
	ApplyROMManipulations()

	if (!menu_initialized)
	{
		debug_mode.enabled.u8 = Game.getSetting(SETTING_DEBUG_MODE)		// The debug flag may not have been set if we didn't go to the AIR menu first
		marathon_timer = 0
		draw_HUD = false					// Do not draw HUD in menus. initializeMainGame() will activate the HUD.
		water.fullscreen = 0				// Set in case we quit the game while totally underwater.
		eggrobos_knuckles = 1				// Default to Hard Mode in case we are in Challenges
		specialstages_knuckles = 1			// Default to Hard Mode in case we are in Challenges
		restartSpecialStage = 0
		challenges_normalmode = 0
	}

	if (global.characters >= 0x04 || levelselect.characters >= 0x04)		// We've entered the mode directly from Knuckles & Tails play.
	{
		global.characters = 0x01						// If this happens, force Sonic to match what the selection icons in the menu show.
		levelselect.characters = 0x01					// Here too, else this will replace global.characters when a stage is loaded.
	}
	else if (global.characters == 0x00 || levelselect.characters == 0x00)		// We've entered the mode directly from Sonic & Tails play.
	{
		global.characters = 0x01						// If this happens, force Sonic to match what the selection icons in the menu show.
		levelselect.characters = 0x01					// Here too, else this will replace global.characters when a stage is loaded.
	}

// #if STANDALONE
	// Assuming a white screen here
//	globalComponentAddedColorR = 0xff
//	globalComponentAddedColorG = 0xff
//	globalComponentAddedColorB = 0xff
// #endif

	playMusic(MUSIC_CTRL_FADEOUT)
	FadeOutScreenBlocking()

	fn04c8e4()
	fn04cca6()

// #if STANDALONE
	// Try to load progress from SRAM
//	SRAM.load(0xffffffa6, 0x50, 4)		// Writing to the address of bluespheregame.current_stage
//	System.loadPersistentData(0xffffffa6, "SRAM_BlueSphereProgress", 4)

	if (green_spheres.active)
		System.loadPersistentData(0xffffffa6, "DAGE_GreenSphereGame", 4)
	else
		System.loadPersistentData(0xffffffa6, "SRAM_BlueSphereProgress", 4)
		
	// Load data that usually gets loaded in the main menu, just in case players use AIR menus to get here
	loadBestActTimes()
	loadRSR()
	if (!System.loadPersistentData(0x840273, "DAGE_Theme", 1))	// load save theme if it exists,
		theme.hud = theme.saturn								// else use the theme matching the menu
	else if (theme.hud > 0x3f)	// classic RINGS HUD digits position
	{
		hud.layout = (theme.hud >> 6)
		theme.hud &= 0x3f		// set HUD to matching theme constant
	}

	// Switch to the correct seed for this stage
	BlueSphere.setGeneratedStage(bluespheregame.current_stage)
// #endif

	A2 = 0xfffffc80
	fn04cb1a()

	Nemesis.loadDataToVRAM(0x0dde34, 0xb7e0)
	Nemesis.loadDataToVRAM(0x189c7c, 0x32e0)

	Kosinski.decompress(0x187d1c, 0xffff0000)
	Kosinski.decompress(0x188f1e, A1)
	updateSpritePattern(0xffff0000, 0, A1.u16 >> 1)

	Kosinski.decompress(0x1897de, 0xffff4000)
	updateSpritePattern(0xffff4000, 0xa9c0, 0x06d0)

	Enigma.decompress(0x187cb0, 0xffff8000, 0x2000)

	//copyRectToVRAM(0xffff8000, 0xc380, 0x28, 0x10)	// Should be the same as below, needs to be tested
	A1 = 0xffff8000
	D0 = 0x43800003
	D1 = 0x27
	D2 = 0x0f
	CopyRectToVRAM()

	Enigma.decompress(0x189c4e, 0xffff8000, 0x4197)

	//copyRectToVRAM(0xffff8000, 0xe09c, 0x0c, 0x08)	// Should be the same as below, but something is wrong
	A1 = 0xffff8000
	D0 = 0x609c0003
	D1 = 0x0b
	D2 = 0x07
	CopyRectToVRAM()

	A1 = 0x04cc62
	if (u8[0xffffffa1] == 0)
	{
		A1 = 0x04cc36
		levelselect.characters = CHARS_SONIC_ALONE
		scrolloffset.y.both = 0xfff0fff8
	}

	D2.u16 = 0x0100
	D6.u16 = 0x05bf
	fn05b318()
	if (bluespheregame.fully_unlocked == 0)
	{
		scrolloffset.y.both = 0xfff0fff8
	}

	u32[0xffffb000] = 0x04ceaa
	u32[0xffffb04a] = 0x04da30
	u32[0xffffb094] = 0x04d986
	UpdateGameObjects()
	RenderSprites()

	playMusic(0x28)

	VDP.Config.setActiveDisplay(true)

	Menu.FadeInAfterInit()

	while (true)
	{
		global.frame_state = 0x1a
		Kosinski.ProcessDecompressionQueue()

		waitForNextFrame()

		fn04cc96()
		UpdateGameObjects()
		RenderSprites()
		Kosinski.ProcessModules()

		if (global.game_mode != 0x2c)
			break
	}
}

//# address-hook(0x04d488) end(0x04d59e)
function void fn04d488()
{
	fn04d268()

	D0.u16 ^= 0x55
	D2.u16 = D0.u16
	D0.u16 &= 0x3f
	D1 ^= 0xaaaaaaaa
	D1 = (D1 << 6) + (D1 >> 26)
	D1 = (D1 << 16) + (D1 >> 16)
	D3.u16 = (D1.u16 & 0xf800) >> 5
	D3.u16 |= D0.u16
	D3.u16 &= 0x07ff
	D1 = (D1 << 16) + (D1 >> 16)
	D1 -= 0x01234567
	D2.u16 &= 0x40
	if (D2.u16 != 0)
	{
		D1 += 0x07654321
	}
	D1 &= 0x07ffffff
	u32[0xffffe400] = D1

	A2 = 0xffffe400
	D6 = 1
	fn04d5a0()

	D4.u16 &= 0x07ff
	if (D3.u16 != D4.u16)
	{
		// Entered an invalid code
		playSound(0xb2)
	}
	else
	{
		// Code is valid
		u8[0xffffffab] = 0
		if (D2.u16 != 0)
		{
			D1 -= 0x07654321
			D1 &= 0x07ffffff
			u8[0xffffffab] = 0xff
		}

		bluespheregame.current_stage = D1
		BlueSphere.setGeneratedStage(bluespheregame.current_stage)


	if (green_spheres.active)
		System.savePersistentData(0xffffffa6, "DAGE_GreenSphereGame", 4)
	else
	{
	#if STANDALONE
		// Save progress to SRAM
		SRAM.save(0xffffffa6, 0x50, 4)		// Copying from the address of bluespheregame.current_stage
		System.savePersistentData(0xffffffa6, "SRAM_BlueSphereProgress", 4)
	#endif
	}

		A2 = 0xfffffc00
		fn04cb1a()

		playSound(0x63)
	}

	u8[0xffffffa1] &= 0x7f
	bluespheregame.menu_selection = 1
}

function void BlueSphereGame.advanceStages(u8 numStages)
{
	bluespheregame.current_stage += numStages

	A2 = 0xffffffa2
	for (u8 i = 0; i < numStages; ++i)
	{
		u32[A2] += 0x01030507
		u8[A2] &= 0x7f
		if (u8[A2+1] >= 0x7f)
			u8[A2+1] -= 0x7f
		if (u8[A2+2] >= 0x7e)
			u8[A2+2] -= 0x7e
		if (u8[A2+3] >= 0x7d)
			u8[A2+3] -= 0x7d
	}

	if (green_spheres.active)
		System.savePersistentData(0xffffffa6, "DAGE_GreenSphereGame", 4)
	else
	{
	#if STANDALONE
		// Save progress to SRAM
		SRAM.save(0xffffffa6, 0x50, 4)		// Copying from the address of bluespheregame.current_stage
		System.savePersistentData(0xffffffa6, "SRAM_BlueSphereProgress", 4)
	#endif
	}
}





function void BlueSphere.setGeneratedStage(u32 number)
{
	if (!challenge_greenspheres)
	{
		u8[0xffffffa2] = number & 0x7f
		u8[0xffffffa3] = (number * 3 + 1) % 0x7f
		u8[0xffffffa4] = (number * 5 + 2) % 0x7e
		u8[0xffffffa5] = (number * 7 + 3) % 0x7d
	}

	// Code for Time Attack mode stage generation
	else
	{
		System.loadExternalRawData("GreenSphereTimeAttackStages", 0xffffffa2, (challenge_greenspheres - 1) * 4, 0x04, 1, 1)	// load premade quadrant configurations

	//	u8[0xffffffa2] = (challenge_greenspheres * 4 - 13) & 0x7f		// Create quadrants by creating values that are 3, 0, 2, and 1 modulo 4 based on stage number.
	//	u8[0xffffffa3] = (challenge_greenspheres * 4 + 48) & 0x7f		// The values are shifted by such arbitrary amounts instead of simply 3, 0 or 4, 1, and 2
	//	u8[0xffffffa4] = (challenge_greenspheres * 4 - 46) & 0x7f		// so that the first green sphere and generated challenge stages don't share quadrants.
	//	u8[0xffffffa5] = (challenge_greenspheres * 4 + 21) & 0x7f

	//	challenge_greenspheres = 0

		// The above variable must be zeroed out somewhere!
		// The palette algorithm still needs to be modified to maximize the number of unique palettes used. It also shows the original sky colors instead of the modded ones.
	}
}




// Don't load the emerald in Special Stage Time Attack.
// In Sonic 2 stages, use Sonic 2 emerald colors.
// Function taken from level\special\bluespheres.lemon
//# address-hook(0x009b62) end(0x009d1c)
function void fn009b62()
{
	if (bluespheres.stage_exit_state == 1)
	{
	#if STANDALONE
		if (bluespheres.rings_remaining == 0)
		{
			Game.setAchievementComplete(ACHIEVEMENT_BS_PERFECT)
		}
	#endif

		// First lift all the spheres before going on
		if (bluespheres.lifted_height < 0x100)
		{
			if (bluespheres.lifted_height == 0)
			{
				playMusic(0x66)
			}
			bluespheres.lifted_height += (bluespheres.lifted_height >= 0x7d) ? 4 : (bluespheres.lifted_height >= 0x3e) ? 3 : 2
			return
		}

		// Spawn the emerald
		++bluespheres.stage_exit_state
		zeroMemory(0xfffff100, 0x400)

		D0.u8 = bluespheres.direction
		LookupSinCos()
		D2.u16 = bluespheres.position.x
		D3.u16 = bluespheres.position.y
		D0.s16 <<= 3
		D1.s16 <<= 3
		D2.u16 -= D0.u16
		D3.u16 -= D1.u16

		A1 = 0xfffff100
		D0.u16 = ((D2.u16 + 0x80) >> 8) & 0x1f
		D1.u16 = ((D3.u16 + 0x80) >> 8) & 0x1f
		D1.u16 = (D1.u16 << 5) | D0.u16
		if (!challenge_greenspheres || unlock_act)
			u8[A1 + D1.s16] = (global.sk_bluespheres) ? 0x0d : 0x0b
		u16[0xffffe44e] = D1.u16
		u16[0xffffe428] = 0x0800
		u8[0xffffe44d] = 0x78

		D0 = (bluespheres.minigame_mode == 0) ? global.next_bluespheres : u8[0xffffffa4]
		A1 = 0x009d1e + (D0.s16 & 0x07) * 8
		copyMemory(0xfffffc64, A1, 0x08)

		if (challenge_greenspheres)
		{
		// Check the ROM location of the palette, which is written to 0xffffe446, to determine how to color the emerald
			if ((challenge_greenspheres & 0x07) == 1)			// (u32[0xffffe446] == 0x0089fe || u32[0xffffe446] == 0x2d5384)		// S3 Stage 1
			{
				u16[0xfffffc64] = 0x0ee8
				u16[0xfffffc66] = 0x0ec0
				u16[0xfffffc68] = 0x0e80
				u16[0xfffffc6a] = 0x0e40					
			}
			else if ((challenge_greenspheres & 0x07) == 2)	// (u32[0xffffe446] == 0x008a24 || u32[0xffffe446] == 0x2d53aa)	// S3 Stage 2
			{
				u16[0xfffffc64] = 0x0e6a
				u16[0xfffffc66] = 0x0c08
				u16[0xfffffc68] = 0x0806
				u16[0xfffffc6a] = 0x0604					
			}
			else if ((challenge_greenspheres & 0x07) == 3)	// (u32[0xffffe446] == 0x008a4a || u32[0xffffe446] == 0x2d53d0)	// S3 Stage 3
			{
				u16[0xfffffc64] = 0x0a6e
				u16[0xfffffc66] = 0x000e
				u16[0xfffffc68] = 0x000a
				u16[0xfffffc6a] = 0x0006
			}
			else if ((challenge_greenspheres & 0x07) == 4)	// (u32[0xffffe446] == 0x008a70 || u32[0xffffe446] == 0x2d53f6)	// S3 Stage 4
			{
				u16[0xfffffc64] = 0x0eae
				u16[0xfffffc66] = 0x0e6e
				u16[0xfffffc68] = 0x0e4e
				u16[0xfffffc6a] = 0x0e0e
			}
			else if ((challenge_greenspheres & 0x07) == 5)	// (u32[0xffffe446] == 0x008a96 || u32[0xffffe446] == 0x2d541c)	// S3 Stage 5
			{
				u16[0xfffffc64] = 0x0aee
				u16[0xfffffc66] = 0x00ce
				u16[0xfffffc68] = 0x008a
				u16[0xfffffc6a] = 0x0068					
			}
			else if ((challenge_greenspheres & 0x07) == 6)	// (u32[0xffffe446] == 0x008abc || u32[0xffffe446] == 0x2d5442)	// S3 Stage 6
			{
				u16[0xfffffc64] = 0x00ea
				u16[0xfffffc66] = 0x00c6
				u16[0xfffffc68] = 0x0082
				u16[0xfffffc6a] = 0x0060
			}
			else if ((challenge_greenspheres & 0x07) == 7)	// (u32[0xffffe446] == 0x008ae2 || u32[0xffffe446] == 0x2d5468)	// S3 Stage 7
			{
				u16[0xfffffc64] = 0x0ccc
				u16[0xfffffc66] = 0x0aaa
				u16[0xfffffc68] = 0x0888
				u16[0xfffffc6a] = 0x0444
			}
		}
		A1 = (global.sk_bluespheres) ? 0x0ae99e : 0x0ae3ec
		Kosinski.addToDMAQueue(A1, 0xb4e0)
	}
	else if (bluespheres.stage_exit_state == 2)
	{
		if (kosinski.waiting_modules == 0)
		{
			u16[0xffffe44a] = 0
			--u8[0xffffe44d]
			if (u8[0xffffe44d] == 0)
			{
				if (challenge_greenspheres && !unlock_act)		// if Special Stage Time Attack,
				{
					playMusic(MUSIC_CTRL_FADEOUT)	// fade out music
					return							// do not load the emerald
				}
				++bluespheres.stage_exit_state
				playMusic(0x2b)
			}
		}
	}
	else if (bluespheres.stage_exit_state == 3)
	{
		D0.u16 = ((bluespheres.position.x + 0x80) >> 8) & 0x1f
		D1.u16 = ((bluespheres.position.y + 0x80) >> 8) & 0x1f
		D1.u16 = (D1.u16 << 5) | D0.u16
		if (D1.u16 == u16[0xffffe44e])
		{
			D0.u16 = (bluespheres.position.x | bluespheres.position.y) & 0xe0
			if (D0.u16 == 0)
			{
				if (bluespheres.minigame_mode == 0)
				{
					// Update either global.chaos_emeralds or global.super_emeralds
					A2 = (global.sk_bluespheres) ? 0xffffffb1 : 0xffffffb0
					if (u8[A2] < 7)
					{
						++u8[A2]
						A1 = 0xffffffb2
						D0 = global.next_bluespheres
						u8[A1 + D0.s16] |= 0x01
					}
				}

				++bluespheres.stage_exit_state
				bluespheres.stage_exit_animation = 1
				global.game_mode = (bluespheres.minigame_mode != 0) ? 0x30 : 0x48

				if (challenge_greenspheres)
				{
					S2Special.swapRingsAndSpheres()
					bluespheres.blue_remaining = 0		// ensure the results screen sees the special stage as won
				}

				if (global.stage_type != 0)
				{
					global.zone_act = level.backup.zone_act
					checkpoint.number |= 0x80
				}

				playSound(0x6a)
			}
		}
	}
}














// Take the direct call to a new game mode and add cases for D.A. Garden menus
//# address-hook(0x000418) end(0x000436)
function void BlueSphereGame()
{
#if !STANDALONE
	call 0x00043a
	u8[0xffffff9f] = D4.u8

	call 0x00111a
	call 0x0012ce
	call 0x0010ae
#endif

	u8[0xffffffa1] = 0
	global.game_mode = 0x2c
	challenge_greenspheres = 0	// ensure this flag isn't left over from elsewhere
	unlock_act = 0				// ensure this flag isn't left over from elsewhere

	while (true)
	{
		if ((global.game_mode & 0x7f) == 0x54)
		{
			Game.setUnderwaterAudioEffect(0)
			// EntryFunctions.dataSelect()
			loadupCustomMenu()
			Game.endSkippableCutscene()
		}
		else if ((global.game_mode & 0x7f) == 0x58)
		{
			Game.setUnderwaterAudioEffect(0)
			// EntryFunctions.dataSelect()
			loadupCustomMenu()
			Game.endSkippableCutscene()
		}
		else
		{
			// See "GameModeControlLoop" for more information
			D0.u16 = global.game_mode & 0x7c
			A0 = u32[0x0004c6 + D0.u16]
			call A0
		}
	}
}








// If exiting the Blue Sphere game, return to the D.A. Garden menu.
// Also ensure Original Mode rendering is not happening.
//# address-hook(0x04d6b8) end(0x04d7a0)
function void fn04d6b8()
{
//	if (original_mode)
//	{
//		setting.original_mode = original_mode
//		original_mode = 0
//	}

	if ((global.game_mode & 0x7f) == 0x58)
		return

	if (green_spheres.active)
		Renderer.drawCustomSprite("hcz_watertint", 0, 0, 0x00, 0, 0x1701, 0, 40)

	#if STANDALONE
	// Do the following only once in total, i.e. only for the right object
	if (objA0.render_flags & 0x01)
	{
		if (levelselect.characters == CHARS_TAILS_ALONE)
		{
			// Manipulate the palette for Tails
			BlueSphereGame.applyTailsPalette(0xfffffc00)
		}

		// Render the BG logo in the right colors again
		Renderer.drawCustomSprite("sklogo", getScreenWidth() / 2, 40 - scrolloffset.y.planeB, 0x00, 0, 0x1700)
	}
#endif

	if (bluespheregame.fully_unlocked != 0)
	{
		A1 = u32[A0 + 0x30]
		D0 = bluespheregame.menu_selection * 4
		D2.u16 = u16[A1 + D0.s16] + getScreenExtend()
		D3.u16 = u16[A1 + D0.s16 + 2]

		// Update velocity-x
		bool skipPart = false
		if (D2.u16 == objA0.position.x.u16)
		{
			D0.u16 = objA0.velocity.x + 0x80
			if (D0.u16 <= 0x0100)
			{
				D1 = 0
				objA0.velocity.x = D1.u16
				skipPart = true
			}
		}

		if (!skipPart)
		{
			D1.u16 = 0x40
			if (D2.s16 < s16[A0 + 0x10])
			{
				D1.s16 = -D1.s16
				if (objA0.velocity.x >= 0)
				{
					D1.u16 *= 4
				}
			}
			else
			{
				if (objA0.velocity.x < 0)
				{
					D1.u16 *= 4
				}
			}
		}
		objA0.velocity.x += D1.u16

		// Update velocity-y
		skipPart = false
		if (D3.u16 == objA0.position.y.u16)
		{
			D0.u16 = objA0.velocity.y + 0x0100
			if (D0.u16 <= 0x0200)
			{
				D1 = 0
				objA0.velocity.y = D1.u16
				skipPart = true
			}
		}

		if (!skipPart)
		{
			D1.u16 = 0x80
			if (D3.s16 < s16[A0 + 0x14])
			{
				D1.s16 = -D1.s16
				if (objA0.velocity.y >= 0)
				{
					D1.u16 *= 4
				}
			}
			else
			{
				if (objA0.velocity.y < 0)
				{
					D1.u16 *= 4
				}
			}
		}
		objA0.velocity.y += D1.u16

		UpdateMovementStraightSimple()
	}

	--objA0.animation.timer
	if (s8(objA0.animation.timer) < 0)
	{
		objA0.animation.timer = 2
		++objA0.animation.sprite
		objA0.animation.sprite &= 0x07
	}

#if STANDALONE
	if (control.pad1.pressed & CONTROL_B || Input.buttonPressed(BUTTON_BACK))
	{
		if ((objA0.render_flags & 0x01) == 0)		// Only consider first of the two objects
		{
			if (bluespheregame.menu_selection == 1)
			{
				// Back to the main menu
				playSound(0xad)
				global.game_mode = 0x58

				u32 backupA0 = A0
				FadeOutScreenBlocking()
				A0 = backupA0

			//	Game.returnToMainMenu()
			//	yieldExecution()
			}
			else if (bluespheregame.menu_selection == 2)
			{
				fn04d488()
			}
		}
		DrawObject()
		return
	}
#endif

	if (control.pad1.pressed & CONTROL_ABC)
	{
		D0.u16 = objA0.sprite_attributes
		if (D0.u16 == 0x8598)
		{
			levelselect.characters = CHARS_SONIC_ALONE
			objA0.sprite_attributes = 0xe598
		}
		else
	#if STANDALONE
		if (D0.u16 == 0xe598)
		{
			levelselect.characters = CHARS_TAILS_ALONE
			objA0.sprite_attributes = 0xc598
		}
		else
	#endif
		{
			levelselect.characters = CHARS_KNUCKLES_ALONE
			objA0.sprite_attributes = 0x8598
		}
	}

	DrawObject()
}




// Custom function to render the green S&K Logo as a background for the end of stage screens
function void RenderSKLogoFullBG()
{
	if !(green_spheres.active)
		return
	
	Renderer.drawCustomSprite("hcz_watertint", 0, 0, 0x00, 0, 0x1701, 0, 40)
	Renderer.drawCustomSprite("blackscreen", 0, 0, 0x00, 0, 0x16ff)	// hide areas on far right in widescreen using a black cover-up

	Renderer.drawCustomSprite("sklogo", -80, 32, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 48, 32, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 176, 32, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 304, 32, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 432, 32, 0x00, 0, 0x1700)	// Render our custom S&K logo

	Renderer.drawCustomSprite("sklogo", -16, 96, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 112, 96, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 240, 96, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 368, 96, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 496, 96, 0x00, 0, 0x1700)	// Render our custom S&K logo

	Renderer.drawCustomSprite("sklogo", -80, 160, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 48, 160, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 176, 160, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 304, 160, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 432, 160, 0x00, 0, 0x1700)	// Render our custom S&K logo

	Renderer.drawCustomSprite("sklogo", -16, 224, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 112, 224, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 240, 224, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 368, 224, 0x00, 0, 0x1700)	// Render our custom S&K logo
	Renderer.drawCustomSprite("sklogo", 496, 224, 0x00, 0, 0x1700)	// Render our custom S&K logo
}







// Insert calls to RenderSKLogoFullBG in functions that draw text on relevant screens.
// Functions taken from general\bluesphere\bluespheregame.lemon
// This function draws LEVEL, and we add a check to only use the results screen.
// However, using this function also causes the original logos to show during the fadeout.
//# address-hook(0x04d09e) end(0x04d0f0)
function void fn04d09e()
{
	if (global.game_mode == 0x30)	// Perfect results screen
		RenderSKLogoFullBG()
	base.fn04d09e()
}

// This function draws DIFFICULTY. While the Perfect results also uses LEVEL, the game mode
// for this screen is the same as the blue sphere game menu screen, which also uses LEVEL.
//# address-hook(0x04e116) end(0x04e15a)
function void fn04e116()
{
	RenderSKLogoFullBG()
	base.fn04e116()
}

// Use an image for the PERFECT text on the results screen, as plane mappings wrap improperly in ultrawide resolutions.
// Functions taken from general\blueshpere\bluespheregame.lemon
// This first function checks if the plane mappings and extra display time for the PERFECT text should be loaded.
//# address-hook(0x04df04) end(0x04df50)
function void fn04df04()
{
	--u16[A0 + 0x30]
	if (s16[A0 + 0x30] < 0)
	{
		if (bluespheres.rings_remaining == 0)
		{
		// We comment out loading the plane mappings for the PERFECT text.
	//	#if !STANDALONE
	//		set_status_register(0x2700)
	//	#endif
	//		A1 = 0x04de9a	// "PERFECT"
	//		D2.u16 = 0x049a
	//		D6.u16 = (sprite_attribute.PRIORITY | (BlueSphereGame.TextTiles.targetInVRAM >> 5))
	//		fn05b318()
	//	#if !STANDALONE
	//		set_status_register(0x2300)
	//	#endif

			playSound(0xac)
			u16[A0 + 0x30] = 0x012c
		}
		objA0.update_address = 0x04df52
	}

	if (bluespheres.rings_remaining != 0 && control.pad1.pressed != 0)
	{
		global.game_mode = 0x2c
	}
}

// This function shifts the PERFECT text far off the right of the screen by adjusting the horizontal scroll buffer values.
// We incorporate our image of the text here and only display it when the buffer values indicate the text is within the screen boundaries.
//# address-hook(0x04df52) end(0x04df84)
function void fn04df52()
{
	if (bluespheres.rings_remaining == 0)
	{
		--u16[A0 + 0x30]
		if (s16[A0 + 0x30] < 0)
		{
			global.game_mode = 0x2c
		}
	}

	if (control.pad1.pressed != 0)
	{
		global.game_mode = 0x2c
	}

	D0.u8 = global.framecounter.low & 0x0f
	if (D0.u8 == 0)
	{
		A1 = 0xffffe120				// address of first row of pixels of PERFECT text in the horizontal scroll buffer (text draws on Plane 1 High/Prio, renderQueue 0x4000)
		D1 = 0x0f					// number of lines to affect minus 1
		while (D1.s16 >= 0)
		{
			u16[A1] ^= 0x0100		// Alternately shift the row 0x100 (256 pixels) left or right (between 0x0058 and 0x0158), scrolling it off screen.
									// Problem: horizontal scrolling loops every 512 pixels and A.I.R. supports 496x224. Lines longer than 16 pixels will loop horizontally!
			A1 += 4					// Move to the next row.
			--D1.s16				// Decrement number of rows remaining to shift.
		}
	}

	// With the plane mappings gone, we use an image in the text's place that shows if the first byte of the horizontal scroll values is appropriate.
	if (u8[0xffffe120] == 0)
		Renderer.drawCustomSprite("results_perfect", getScreenWidth()/2, 81, 0, 0, 0x4001)
}

// Green sphere palette setup and a new line to reset the displayed time at the start of a special stage
// Taken from scripts\level\special\bluespheres.lemon
//# address-hook(0x0081c6) end(0x00858e)
function void SpecialStage()
{
	if (!original_mode)
		playMusic(MUSIC_CTRL_FADEOUT)
	else
		playMusic(MUSIC_CTRL_STOP)

	kosinski.queue_size = 0
	zeroMemory(0xffffff10, 0x6c)

	ClearPatternLoadingQueue()
	FadeScreenToWhiteBlocking()

#if STANDALONE
	// Add a small artificial delay here
	u8 delayFrames = (original_mode || unlock_act) ? 112 : 12
	for (u8 i = 0; i < delayFrames; ++i)
		yieldInWhiteScreen()
#else
	set_status_register(0x2700)
#endif

	VDP.Config.enableHInt(false)
	VDP.Config.setNameTableBasePlaneA(0xc000)
	VDP.Config.setNameTableBasePlaneB(0xe000)
	VDP.Config.setPlayfieldSizeInPixels(512, 256)
	VDP.Config.setupWindowPlane(false, 0)	// Disable window plane
	VDP.Config.setVerticalScrolling(false, 0)
	VDP.Config.setBackdropColor(0x20)
	VDP.Config.setRenderingModeConfiguration(false)
	water.fullscreen = 0

	fn0011ca()

	zeroMemory(0xffffac00, 0x400)
	zeroMemory(0xffffb000, 0x2000)
	zeroMemory(0xfffffe6e, 0x4c)
	zeroMemory(0xffffe400, 0x100)

	u32[0xfffffe66] = 0
	u32[0xfffffe6a] = 0

	fn01aa6e()

	u16[0xfffffb00] = 0
	u32[0xfffffbfc] = 0xfffffb00

	// Load special stage palette
	//  -> Character colors is the 8 colors from 0xfffffc90 (for Sonic/Knuckles) and 0xfffffcb0 (for Tails)
	copyMemory(0xfffffc80, 0x00896e, 0x100)
	if (global.characters == CHARS_KNUCKLES_ALONE)
	{
		copyMemory(0xfffffc90, 0x0089ee, 0x10)
	}

#if STANDALONE
	for (u8 player = 0; player < getNumPlayers(); ++player)
	{
		u8 character = getPlayerCharacter(player)
		u64 paletteKey = (character == CHARACTER_SONIC) ? "bluesphere_palette_sonic" : (character == CHARACTER_TAILS) ? "bluesphere_palette_tails" : "bluesphere_palette_knuckles"
		u16 numColors = System.loadExternalPaletteData(paletteKey, 0, 0x800000, 0x20)
		if (numColors > 0)
		{
			u32 dest = 0x802180 + character * 0x40
			for (u16 i = 0; i < numColors; ++i)
			{
				u16[dest + i * 2] = packColor(u32[0x800000 + i * 4])
			}
		}
	}
#endif

	Nemesis.loadDataToVRAM(0x0b07b8, 0x0000)

	fn0085b0()
	if (!original_mode)	// no green sphere palette in original mode
	{
		// new code for green spheres
		// green sphere palette from concept vid, translated by Fred Bronze
		u32[0xfffffce4] = 0x00c600a0
		u32[0xfffffce8] = 0x00600020
		u32[0xfffffcec] = 0x00c600a0

		if (green_sphere_palette == 1)
		{
			// green sphere palette closer to Mania palette
			u32[0xfffffce4] = 0x04e002c0
			u32[0xfffffce8] = 0x02800040
			u32[0xfffffcec] = 0x04e002c0
		}
	}

	Enigma.decompress(0x0aef54, 0xffff5500, 0x0000)
	copyRectToVRAM(0xffff5500, 0xc000, 0x28, 0x1c)

	Nemesis.loadDataToVRAM(0x0ad904, 0xd000)
	Nemesis.loadDataToVRAM(0x0adf60, 0xb4e0)
	Nemesis.loadDataToVRAM(0x0aeed0, 0xb360)
	if (!challenge_greenspheres)
	{
		Nemesis.loadDataToVRAM(0x0ad472, 0xabe0)
		Nemesis.loadDataToVRAM(0x0ad5f4, 0xdf00)
	}
	else
	{
		VDP.setupVRAMWrite(0xabe0)
		VDP.zeroVRAM(0xb120 - 0xabe0)	// GET BLUE SPHERES and PERFECT texts should not show in Sonic 2 special stages
		VDP.setupVRAMWrite(0xdf00)
		VDP.zeroVRAM(0xe000 - 0xdf00)	// graphics bookending the text should not show
	}
	Nemesis.loadDataToVRAM(0x0ad650, 0xf020)

	A0 = 0x0ad650
	A4 = 0xffffe020
	fn0015cc()

	Nemesis.loadDataToVRAM(0x0ad7bc, 0xb120)
	Nemesis.loadDataToVRAM(0x0ad430, 0xf400)

	copyRectToVRAM(0x008d2c, 0xc084, 0x08, 0x03)
	copyRectToVRAM(0x008d2c, 0xc0bc, 0x08, 0x03)

	Enigma.decompress(0x0aedb0, 0xffff0000, 0x459b)
	copyRectToVRAM(0xffff0000, 0xe000, 0x40, 0x20)

	Kosinski.decompress(0x0b2e36, 0xffff0000)

	fn009ea0()
	fn00a0e6()
	// copyMemory(0xffffe4f0, 0xffffe4f0, 0x08)	// Copy the mappings pointer for sphere ID 0x0c (touched green sphere) to new slot 0x0e (untouched green sphere)
												// We're not using this method anymore, instead putting in a check later that says to treat 0x0e as 0x0c when needed.

	global.level_started = 0
	bluespheres.bs_hud_dirty = 0xff
	bluespheres.rings_flags = 0x80
	bluespheres.current_gamespeed = 0x1000	// usually 0x1000
	bluespheres.speedup_countdown = BlueSpheres.useGeneratedStages() ? 2700 : 1800
	if (challenge_greenspheres)
		bluespheres.speedup_countdown = 1
	camera.foreground.x.u16 = 0
	camera.foreground.y.u16 = 0
	level.height.bitmask = 0xffff
	time_attack_end = 0		// new: if we just came out of a Challenge, make sure pausing is re-enabled.
	BS_displayedTime = 0	// new: resets the time display between stages

	u32[0xffffb000] = 0x008faa	// initialize main character
	BS_fadeFinished = 0			// new for DAGE: ensure byte 0x3e of the character RAM is clear to lock controls in Original Mode until after fade in completes
	if (getNumPlayers() >= 2 && !bluespheres.minigame_mode)
	{
		u32[0xffffb04a] = 0x009212
	}
	u32[0xffffb094] = 0x008df8
	u32[0xffffb0de] = 0x008e40
	UpdateGameObjects()

	fn009d9e()
	fn009dde()
	RenderSprites()

	BlueSpheres.RenderSpheres()
	fn009d5e()

	bluespheres.stage_exit_animation = 1
	global.frame_state = 0x1c

	waitForNextFrame()

	bluespheres.stage_exit_animation = 0
	VDP.Config.setRenderingModeConfiguration(true)		// Enable shadow/highlight palette mode

	global.demo_countdown = 1800
	fn0075d2()

#if STANDALONE
	if (BlueSpheres.useGeneratedStages())
	{
		playMusic(0xf8)		// Different music track, one that speeds up the music only every 45 (instead of 30) seconds
	}
	else
#endif
	{
		playMusic(0x1c)
	}

	VDP.Config.setActiveDisplay(true)
	BlueSpheres.FadeIn()

	while (true)
	{
		if (restartSpecialStage == 1)
		{
			restartSpecialStage = 0
			return
		}
		UpdateGamePause()
		global.frame_state = 0x1c
		Kosinski.ProcessDecompressionQueue()

		waitForNextFrame()
	@EntryPoint:

		++level.framecounter
		if (original_mode)
			BS_fadeFinished = 1			// new for DAGE: set our custom flag to allow controls after fade in in Original Mode
		UpdateRollingDemo()
		UpdateGameObjects()

		fn009d9e()
		fn009dde()
		RenderSprites()

		BlueSpheres.RenderSpheres()
		BlueSpheres.RenderCharacterSprites()
		fn009d5e()
		fn009b62()

	#if GAMEAPP
		BlueSpheres.renderCustomGround()
		BlueSpheres.renderCustomCharacterShadows()
	#else
	#if STANDALONE
		Renderer.setViewport(getScreenExtend(), 0, 320, 224, 0x0000)
	#endif
	#endif

		LoadRequiredSpritePatterns()
		Kosinski.ProcessModules()

		if (global.rolling_demo && global.demo_countdown == 0)
			break

		if (global.game_mode != 0x34)	// Blue Spheres game mode
			break

	#if STANDALONE
		// Only needed to support restart from the Pause Menu
		//  -> Not used at the moment, so nevermind
		if (level.restart)
		{
			global.game_mode = 0x0c
			return
		}
	#endif
	}

	if (global.rolling_demo)
	{
		global.game_mode = 0
	}

	global.demo_countdown = 60
	palette_fade.range = 0x003f
	u16[0xfffff794] = 0

	while (true)
	{
		global.frame_state = 0x1c

		waitForNextFrame()

		UpdateRollingDemo()
		UpdateGameObjects()

		fn009d9e()
		fn009dde()
		RenderSprites()

		BlueSpheres.RenderSpheres()
		fn009d5e()
		fn009b62()

	#if GAMEAPP
		BlueSpheres.renderCustomGround()
		BlueSpheres.renderCustomCharacterShadows()
	#else
	#if STANDALONE
		Renderer.setViewport(getScreenExtend(), 0, 320, 224, 0x0000)
	#endif
	#endif

		LoadRequiredSpritePatterns()
		Kosinski.ProcessModules()

		--u16[0xfffff794]
		if (s16[0xfffff794] < 0)
		{
			u16[0xfffff794] = 2
			FadePaletteToWhite()
		}

		if (global.demo_countdown == 0)
			break
	}
}




// If in a Sonic 2 special stage, do not render the HUD graphic sprites.
//# address-hook(0x008df8) end(0x008e2a)
function void fn008df8()
{
	if (!challenge_greenspheres)
		base.fn008df8()
}




// This function runs many ongoing parts of Blue Sphere, such as letting characters jump and controlling when the stage speeds up.
// We add in calls to update the timer's value each frame and to check for the back and retry buttons.
//# address-hook(0x00903e) end(0x00919e)
function void fn00903e()
{
	if (BS_displayedTime < 35999 && bluespheres.stage_exit_state == 0)
		BS_displayedTime++
	if (!bluespheres.stage_exit_state && BS_remainingTime && !bluespheres.stage_exit_state && !bluespheres.stage_exit_animation && bluespheres.started_running)
		BS_remainingTime--
	if (showTimeGain)
		showTimeGain--
	if (showTimeGainTarget)
		showTimeGainTarget--

	if (challenge_greenspheres && !BS_remainingTime && !bluespheres.stage_exit_animation)
	{
		// Game over
		bluespheres.stage_exit_animation = 1
		global.game_mode = (bluespheres.minigame_mode == 0) ? 0x48 : 0x2c
		if (challenge_greenspheres)
		{
			S2Special.swapRingsAndSpheres()
			bluespheres.blue_remaining = 1		// do not let the results screen believe the stage was won
		}
		if (global.stage_type != 0)
		{
			global.zone_act = level.backup.zone_act
			checkpoint.number |= 0x80
		}
		playSound(0x6a)
	}

	if (bluespheres.speedup_countdown != 0)
	{
		--bluespheres.speedup_countdown
		if (bluespheres.speedup_countdown == 0)
		{
			// Increase speed (up to four times)
			bluespheres.speedup_countdown = BlueSpheres.useGeneratedStages() ? 2700 : 1800
			if (challenge_greenspheres)
				bluespheres.speedup_countdown = 1
			if (bluespheres.current_gamespeed < 0x2000)
			{
				if (challenge_greenspheres && bluespheres.started_running)	// speedup by 1.5 per frame, rounded down, achieving full speed in about 45.5 seconds
				{
					bluespheres.current_gamespeed++
					if (level.framecounter.low & 0x01 && bluespheres.current_gamespeed < 0x2000)
						bluespheres.current_gamespeed++
				}
				else if (!challenge_greenspheres)
				{
					bluespheres.current_gamespeed += 0x400
				}

				// Tempo values are (in that order):
				//  0x20, 0x18, 0x10, 0x08
				//  -> The music speed steps are: normal speed, +1/16, +1/12, +1/8, +1/4
				//  -> Each for 30 seconds (or 45 seconds for generated stages)
				D0.u8 = 0x48 - (bluespheres.current_gamespeed >> 8) * 2
				changeMusicTempo(D0.u8)
			}
		}
	}

	fn009580()

	D0 = 0x0c
	if (bluespheres.movement_speed != 0)
	{
		u16[A0 + 0x24] += bluespheres.movement_speed >> 5
		D0 = objA0.animation.timer
		if (D0.s8 < 0)
		{
			D0.u8 += 0x0c
		}
		else if (D0.u8 >= 0x0c)
		{
			D0.u8 -= 0x0c
		}
	}

	objA0.animation.timer = D0.u8
	if (bluespheres.jumping_flags.player1 & 0x80)
	{
		A1 = 0x0091f6
		if (bluespheres.movement_speed == 0)
		{
			D0.u16 = level.framecounter.low & 0x03
		}
	}
	else
	{
		A1 = 0x0091e8
	}

	objA0.animation.sprite = u8[A1 + D0.s16]
	if ((bluespheres.jumping_flags.player1 & 0x80) == 0 && bluespheres.stage_exit_state == 0 && (control.pad1.pressed & CONTROL_ABC))
	{
		bluespheres.jumping_flags.player1 = 1
	}

	D0.u8 = bluespheres.direction & 0x3f
	if (D0.u8 == 0)
	{
		if (bluespheres.jumping_flags.player1 == 1)
		{
			u32[A0 + 0x40] = 0xfff00000
			bluespheres.jumping_flags.player1 = 0x80
			bluespheres.next_direction = 0
			playSound(SFX_JUMP)
		}

		if (bluespheres.jumping_flags.player1 & 0x80)
		{
			D0 = u32[A0 + 0x3c] + u32[A0 + 0x40]
			if (D0.s32 >= 0)
			{
				D0 = 0
				u32[A0 + 0x40] = 0
				bluespheres.jumping_flags.player1 = 0
			}

			u32[A0 + 0x40] += bluespheres.current_gamespeed << 4
			u32[A0 + 0x3c] = D0
			D0 = (D0 << 16) + (D0 >> 16)
			D0.u16 -= 0x800
			u16[A0 + 0x36] = D0.u16
		}
	}

	fn00950c()
	fn00953e()
	DrawObject()

	if (isMainCharacter(CHARACTER_TAILS))
	{
		A2 = 0x2908d2
		D6 = 0x28f95a
		D4.u16 = SpecialStage.Tails.targetInVRAM
	}
	else if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		A2 = 0x0ad31a
		D6 = 0x0abf22
		D4.u16 = SpecialStage.Player.targetInVRAM
	}
	else
	{
		A2 = 0x0abe14
		D6 = 0x0aaa7c
		D4.u16 = SpecialStage.Player.targetInVRAM
	}

	fn0091a2()
}










// This function is for compatibility with Mania-Styled Blue Spheres.
function u64 ManiaSpheres.getSphereSprite(u8 sphereType, u8 form, u8 form16)
{
	if (sphereType == 0x0e)
		return stringformat("GreenSphere_size_%d", form)
	else
		return base.ManiaSpheres.getSphereSprite(sphereType, form, form16)
}




// These functions are for compatibility with Blue Sphere Time Attack.
// Taken from scripts\standalone\entryfunctions.lemon
function void EntryFunctions.sharedInit()
{
	#if GAMEAPP
		// Disabled the muffled underwater sound effect in any case
		specialstages_knuckles.shared = specialstages_knuckles
		Game.setUnderwaterAudioEffect(0)
	#endif
}

function void EntryFunctions.blueSphereGame()
{
	green_spheres.active = 0x01		// set flag if entering the Blue Sphere game mode (Green Spheres for DAGE)
	base.EntryFunctions.blueSphereGame()
}

function void EntryFunctions.levelSelect()
{
	green_spheres.active = 0x01		// set flag if entering the level select. Entering special stages via a level sees the flag set in Standalone.onLevelStart().
	specialstages_knuckles.shared = specialstages_knuckles
	EntryFunctions.sharedInit()
	System.setupCallFrame("GameModeControlLoop", "@EntryPoint")
	System.setupCallFrame("LevelSelect")

	global.game_mode = 0x1c
}






// Remove the sound that plays when first entering Blue Sphere mode, as our custom menu already makes one.
// Function taken from general\bluesphere\bluespheregame.lemon
//# address-hook(0x04ceb6) end(0x04cef4)
function void fn04ceb6()
{
#if !STANDALONE
	if (u8[0x000000] != 0)	// Does this make any sense at all?
		return
#endif

	// For standalone, wait briefly (to prevent glitches) instead of requiring A+B+C buttons
#if STANDALONE
	if (global.framecounter > 30)
#else
	if (control.pad1.state == CONTROL_ABC)
#endif
	{
		control.pad1.pressed = 0
		D0 = 0xffffffff
		bluespheres.blue_remaining = D0.u16
		bluespheres.rings_remaining = D0.u16
	//	playSound(0x63)

	#if !STANDALONE
		set_status_register(0x2700)
	#endif
		A1 = 0x04cc62
		D2.u16 = 0x0100
		D6.u16 = 0x05bf
		fn05b318()
	#if !STANDALONE
		set_status_register(0x2300)
	#endif

		fn04cef8()
	}
}



// Have certain challenge mode stages call the generated stage algorithm
// Function taken from level\special\bluespheres.lemon
function bool BlueSpheres.useGeneratedStages()
{
#if STANDALONE
	if ((Game.getSetting(SETTING_RANDOM_SPECIALSTAGES) || challenge_greenspheres) && !original_mode)
		return true
#endif
	if (original_mode)
		return false
	
	return (bluespheres.minigame_mode != 0)
}



// Create a second set of special stage layouts for Knuckles and set whether green or yellow spheres are used.
// Also fixes a glitch with how colors are loaded into Sonic 3 Special Stage 4 in Original Mode.
// Taken from scripts\level\special\bluespheres.lemon
//# address-hook(0x0085b0) end(0x0087b8)
function void fn0085b0()
{
	u16 reverseStart = 0

	if (!original_mode)
		Renderer.setScreenSize(screen_width, 224)

	bool useSKLayouts = (global.lock_on_state != 0 || global.sk_bluespheres)
	if (challenge_greenspheres)
	{
		useSKLayouts = ((challenge_greenspheres & 0x0f) > 8)
		BS_remainingTime = S2Special.BonusTime[challenge_greenspheres * 3 - 3] * 60
		bluespheres.blue_collected = 0
		showTimeGain = 0
		showTimeGainTarget = 0
	}
	bool useGeneratedStage = BlueSpheres.useGeneratedStages()
	bool isGeneratedStageInMainGame = (useGeneratedStage && bluespheres.minigame_mode == 0)

	u8[0xffffef7c] &= 0xfe		// clear green sphere RAM flag (least significant bit of 0xfffffe7c) and leave other bits alone

	if (!useGeneratedStage)
	{
		// Main game stages
		if (isMainCharacter(CHARACTER_KNUCKLES) && useSKLayouts && specialstages_knuckles && !original_mode)	// new check for Knuckles
		{
			Kosinski.decompress(0x2d3ad0, 0xffff0000)	// shift to ROM location of Knuckles' super emerald layouts
			u8[0xffffef7c] |= 0x01	// set a green sphere flag for mods in the least significant bit of otherwise unused RAM byte 0xffffef7c
		}
		else
			Kosinski.decompress(u32[0x1e4078], 0xffff0000)

		global.next_bluespheres = BlueSpheres.getNextOpenStageIndex()

		// Load level layout, either from S3 or S&K
		A2 = useSKLayouts ? 0x008590 : 0x25e2d8
		A2 = u32[A2 + global.next_bluespheres * 4]
		if (!useSKLayouts)
		{
			A2 += 0x200000
			if (isMainCharacter(CHARACTER_KNUCKLES) && specialstages_knuckles && !original_mode)	// new check for Knuckles
				A2 += 0x0679b0	// shift to ROM location of Knuckles' chaos emerald layouts
		}
		
		
		

		zeroMemory(0xfffff000, 0x100)
		copyMemory(0xfffff100, A2, 0x400)
		zeroMemory(0xfffff500, 0x100)
		A2 += 0x400

		u16[0xffffe426] = u16[A2]
		bluespheres.position.x = u16[A2+2]
		bluespheres.position.y = u16[A2+4]
		bluespheres.rings_remaining = u16[A2+6]

		// Special check for Original Mode Sonic 3 Secret Special Stage
		if (original_mode && !useSKLayouts && global.next_bluespheres == 7)
		{
			System.loadExternalRawData("S3SS8_Orig", 0xfffff100, 0, 0x400, 0, 1)	// stage layout
			System.loadExternalRawData("S3SS8_Orig", 0xffffe426, 0x400, 2, 0, 1)
			System.loadExternalRawData("S3SS8_Orig", 0xffffe422, 0x402, 4, 0, 1)	// bluespheres.position.x and bluespheres.position.y
			System.loadExternalRawData("S3SS8_Orig", 0xffffe442, 0x406, 2, 0, 1)	// bluespheres.rings_remaining
		}
		// Special check for Original Mode Sonic & Knuckles Special Stage 5
		else if (original_mode && useSKLayouts && global.next_bluespheres == 4)
		{
			System.loadExternalRawData("SKSS5_Orig", 0xfffff100, 0, 0x400, 0, 1)	// stage layout
			System.loadExternalRawData("SKSS5_Orig", 0xffffe426, 0x400, 2, 0, 1)
			System.loadExternalRawData("SKSS5_Orig", 0xffffe422, 0x402, 4, 0, 1)	// bluespheres.position.x and bluespheres.position.y
			System.loadExternalRawData("SKSS5_Orig", 0xffffe442, 0x406, 2, 0, 1)	// bluespheres.rings_remaining
		}
		// Special check for Original Mode Sonic & Knuckles Special Stage 7
		else if (original_mode && useSKLayouts && global.next_bluespheres == 6)
		{
			System.loadExternalRawData("SKSS7_Orig", 0xfffff100, 0, 0x400, 0, 1)	// stage layout
			System.loadExternalRawData("SKSS7_Orig", 0xffffe426, 0x400, 2, 0, 1)
			System.loadExternalRawData("SKSS7_Orig", 0xffffe422, 0x402, 4, 0, 1)	// bluespheres.position.x and bluespheres.position.y
			System.loadExternalRawData("SKSS7_Orig", 0xffffe442, 0x406, 2, 0, 1)	// bluespheres.rings_remaining
		}

		// New if statement that activates yellow spheres instead of green spheres outside of Knux's Super Emerald Stages.
		// 0 was used for testing green spheres being on, so make the flag 1 to disable them.
//		if (isGeneratedStageInMainGame)
//			yellow_spheres = 1	// yellow sphere flag enabled
//		else if (!useSKLayouts || !isMainCharacter(CHARACTER_KNUCKLES) || (isMainCharacter(CHARACTER_KNUCKLES) && !specialstages_knuckles))
//			yellow_spheres = 1
//		else
//			yellow_spheres = 0

		// Find which palette to use
		A1 = u32[0x0088ba + global.next_bluespheres * 0x10]
		if (useSKLayouts)
		{
			A1 += 0x0130
		}
		// new if statement to switch to new Special Stage palette offset
		if (palette_set >= 2 && !original_mode)
			A1 += 0x2cb80e	// distance between old and new offsets
	}
	else
	{
		// Bluespheres mini-game mode
//		yellow_spheres = 1 // new line to ensure green spheres are not overwriting yellow spheres

		bool KnucklesMainGameRandomGreenSphereStage = (useGeneratedStage && isMainCharacter(CHARACTER_KNUCKLES) && useSKLayouts && specialstages_knuckles && !original_mode)
		if (challenge_greenspheres)	// This is the same result as normal Green Sphere stages. We keep it separate for now just in case it requires special functionality later.
		{
			System.loadExternalRawData("GreenSphereGame", KosinskiRawdataBuffer)	// copy green sphere quarter layouts to shared memory
			Kosinski.decompress(KosinskiRawdataBuffer, 0xffff0000)				// decompress them
		}
		else if (((!specialstages_knuckles && bluespheres.minigame_mode == 0) || (isGeneratedStageInMainGame && (!isMainCharacter(CHARACTER_KNUCKLES) || !useSKLayouts))) || !green_spheres.active)
		{
			Kosinski.decompress(u32[0x1e407c], 0xffff0000)	// Loads lookup data for the 0x80 quarter layouts. Total size is 0x900 bytes.
															// In ROM, u32[0x1e407c] = 0x1fd5ca, which is the address of the blue spheres quarter layouts.
															// The first 0x80 bytes (uncompressed) give the number of rings in each quarter layout.
															// The next 0x80 bytes (uncompressed) are the difficulty of each quarter layout.
															// Next, all 0x80 quarter layouts take up 0x100 bytes (uncompressed) each.
		}
		else
		{
			System.loadExternalRawData("GreenSphereGame", KosinskiRawdataBuffer)	// copy green sphere quarter layouts to shared memory (seems to be a length of 0x22b8)
			Kosinski.decompress(KosinskiRawdataBuffer, 0xffff0000)				// decompress them
		}

		zeroMemory(0xfffff000, 0x600)

	#if STANDALONE
		if (challenge_greenspheres)
			BlueSphere.setGeneratedStage(0)	// the input value doesn't matter, as challenge_greenspheres will override it
		else if (isGeneratedStageInMainGame)
		{
			// Most of the "magic numbers" you see are more or less arbitrary numbers
			u32 stageNumber = 0x13571113 + u32(global.game_random_base) * 0x09070503 + global.next_bluespheres + global.sk_bluespheres * 8

			// Limit difficulty to a maximum value of 6, as higher ones tend to get kind of unfair if you can't just try them over and over again
			u8 difficulty = 0xff
			while (difficulty > 6)
			{
				stageNumber += 0x050b030f
				BlueSphere.setGeneratedStage(stageNumber)

				difficulty = 0
				for (u8 quarter = 0; quarter < 4; ++quarter)
				{
					u16 type = u8[0xffffffa2 + quarter] & 0x7f
					if (type == 0x6d)		// Do not allow type 0x6d specifically, because it is EVIL!
						difficulty += 0x10
					difficulty += u8[0xffff0080 + type]
				}
			}
		}

		if (bluespheres.minigame_mode == 0)
		{
			global.next_bluespheres = BlueSpheres.getNextOpenStageIndex()
		}
		else
	#endif
		{
			global.next_bluespheres = 0
		}
		bluespheres.direction = 0x40
		bluespheres.position.x = 0x1000
		bluespheres.position.y = 0x0300
		
		// Let's start half of generated stages facing the opposite direction to mix things up!
		u16 oddSum = 0
		if (useGeneratedStage)
			oddSum = (u8[0xffffffa2] + u8[0xffffffa3] + u8[0xffffffa4] + u8[0xffffffa5]) & 0x01
		reverseStart = (oddSum && !challenge_greenspheres) | (!oddSum && challenge_greenspheres)
		if (reverseStart && useGeneratedStage)	// These opposite algorithms ensure Level 1 in both Challenge and normal Green Spheres starts forward-facing
		{
			bluespheres.direction += 0x80	// start a few stages facing the opposite direction to prevent counterclockwise movement from getting same-y
//			bluespheres.position.x = 0x1100
		}

		bluespheres.rings_remaining = 0
		u16[0xffffffac] = 0

		// To build the generated stage, cycle through 4 quarters that get selected individually
		for (u8 quarter = 0; quarter < 4; ++quarter)
		{
			u16 type = u8[0xffffffa2 + quarter] & 0x7f
			bluespheres.rings_remaining += u8[0xffff0000 + type]
			u16[0xffffffac] += u8[0xffff0080 + type]				// Affects the difficulty (stored in upper byte)

			A2 = 0xffff0100 + (type << 8)
			A1 = 0x0087ba + quarter * 8
			D3.u16 = u16[A1]
			D4.u16 = u16[A1+2]
			D5.u16 = u16[A1+4]
			D0.u16 = u16[A1+6]

			A3 = 0xfffff100 + D0.u16
			for (u8 y = 0; y < 0x10; ++y)
			{
				u16 offset = D4.u16
				for (u8 x = 0; x < 0x10; ++x)
				{
					u8[A3 + x] = u8[A2 + offset]
					offset += D3.u16
				}
				A3 += 0x20
				D4.u16 += D5.u16
			}
		}

		if (bluespheres.minigame_mode)			// get palette for normal Green Sphere stages
		{
			A1 = u32[0x0088ba + (u8[0xffffffa4] & 0x07) * 0x10]
			if (u8[0xffffffa4] & 0x08)
			{
				A1 += 0x0130
			}
		}
		else									// get palette for main game randomly generated special stages or Challenge stages
		{
			if (challenge_greenspheres && palette_set >= 2)
			{
				A1 = u32[0x0088ba + ((challenge_greenspheres - 1) & 0x07) * 0x10]	// gets the appropriate DAGE Revisited palette	// 0x2cc986 is distance between base Sonic 3 offset and Sonic 2 offset
				A1 += 0x2cc986
				// Note there is currently no palette change for S&K layouts.
			}
			else
			{
				A1 = u32[0x0088ba + ((challenge_greenspheres - 1) & 0x07) * 0x10]	// kept separate from above in case of future alterations
				if (useSKLayouts)
				{
					A1 += 0x0130
				}
			}
		}


		// new if statement to switch to new Special Stage palette offset
		if (palette_set >= 2 && !original_mode && green_spheres.active && !challenge_greenspheres)
			A1 += 0x2cb80e	// distance between old and new offsets
	}



	// Load colors
	u32[0xffffe446] = A1
	A2 = 0xfffffc80
	copyMemory(A2 + 0x70, A1, 0x10)			// Ground colors
/*	
	if (global.next_bluespheres == 3 && !useSKLayouts && !useGeneratedStage)	// fixes a color glitch in Sonic 3 Special Stage 4 resulting from its start position
	{																			//  || (reverseStart && useGeneratedStage)
		u32 colorSwap = u32[0xfffffcf0]
		u32[0xfffffcf0] = u32[0xfffffcf8]
		u32[0xfffffcf4] = u32[0xfffffcf8]
		u32[0xfffffcf8] = colorSwap
		u32[0xfffffcfc] = colorSwap
	}
*/
	copyMemory(A2 + 0x50, A1 + 0x20, 6)		// Sky colors

#if STANDALONE
	if (isGeneratedStageInMainGame && !challenge_greenspheres)
	{
		// Overwrite the sky colors (A2 + 0x50 = 0xfffffcd0) with the correct ones
		A1 = u32[0x0088ba + global.next_bluespheres * 0x10]
		if (useSKLayouts)
		{
			A1 += 0x0130
		}
		copyMemory(A2 + 0x50, A1 + 0x20, 6)
	}
#endif
}












// If green spheres replace yellow spheres, then don't let Tails interact with them.
//# address-hook(0x00927a) end(0x009378)
function void fn00927a()
{
	D0 = 0x0c
	D1.u16 = bluespheres.movement_speed
	if (D1.u16 != 0)
	{
		D1.s16 >>= 5
		u16[A0 + 0x24] += D1.u16
		D0 = objA0.animation.timer
		if (D0.s8 < 0)
		{
			D0.u8 += 0x0c
		}
		else if (D0.u8 >= 0x0c)
		{
			D0.u8 -= 0x0c
		}
	}
	objA0.animation.timer = D0.u8

	A1 = 0x0091e8
	if (bluespheres.jumping_flags.player2 != 0)
	{
		A1 = 0x009204
		D1.u16 = bluespheres.movement_speed
		if (D1.u16 == 0)
		{
			D0.u8 = level.framecounter.low
			D0.u16 &= 0x03
		}
	}
	objA0.animation.sprite = u8[A1 + D0.s16]

	fn009402()

	if (u8[A0 + 0x44] == 0x05 && bluespheres.stage_exit_state == 0 && s8(bluespheres.jumping_flags.player2) >= 0)	// last comparison is new: checks green sphere stage flag
	{
		if ((bluespheres.direction & 0x3f) == 0)
		{
			u32[A0 + 0x40] = 0xffe80000
			bluespheres.jumping_flags.player2 = 0x81
			playSound(0xb1)
		}
	}

	fn00937c()
	D0.u16 &= 0x70
	if (D0.u16 != 0 && bluespheres.jumping_flags.player2 == 0)
	{
		u32[A0 + 0x40] = 0xfff00000
		bluespheres.jumping_flags.player2 = 0x80
		playSound(SFX_JUMP)
	}

	if (s8(bluespheres.jumping_flags.player2) < 0)
	{
		D0 = u32[A0 + 0x3c] + u32[A0 + 0x40]
		if (D0.s32 >= 0)
		{
			D0 = 0
			u32[A0 + 0x40] = 0
			bluespheres.jumping_flags.player2 = 0
		}
		D1.s32 = s16(bluespheres.current_gamespeed) << 4
		u32[A0 + 0x40] += D1
		u32[A0 + 0x3c] = D0
		D0 = (D0 << 16) + (D0 >> 16)
		D0.u16 -= 0x800
		u16[A0 + 0x36] = D0.u16
	}

	fn00953e()
	DrawObject()

	A2 = 0x2908d2
	D6 = 0x28f95a
	D4.u16 = 0xfd60
	fn0091a2()
}



//# address-hook(0x009580) end(0x00972c)
function void fn009580()
{
	if (global.game_mode != 0x34)
	{
		if (bluespheres.stage_exit_animation != 0)	// We play the exit animation on returning to main menu, although we still need to get the ground palette to fade to white
		{
			if (bluespheres.stage_exit_animation <= 0x60)
			{
				// Fast rotation of the stage after collecting the emerald
				D1 = 8
				bluespheres.direction += 8
				++bluespheres.stage_exit_animation
				return
			}

			// This seems to be dead code, at least in S3AIR, as "bluespheres.stage_exit_animation" doesn't reach a value above 0x3d
			D0.u16 = (bluespheres.position.x | bluespheres.position.y) & 0xe0
			if (D0.u16 != 0)
			{
				bluespheres.stage_exit_animation = 0
			}
		}
	return
	}

	// Base function starts here, with exception of not accepting control input in Original Mode until the fade-in stops
	if (bluespheres.stage_exit_animation != 0)
	{
		if (bluespheres.stage_exit_animation <= 0x60)
		{
			// Fast rotation of the stage after collecting the emerald
			D1 = 8
			bluespheres.direction += 8
			++bluespheres.stage_exit_animation
			return
		}

		// This seems to be dead code, at least in S3AIR, as "bluespheres.stage_exit_animation" doesn't reach a value above 0x3d
		D0.u16 = (bluespheres.position.x | bluespheres.position.y) & 0xe0
		if (D0.u16 != 0)
		{
			bluespheres.stage_exit_animation = 0
		}
	}

	D3.u16 = (bluespheres.direction & 0x40) ? bluespheres.position.x : bluespheres.position.y
	D3.u16 &= 0xe0
	D2 = 0
	if (bluespheres.next_direction != 0 && D3.u16 == 0)
	{
		if ((bluespheres.jumping_flags.player1 & 0x80) == 0)
		{
			bluespheres.direction += bluespheres.next_direction
			if ((bluespheres.direction & 0x3f) != 0)
				return

			bluespheres.next_direction = 0
			if (bluespheres.movement_speed != 0)
			{
				u8[0xffffe430] = 1
			}
		}
	}
	else
	{
		if (D3.u16 != 0)
		{
			u8[0xffffe430] = 0
		}
	}

	D1.u8 = control.pad1.state
	if (original_mode && !BS_fadeFinished)
		D1.u8 = 0	// remove control input in Original Mode if the fade in has not finished
	D2.s16 = bluespheres.movement_speed
	if (bluespheres.stage_exit_state == 0)
	{
		if (bluespheres.hitting_bumper == 0)
		{
			if (D1 & CONTROL_UP)
			{
				bluespheres.going_forward = 1
				bluespheres.started_running = 1
			}

			// Acceleration / deceleration
			if (bluespheres.going_forward)
			{
				bluespheres.movement_speed = min(bluespheres.movement_speed + 0x200, s16(bluespheres.current_gamespeed))
			}
			else if (bluespheres.started_running)
			{
				if (bluespheres.movement_speed < 0)
				{
					bluespheres.movement_speed = max(bluespheres.movement_speed - 0x200, -s16(bluespheres.current_gamespeed))
				}
				else
				{
					bluespheres.movement_speed = min(bluespheres.movement_speed + 0x200, s16(bluespheres.current_gamespeed))
				}
			}
			D2.s16 = bluespheres.movement_speed
		}

		if (u8[0xffffe430] == 0)
		{
			if (D1 & CONTROL_LEFT)
			{
				bluespheres.next_direction = 4
			}
			if (D1 & CONTROL_RIGHT)
			{
				bluespheres.next_direction = -4
			}
		}

		if (bluespheres.hitting_bumper != 0)
		{
			D0.u16 = (bluespheres.direction & 0x40) ? bluespheres.position.x : bluespheres.position.y
			if ((D0.u16 & 0xe0) == 0)
			{
				D0.u16 = ((bluespheres.position.x + 0x80) >> 8) & 0x1f
				D1.u16 = ((bluespheres.position.y + 0x80) >> 8) & 0x1f
				D1.u16 = (D1.u16 << 5) | D0.u16
				if (D1.u16 != u16[0xffffe44e])
				{
					bluespheres.hitting_bumper = 0
					bluespheres.movement_speed = (bluespheres.movement_speed >= 0) ? -bluespheres.current_gamespeed : bluespheres.current_gamespeed
					return
				}
			}

			if (bluespheres.movement_speed == 0)
			{
				bluespheres.hitting_bumper = 0
				bluespheres.going_forward = 1
				bluespheres.movement_speed = (bluespheres.movement_speed >= 0) ? -bluespheres.current_gamespeed : bluespheres.current_gamespeed
			}
			else
			{
				D2.s16 = -D2.s16
			}
		}
	}

	if (bluespheres.jumping_flags.player1 == 0x81)
	{
		D2.s16 *= 2
	}

	D0.u8 = bluespheres.direction
	LookupSinCos()
	D0.s32 = s32(D0.s16) * D2.s16
	D1.s32 = s32(D1.s16) * D2.s16
	bluespheres.position.x -= D0 >> 16
	bluespheres.position.y -= D1 >> 16

	if ((bluespheres.jumping_flags.player1 & 0x80) == 0 && bluespheres.stage_exit_state == 0)
	{
		fn00972e()
	}
}



// Handle what happens when green spheres are touched.
// Also sets the continue and 100-ring sounds to not play in Special Stage Time Attack.
//# address-hook(0x00972e) end(0x0098ae)
function void fn00972e()
{
	A1 = 0xfffff100
	D0.u16 = ((bluespheres.position.x + 0x80) >> 8) & 0x1f
	D1.u16 = ((bluespheres.position.y + 0x80) >> 8) & 0x1f
	D1.u16 <<= 5
	D1.u8 |= D0.u8
	A1 += D1.s16
	D2.u8 = u8[A1]

	if (D2.u8 == 1)
	{
		// Ran into red sphere
		D0.u16 = (bluespheres.position.x | bluespheres.position.y) & 0xe0
		if (D0.u16 == 0 && bluespheres.stage_exit_animation == 0)
		{
			// Game over
			bluespheres.stage_exit_animation = 1
			global.game_mode = (bluespheres.minigame_mode == 0) ? 0x48 : 0x2c
			if (challenge_greenspheres)
			{
				S2Special.swapRingsAndSpheres()
				bluespheres.blue_remaining = 1		// do not let the results screen believe the stage was won
			}
			if (global.stage_type != 0)
			{
				global.zone_act = level.backup.zone_act
				checkpoint.number |= 0x80
			}
			playSound(0x6a)
		}
	}
	else if (D2.u8 == 2)
	{
		// Approaching blue sphere
		fn009dca()
		if (_equal())
		{
			u8[A2] = 2
			u32[A2 + 0x04] = A1
		}
		playSound(0x65)
	}
	else if (D2.u8 == 3)
	{
		// Running into bumper
		if (u8[0xffffe42b] == 0)
		{
			u16[0xffffe44e] = D1.u16
			u8[0xffffe42b] = 1
			bluespheres.going_forward = 0
			playSound(0xaa)
		}
	}
	else if (D2.u8 == 4)
	{
		// Collecting ring
		//  -> Gets collected already when approaching the position
		fn009dca()
		if (_equal())
		{
			u8[A2] = 1
			u32[A2 + 0x04] = A1
		}

		if (bluespheres.rings_remaining != 0)
		{
			--bluespheres.rings_remaining
			if (bluespheres.rings_remaining == 0)
			{
				playMusic(0x68)
			}
		}

		++bluespheres.rings_collected
		if (challenge_greenspheres)
		{
			if (bluespheres.rings_collected == S2Special.RingTargets[challenge_greenspheres * 3 - 3])
			{
				bluespheres.current_gamespeed = 0x1000
				BS_remainingTime += S2Special.BonusTime[challenge_greenspheres * 3 - 2] * 60
				showTimeGainTarget = 180
				playSound(0x63)
			}
			else if (bluespheres.rings_collected == S2Special.RingTargets[challenge_greenspheres * 3 - 2])
			{
				bluespheres.current_gamespeed = 0x1000
				BS_remainingTime += S2Special.BonusTime[challenge_greenspheres * 3 - 1] * 60
				showTimeGainTarget = 180
				playSound(0x63)
			}
			else if (bluespheres.rings_collected == S2Special.RingTargets[challenge_greenspheres * 3 - 1])
			{
				bluespheres.stage_exit_state = 1
			}
		}
		bluespheres.rings_flags |= 0x80

		u8 soundId = 0x33
		if (bluespheres.minigame_mode == 0)
		{
			if (bluespheres.rings_collected >= 50 && !challenge_greenspheres && (bluespheres.rings_flags & 0x01) == 0)
			{
				bluespheres.rings_flags |= 0x01
				++continues_counter
				playMusic(0xac)

			#if STANDALONE
				if (continues_counter >= 5)
				{
					Game.setAchievementComplete(ACHIEVEMENT_CONTINUES)
				}
			#endif
				return
			}

			if (bluespheres.rings_collected >= 100)
			{
				bool grantExtraLife = false
				if ((bluespheres.rings_flags & 0x02) == 0)
				{
					bluespheres.rings_flags |= 0x02
					grantExtraLife = true
				}
				else if (bluespheres.rings_collected >= 200 && (bluespheres.rings_flags & 0x04) == 0)
				{
					bluespheres.rings_flags |= 0x04
					grantExtraLife = true
				}

				if (grantExtraLife)
				{
					if (!original_mode)
					{
						if (Game.getSetting(SETTING_INFINITE_LIVES))
						{
							lives_counter = 3
						}
						else
						{
							lives_counter = min(lives_counter + 1, 99)

							// Extra life jingle, with less channels to sound like a sound effect
							u64 soundKey = "sfx_sklife"
							if (unlock_act || challenge_greenspheres)
							{
								soundKey = "sfx_s2life"
							}
							else if (Game.getSetting(SETTING_AUDIO_EXTRALIFE_JINGLE) == 0 && !original_mode)
							{
								soundKey = "sfx_s3life"
							}
							else if (Game.getSetting(SETTING_AUDIO_EXTRALIFE_JINGLE) == 0x10 && !original_mode)
							{
								if (!isSonicAndKnucklesZone())
									soundKey = "sfx_s3life"
							}
							Audio.playAudio(soundKey, AudioContext.CONTEXT_SOUND)
						}
					}
					else
					{
						++lives_counter
						soundId = 0xb9
					}
				}
			}
		}

		playSound(soundId)
	}
	else if (D2.u8 == 5)
	{
		// Yellow spring sphere
		if (bluespheres.stage_exit_state == 0 && (u8[0xffffe432] & 0x80) == 0)
		{
			D0.u8 = bluespheres.direction & 0x3f
			if (D0.u8 == 0)
			{
				u32[A0 + 0x40] = 0xffe80000
				u8[0xffffe432] = 0x81
				playSound(0xb1)
			}
		}
	}
	else if (D2.u8 == 0x0e)	// new section
	{
		// Green sphere
		fn009dca()	// function that determines collision response
		if (_equal())
		{
			u8[A2] = 3
			u16[A2 + 0x02] = D1.u16
			u32[A2 + 0x04] = A1
		}
		playSound(0x65)	// blue sphere sound
		BS_remainingTime += 30
		showTimeGain = 30
	}
}


constant array<u16> S2Special.RingTargets =
{
	20, 40, 65,		// S2 Special C-1
	25, 50, 70,		// S2 Special C-2
	25, 50, 80,		// S2 Special C-3
	20, 40, 60,		// S2 Special C-4
	40, 80, 130,	// S2 Special C-5
	20, 40, 60,		// S2 Special C-6
	40, 80, 120,	// S2 Special C-7
	25, 50, 75,		// S2 Special C-Bonus
	30, 70, 100,	// S2 Special S-1
	40, 75, 110,	// S2 Special S-2
	25, 50, 85,		// S2 Special S-3
	40, 80, 120,	// S2 Special S-4
	40, 70, 100,	// S2 Special S-5
	25, 55, 85,		// S2 Special S-6
	50, 100, 150,	// S2 Special S-7
	30, 50, 70,		// S2 Special S-Bonus
	45, 90, 135,	// S2 Special C-1 Hard
	20, 40, 55,		// S2 Special C-2 Hard
	40, 80, 120,	// S2 Special C-3 Hard
	15, 35, 50,		// S2 Special C-4 Hard
	50, 100, 140,	// S2 Special C-5 Hard
	10, 25, 35,		// S2 Special C-6 Hard
	20, 40, 60,		// S2 Special C-7 Hard
	70, 140, 210,	// S2 Special C-Bonus Hard
	15, 30, 45,		// S2 Special S-1 Hard
	10, 25, 45,		// S2 Special S-2 Hard
	20, 35, 55,		// S2 Special S-3 Hard
	25, 50, 75,		// S2 Special S-4 Hard
	15, 30, 45,		// S2 Special S-5 Hard
	10, 30, 50,		// S2 Special S-6 Hard
	15, 35, 50,		// S2 Special S-7 Hard
	50, 100, 140	// S2 Special S-Bonus Hard
}

constant array<u8> S2Special.BonusTime = 
{
	25, 20, 15,		// S2 Special C-1
	25, 10, 10,		// S2 Special C-2
	30, 15, 15,		// S2 Special C-3
	25, 10, 10,		// S2 Special C-4
	20, 15, 15,		// S2 Special C-5
	10, 10, 10,		// S2 Special C-6
	15, 10, 10,		// S2 Special C-7
	25, 20, 15,		// S2 Special C-Bonus
	15, 15, 10,		// S2 Special S-1
	20, 10, 10,		// S2 Special S-2
	20, 15, 15,		// S2 Special S-3
	30, 20, 15,		// S2 Special S-4
	20, 10, 10,		// S2 Special S-5
	20, 15, 10,		// S2 Special S-6
	15, 10, 10,		// S2 Special S-7
	20, 10, 10,		// S2 Special S-Bonus
	15, 15, 10,		// S2 Special C-1 Hard
	10, 10, 10,		// S2 Special C-2 Hard
	15, 15, 15,		// S2 Special C-3 Hard
	20, 15, 10,		// S2 Special C-4 Hard
	20, 15, 15,		// S2 Special C-5 Hard
	15, 10, 10,		// S2 Special C-6 Hard
	15, 15, 10,		// S2 Special C-7 Hard
	10, 10, 10,		// S2 Special C-Bonus Hard
	25, 20, 15,		// S2 Special S-1 Hard
	20, 15, 15,		// S2 Special S-2 Hard
	10, 15, 15,		// S2 Special S-3 Hard
	20, 15, 10,		// S2 Special S-4 Hard
	10, 10, 10,		// S2 Special S-5 Hard
	20, 15, 15,		// S2 Special S-6 Hard
	20, 15, 15,		// S2 Special S-7 Hard
	20, 15, 15		// S2 Special S-Bonus Hard
}



// Set a new collision response for green spheres
//# address-hook(0x009dde) end(0x009dfa)
function void fn009dde()
{
	A0 = 0xffffa400
	D7.u16 = 0x1f
	while (D7.s16 >= 0)
	{
		D0 = u8[A0]
		if (D0.u8 == 3)		// new: if green sphere ID,
			TouchGreenSphere()	// branch to new code
		else if (D0.u8 != 0)
		{
			D0.u16 *= 4
			A1 = u32[0x009df8 + D0.s16]
			call A1
		}

		A0 += 8
		--D7.s16
	}
}



// New function to handle touching green spheres
function void TouchGreenSphere()
{
	A1 = u32[A0 + 0x04]
	if (u8[A1] == 0x04)	// did this already become a ring?
	{
		u32[A0] = 0
		u32[A0+4] = 0
		return
	}
	if (u8[A1] != 0x0c)
	{
		if (u8[A1] == 0x0a)
		{
			TouchGreenSphere_CheckPlayerMoved()
			return
		}
		u8[A1] = 0x0c
		u8[A0 + 0x01] = 3	// usually 9; this is a buffer before the sphere changes	// 3 seems to be the most workable value
	}
	else
	{
		u8[A0 + 0x01] -= 1
		if (u8[A0 + 0x01] > 0)
		{
			TouchGreenSphere_CheckPlayerMoved()
			return
		}
		// We ignore the test to make a dummy blue sphere, instead choosing to use a short buffer (see above) and rely on moving off the square and specific sphere-to-ring checks to cover for it.
//		D0.u16 = (bluespheres.position.x | bluespheres.position.y) & 0xf0 	// does not seem accurate enough with the variable speeds/positions in Sonic 2 stages
//		if (D0.u16 == 0)	// test if the fractional part of character position has any of the high four bits set
//		{
//			u8[A1] = 0x0a	// change this object to a "dummy blue sphere"
//			TouchGreenSphere_CheckPlayerMoved()
//		}
	}
}

// New function to ensure the player leaves a green sphere turning blue before the blue sphere can become red
function void TouchGreenSphere_CheckPlayerMoved()
{
	D0.u16 = ((bluespheres.position.x + 0x80) >> 8) & 0x1f
	D1.u16 = ((bluespheres.position.y + 0x80) >> 8) & 0x1f

	D1.u16 <<= 5
	D1.u8 |= D0.u8
	if (u16[A0 + 0x02] != D1.u16)
	{
		u8[A1] = 2
		u32[A0] = 0
		u32[A0 + 0x04] = 0
	}
}


//# address-hook(0x009e88) end(0x009e9e)
function void BlueSpheres.OnBlueSphereCollected()
{
	if (!bluespheres.blue_remaining)
		return

	bluespheres.bs_hud_dirty = 0xff
	--bluespheres.blue_remaining
	bluespheres.blue_collected++
	BS_remainingTime += 30
	showTimeGain = 30

	// Tie continues to spheres in Sonic 2 special stages instead of to rings. We need at least half of the total spheres for a continue.
	u16 continueSpheres = (bluespheres.blue_total & 0x01) ? (bluespheres.blue_total + 1)/2 : bluespheres.blue_total/2
	if (bluespheres.blue_collected >= continueSpheres && challenge_greenspheres && (bluespheres.rings_flags & 0x01) == 0)
	{
		bluespheres.rings_flags |= 0x01
		++continues_counter
		if (bluespheres.blue_remaining == 0)
			Standalone.playAudio(0x68)	// Should not use playMusic(ID) for this, as it affects D0 and that must be preserved for sphere-to-ring conversions. playMusic simply calls Standalone.playAudio(ID) anyway.
		else
			Standalone.playAudio(0xac)	// Same as above.

	#if STANDALONE
		if (continues_counter >= 5)
		{
			Game.setAchievementComplete(ACHIEVEMENT_CONTINUES)
		}
	#endif
		return
	}

	if (bluespheres.blue_remaining == 0 && !challenge_greenspheres)
	{
		bluespheres.stage_exit_state = 1
		if (bluespheres.hitting_bumper != 0)
		{
			bluespheres.hitting_bumper = 0
			bluespheres.movement_speed = (bluespheres.movement_speed >= 0) ? -bluespheres.current_gamespeed : bluespheres.current_gamespeed
			return
		}
	}
	else if (bluespheres.blue_remaining == 0)
	{
		Standalone.playAudio(0x68)	// Same as above.
	}
}


// Add green spheres to the blue sphere count
//# address-hook(0x009ea0) end(0x009eba)
function void fn009ea0()
{
#if STANDALONE
	if (CHEAT_ONE_BLUE_SPHERE)
	{
		bluespheres.blue_remaining = 1
		return
	}
#endif

	// Count the number of blue spheres and green spheres
	A3 = 0xfffff100
	D1 = 0
	D0.u16 = 0x03ff
	while (D0.s16 >= 0)
	{
		if (u8[A3] == 2)
		{
			++D1.u16
		}
		if (u8[A3] == 0x0e) // green sphere ID
		{
			++D1.u16
		}
		++A3
		--D0.s16
	}
	bluespheres.blue_remaining = D1.u16
	bluespheres.blue_total = bluespheres.blue_remaining
}





//# address-hook(0x009ebc) end(0x009f42)
function void fn009ebc()
{
	// This function creates rings from a region of spheres (when all border spheres got turned red)

	_setZeroFlagByValue(0)	// Default result

	// A1 is the address of the currently collected blue sphere
	A2 = 0xfffff100		// Pointer to level layout, will stay at this address this whole function
	D5 = A1 - A2		// Position of the currently collected blue sphere (D5 = x + y * 0x20)
	fn009f44()

	D6 = 0
	A4 = 0xffffa500
	D1 = A5 - A4
	if (D1 == 0)
		return

	// Convert region to rings
	//  -> The words between A4 (inclusive) and A5 (exclusive) are the positions of encapsulated blue spheres
	//  -> Each one of these will make its 8 neighbors turn into rings, if they are blue or red spheres

	while (D1.u16 > 0)
	{
		D5.u16 = u16[A4]
		A4 += 2

		// Have a look at the eight neighboring positions
		A3 = 0x00a0ca		// Values stored here as s16: -0x21, -0x20, -0x1f, -0x01, 0x01, 0x01f, 0x20, 0x21
		for (u8 i = 0; i < 8; ++i)
		{
			D2.u16 = (D5.u16 + s16[A3]) & 0x03ff
			A3 += 2
			if (u8[A2 + D2.u16] == 0x02 || u8[A2 + D2.u16] == 0x0c)	// Blue sphere or a sphere changing from green to blue? // || (u8[A2 + D2.u16] == 0x0e && u8[A2 + D2.u16 - 3] > 0)
			{
				BlueSpheres.OnBlueSphereCollected()

				// Make it a ring
				u8[A2 + D2.u16] = 0x04

				// Enqueue this position to the end of the list, so its neighbors get converted as well
				//  -> This mechanism makes this essentially a flood-fill algorithm
				u16[A5] = D2.u16
				A5 += 2
				D1.u16 += 2
			}
		}
		D1.u16 -= 2
	}

	A4 = 0xffffa500
	D1 = A5 - A4
	if (D1 == 0)	// Can this condition ever be true? A5 is definitely larger than A4 here
		return

	while (D1.u16 > 0)
	{
		D5.u16 = u16[A4]
		A4 += 2

		// Have a look at the eight neighboring positions
		A3 = 0x00a0ca
		for (u8 i = 0; i < 8; ++i)
		{
			D2.u16 = (u16[A3] + D5.u16) & 0x03ff
			A3 += 2
			if (u8[A2 + D2.u16] == 0x01)	// Red sphere?
			{
				// Make it a ring
				u8[A2 + D2.u16] = 0x04
			}
		}
		D1.u16 -= 2
	}

	playSound(0xb9)
	D1 = 1
	_setZeroFlagByValue(1)
}


//# address-hook(0x009f44) end(0x00a0c8)
function void fn009f44()
{
	A5 = 0xffffa500		// Pointer to end of output list, initially empty, will hold positions of all blue spheres turned into rings when returning

	// Look at the neighboring 8 positions
	//  -> D5 is the position of the currently collected blue sphere
	{
		A3 = 0x00a0ca		// Pointer to 8 hard-coded relative offsets of neighbors
		u8 counter = 0
		for (u8 i = 0; i < 8; ++i)
		{
			D1.u16 = (D5.u16 + s16[A3]) & 0x03ff
			A3 += 2
			if (u8[A2 + D1.u16] == 0x0a)		// Is this the blue sphere that gets collected right now?
			{
				// Turn into a red sphere
				//  -> This seems to be dead code?
				u8[A2 + D1.u16] = 0x01
			}
			else if (u8[A2 + D1.u16] == 0x02 || u8[A2 + D1.u16] == 0x0c)	// Is this a different blue sphere?
			{
				++counter
			}
		}

		// This is the number of blue spheres around, there must be at least 1 to proceed
		if (counter == 0)
			return
	}

	// Count the number of non-empty positions in a straight line along negative and positive x direction
	//  -> Note that this (somewhat unnecessarily) also counts the current position, and even counts it twice
	{
		u8 counter = 0
		D1.u16 = D5.u16
		for (u8 i = 0; i < 0x10; ++i)
		{
			++counter
			--D1.u16
			if (u8[A2 + D1.u16] == 0)
				break
		}
		D1.u16 = D5.u16
		for (u8 i = 0; i < 0x10; ++i)
		{
			++counter
			++D1.u16
			if (u8[A2 + D1.u16] == 0)
				break
		}

		// To proceed, there must be at least 3 non-empty positions next to each other (comparing to 4 because we counted current position twice)
		if (counter < 4)
			return
	}

	// Same as above, but now in y direction
	{
		u8 counter = 0
		D1.u16 = D5.u16
		for (u8 i = 0; i < 0x10; ++i)
		{
			++counter
			D1.u16 -= 0x20
			if (u8[A2 + D1.u16] == 0)
				break
		}
		D1.u16 = D5.u16
		for (u8 i = 0; i < 0x10; ++i)
		{
			++counter
			D1.u16 += 0x20
			if (u8[A2 + D1.u16] == 0)
				break
		}

		if (counter < 4)
			return
	}

	A4 = 0xffffa600		// Buffer for temporary use as a stack, we store data about positions that get marked in the following algorithm
	u8 stackSize = 0	// Counts number of entries on the stack (see A4)

	// Current state (in addition to states saved on the stack) consists of these three variables:
	D3 = 0x00			// Offset of a direction in A4, can have values 0x00, 0x02, ..., 0x0a
	D4 = 0x06			// Offset of a different direction in A4, usually in right angle to D3
	D0.u16 = D5.u16		// This is still the position of the currently collected blue sphere

	while (true)
	{
		// Look at one of the 4 direct neighbor positions to the current position
		//  -> At 0x00a0da, the following s16 values are stored: -0x01, -0x20, 0x01, 0x20, -0x01, -0x20
		D1.u16 = (D0.u16 + s16[0x00a0da + D4.u16]) & 0x03ff
		u8 neighborType = u8[A2 + D1.u16]

		if (neighborType == 0x01)
		{
			// Neighbor is a red sphere that is not yet marked
			bool accepted = true
			if (stackSize >= 2)		// If we got at most one entry on the stack so far, go on without further checks
			{
				// I guess this way, we will ignore circles of 2 * 2 red spheres
				u16 diff = abs(D1.u16 - u16[A4 - 0x06])
				accepted = (diff != 0x01 && diff != 0x20)
			}

			if (accepted)
			{
			#if STANDALONE
				// Check whether there's at least one blue sphere near this red sphere
				//  -> This is done to avoid the issue that D.A. Garden describes here: https://www.youtube.com/watch?v=e1gfYFq8KkM
				// This also removes a bug that could cause the original game to make rings when it shouldn't...
				// ...so naturally we reintroduce that bug in Original Mode.
				accepted = false
				for (u8 i = 0; i < 8; ++i)
				{
					u16 position = (D0.u16 + s16[0x00a0ca + i * 2]) & 0x03ff
					if (u8[A2 + position] == 0x02 || u8[A2 + position] == 0x0c)		// Accept blue spheres only
					{
						accepted = true
						break
					}
				}
				if (accepted || original_mode)
			#endif
				{
					// Temporarily mark this position; the mark tells us whether the position is on the stack already
					u8[A2 + D0.u16] |= 0x80

					// Add an entry to the stack
					u8[A4]    = D3.u8
					u8[A4+1]  = D4.u8
					u16[A4+2] = D0.u16
					A4 += 4
					++stackSize

					// Continue at the neighbor, and create a new state to check:
					//  - Starting at the neighbor's position
					//  - Checking all direction except where we just came from
					D0.u16 = D1.u16
					D3.u16 = (D4.u16 - 2) & 0x06	// Limit direction = direction change relative to current direction by 90
					D4.u16 = D3.u16 + 4				// Current direction = opposite of new limit direction
					continue
				}
			}
		}
		else if (neighborType == 0x8a)
		{
			// Reached the currently collected blue sphere again
			push(A4)
			push(D4)
			push(D3)
			push(D0)

			// Go through the entire stack (except for the entry at the very bottom, which represents the start position)
			D4.u16 = D5.u16 - D0.u16
			A4 = 0xffffa600 + 0x06
			D2.u16 = u16[A4] - D5.u16
			D3.u16 = D5.u16

			// Find first direction change in the stack
			while (true)
			{
				D0.u16 = u16[A4] - D3.u16
				A4 += 4
				if (D0.u16 != D2.u16)
					break

				D3.u16 += D0.u16
			}

			if (D4.s16 == D0.s16 || D4.s16 == D2.s16)
			{
				// Step into the start position is either:
				//  - the first turn's direction (e.g. red spheres built something like the edge of an L-shape, and the start position is the inner corner)
				//  - the start direction (red spheres made a loop that enters the start position straight from behind)
				//     -> In these cases, the position in direction of first turn is expected to be a blue sphere
				D0.u16 = D5.u16 + D0.s16
			}
			else
			{
				// Step into the start position is neither of the above
				//  -> The position in diagonal direction (namely start direction + first turn) is expected to be a blue sphere
				D0.u16 = D5.u16 + D0.s16 + D2.s16
			}

			// Now check if it's really a blue sphere
			if (u8[A2 + D0.u16] == 0x02 || u8[A2 + D0.u16] == 0x0c)
			{
			#if STANDALONE
				// Perform an additional sanity check, just to be sure - and to solve an original game bug from S&K
				//  -> This is just a workaround, better fix whatever is wrong with the actual algorithm
				//  -> I suppose the real bug is that D0.u16 is not necessarily the right position to check, it can be on the wrong side;
				//      considering whether the red sphere ring is CW or CCW and using that info to decide on where to put D0.u16 could do the trick
				//  -> In fact, with the following fix that bug is really rare, it only can (but still does) happen when traversing a very large region
				//      of blue spheres in just the right way
				bool accepted = true
				if (Game.getSetting(SETTING_FIX_GLITCHES) && !original_mode)
				{
					for (u8 i = 0; i < 8; ++i)
					{
						u16 position = (D0.u16 + s16[0x00a0ca + i * 2]) & 0x03ff
						if (u8[A2 + position] == 0)
						{
							accepted = false
							break
						}
					}
				}
				if (accepted)
			#endif
				{
					BlueSpheres.OnBlueSphereCollected()

					// Make it a ring
					u8[A2 + D0.u16] = 0x04

					// Store position in the output list
					u16[A5] = D0.u16
					A5 += 2
				}
			}

			D0 = pop()
			D3 = pop()
			D4 = pop()
			A4 = pop()
		}

		// Reached a position where it's no use to go on, because there's neither a (not yet visited) red sphere nor the currently collected blue sphere; proceed by either:
		//  - Rotating current direction by 90 and check this one; i.e. do not enter the next while loop at all
		//  - If all directions got checked for the current position, take the next entry from the stack and continue with it (possibly multiple times if all directions of the top-of-stack already got checked, too)
		//  - In case the stack is empty, we're done with all checks
		D4.u16 -= 2
		while (D4.s16 < D3.s16)
		{
			// We're done if stack is empty
			if (stackSize == 0)
				return

			// Pop topmost entry from the stack
			A4 -= 4
			--stackSize
			D3     = u8[A4]
			D4     = u8[A4+1]
			D0.u16 = u16[A4+2]

			u8[A2 + D0.u16] &= 0x7f		// Remove mark again
			D4.u16 -= 2
		}
	}
}







// Make green spheres translucent when touched, as AIR does for blue spheres.
// Add 46 to sphere position for new screen size
// We also manage the HUD display for time attack here, as the function is called every frame in special stages.
// Taken from \scripts\general\bluesphere\bluespheres.lemon
function void BlueSpheres.renderCustomSpheres()
{
	if (original_mode && bluespheres.lifted_height == 0)	// The original code is bugged to not draw lifted spheres without custom rendering, unfortunately.
	{
		// This is a copy of the portion of BlueSpheres.RenderSpheres() that is called only if NOT the GAMEAPP.

		// Usual case is A0 = 0x009af4, except after all blue spheres got collected
		A0 = (bluespheres.lifted_height == 0) ? 0x009af4 : 0x009b18

		D5.u16 = (u16[A5 + 0x02] + D1.u16) & u16[A5 + 0x0a]
		D0.u16 = u16[0xffffe420] * 4
		A1 = u32[0xffff0000 + D0.u16]		// Pointer to lookup table for sphere positions and distances
		D6.u16 = u16(u8[0xfffff62c]) * 8
		D7 = 0x4f - u8[0xfffff62c]
		A6 = 0xfffff800 + D6.u16
		D2 = 0x0f

		bool directionFlag = ((bluespheres.direction & 0x40) == 0)
		while (D2.s16 >= 0)
		{
			D0 = (directionFlag ? bluespheres.position.x : bluespheres.position.y) >> 8
			D4.u16 = (u16[A5] + D0.u16) & u16[A5 + 0x06]
			D3 = 0x0e

			while (D3.s16 >= 0)
			{
				// Distance values are around [0x18, 0x57]
				u16 distance = u16[A1]

				if (directionFlag)
					D0.u16 = (D5.u16 << 5) | D4.u8
				else
					D0.u16 = (D4.u16 << 5) | D5.u8

				// Sphere types:
				//  - 0x00 = none / empty
				//  - 0x01 = red sphere
				//  - 0x02 = blue sphere
				//  - 0x03 = bumper sphere
				//  - 0x04 = ring
				//  - 0x05 = yellow sphere
				//  - 0x06 = ring (collected, part 1)
				//  - 0x07 = ring (collected, part 2)
				//  - 0x08 = ring (collected, part 3)
				//  - 0x09 = ring (collected, part 4)
				//  - 0x0a = blue sphere (during collection)
				//  - 0x0b = Chaos Emerald
				u8 sphereType = u8[0xfffff100 + D0.s16]

				D1.u16 = distance & 0x7c
				if (sphereType != 0 && D1.u16 != 0)
				{
					u16 size = (D1.u16 >> 2) - 6
					if (size < 0x10)		// Filter out what's too small, i.e. completely behind the horizon
					{
						D0.u16 = u8(sphereType) * 8
						A3 = u32[0xffffe480 + D0.s16]
						D6.u16 = u16[0xffffe480 + D0.s16 + 4]
						if (distance >= 0x54)	// Draw as non-priority sprite if partly behind the horizon
						{
							D6.u16 &= 0x7fff
						}

						D0.u16 = u16[0xffffe480 + D0.s16 + 6]
						D1 = (D0.u16 & 0x8000) ? 0 : size
						D1.u16 += (D0.u16 & 0x7fff)
						A3 += u16[A3 + D1.s16 * 2]

						// A3 = Pointer to sprite data
						D1.u16 = u16[A3] - 1
						A3 += 2
						if (D1.s16 >= 0)
						{
							call A0		// One of "BlueSpheres.RenderSingleSphere*"
							if (D7.s16 < 0)
								return
						}
					}
				}

				A1 += 6
				D4.u16 = (D4.u16 + u16[A5 + 0x04]) & u16[A5 + 0x06]
				--D3.s16
			}

			D5.u16 = (D5.u16 + u16[A5 + 0x08]) & u16[A5 + 0x0a]
			--D2.s16
		}

	return
	}

	// From here on is AIR's custom sphere rendering.
/*
	// Add timer HUD here.
	u16 px_hud = getScreenWidth() / 2 - 14	// subtract 49 instead for non-small digits without TIME/BEST
	u16 py_hud = 14	// place the BEST time at getScreenHeight() - 14 - 16. Show either Normal or Perfect best time based on a menu option. Use 12 for non-small digits.
	u16 renderQueue_hud = 0xe800

	u16 minutes = BS_displayedTime / 3600
	u16 seconds = (BS_displayedTime - (minutes * 3600)) / 60
	u16 frames = BS_displayedTime - (minutes * 3600) - (seconds * 60)
	u16 centiseconds = (frames * 99 + 30) / 59

	// TIME and timer
	Renderer.drawCustomSprite("BlueSphere_smalltext_time", px_hud - 48, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", minutes % 10), px_hud + 5, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x11, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", seconds / 10), px_hud + 0x16, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", seconds % 10), px_hud + 0x21, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x2d, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x31, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", centiseconds / 10), px_hud + 0x35, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", centiseconds % 10), px_hud + 0x40, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)

	// BEST and best time. Right now this just shows the timer again, as best time saving/loading isn't implemented yet.
	py_hud = getScreenHeight() - 14 - 16

	Renderer.drawCustomSprite("BlueSphere_smalltext_best", px_hud - 48, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", minutes % 10), px_hud + 5, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x11, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", seconds / 10), px_hud + 0x16, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", seconds % 10), px_hud + 0x21, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x2d, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x31, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", centiseconds / 10), px_hud + 0x35, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", centiseconds % 10), px_hud + 0x40, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	// End of timer HUD code.
*/

	// Draw the HUD in Sonic 2 special stages
	if (challenge_greenspheres)
	{
		// debugLog(stringformat("%d.%02d", BS_remainingTime / 60, ((BS_remainingTime % 60) * 99 + 30) / 59))
		
		u16 renderQueue_hud = 0xe800
		u16 ringsToDisplay = (bluespheres.stage_exit_state == 4 || bluespheres.stage_exit_animation) ? bluespheres.blue_collected : bluespheres.rings_collected
		u16 spheresToDisplay = (bluespheres.stage_exit_state == 4 || bluespheres.stage_exit_animation) ? bluespheres.rings_collected : bluespheres.blue_collected

		// Draw "GET X RINGS" messages
		u16 ringTargetFirst = S2Special.RingTargets[challenge_greenspheres * 3 - 3]
		u16 ringTargetSecond = S2Special.RingTargets[challenge_greenspheres * 3 - 2]
		u16 ringTargetThird = S2Special.RingTargets[challenge_greenspheres * 3 - 1]
		u16 ringTargetCurrent = ringTargetFirst
		if (ringsToDisplay >= ringTargetSecond)
			ringTargetCurrent = ringTargetThird
		else if (ringsToDisplay >= ringTargetFirst)
			ringTargetCurrent = ringTargetSecond
		s16 px_ringtarget = getScreenWidth()/2
		s16 py_ringtarget = getScreenHeight()/2 - 8

		u16 alpha = min(u16(showTimeGainTarget) * 17 / 6, 255)	// here, 17 / 6 = 255 / 90, where 90 is half the variable's max.
		if (BS_displayedTime < 180)
			alpha = min(u16(180 - BS_displayedTime) * 17 / 6, 255)	// here, 17 / 6 = 255 / 90, where 90 is half the variable's max.
		
		if (BS_displayedTime < 180 || showTimeGainTarget)	// normal duration of GET BLUE SPHERES message not reached or the previous ring target was just reached
		{
			if (ringTargetCurrent < 100)
				Renderer.drawCustomSprite("sonic2_getXXrings", px_ringtarget, py_ringtarget, 0, SPRITE_FLAG_PRIO, renderQueue_hud, 0, alpha)	// two-digit ring target
			else
			{
				Renderer.drawCustomSprite("sonic2_getXXXrings", px_ringtarget, py_ringtarget, 0, SPRITE_FLAG_PRIO, renderQueue_hud, 0, alpha)	// three-digit ring target
				px_ringtarget += 4
			}
			for (u32 value = ringTargetCurrent;;)
			{
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d", value % 10), px_ringtarget - 11, py_ringtarget - 8, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 1, 0, alpha)
				px_ringtarget -= 8
				value /= 10
				if (value == 0)
					break
			}
		}

		// Draw the timer
		s16 px_timer = getScreenWidth() / 2
		constant u16 timer_screentop = 12
		constant u16 timer_screenbottom = 196		// getScreenHeight() of 224, minus 12 for empty space below HUD, minus 16 for height of digits
		s16 py_timer = timer_screenbottom

		u16 seconds = BS_remainingTime / 60
		u16 frames = BS_remainingTime - (seconds * 60)
		u16 centiseconds = (frames * 99 + 30) / 59

		if (seconds > 99)
		{
			seconds = 99
			centiseconds = 99
		}

		Renderer.drawCustomSprite("sonic2_timeframe", px_timer, py_timer + 6, 0, SPRITE_FLAG_PRIO, renderQueue_hud)

		// Normal digits
		Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d", seconds / 10), px_timer - 17, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
		Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d", seconds % 10), px_timer - 9, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
		Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_period", seconds % 10), px_timer - 2, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
		Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini", centiseconds / 10), px_timer + 2, py_timer + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
		Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini", centiseconds % 10), px_timer + 10, py_timer + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	
		// Sphere time bonus digits
		if (BS_remainingTime <= 600 && (level.framecounter.low & 0x08) && !bluespheres.stage_exit_state)
		{
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_red", seconds / 10), px_timer - 17, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 1)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_red", seconds % 10), px_timer - 9, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 1)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_period_red", seconds % 10), px_timer - 2, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 1)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini_red", centiseconds / 10), px_timer + 2, py_timer + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 1)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini_red", centiseconds % 10), px_timer + 10, py_timer + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 1)
		}

		// Sphere time bonus digits
		alpha = min(u16(showTimeGain) * 17, 255)	// For sphere time bonus, showTimeGain is set to 30 frames. Full alpha until half done (15), which is 255 / 17. Typecast the u8 to u16 to fit 17 * value.
		if (showTimeGain)
		{
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_teal", seconds / 10), px_timer - 17, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_teal", seconds % 10), px_timer - 9, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_period_teal", seconds % 10), px_timer - 2, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini_teal", centiseconds / 10), px_timer + 2, py_timer + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini_teal", centiseconds % 10), px_timer + 10, py_timer + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
		}

		// Ring target time bonus digits
		if (showTimeGainTarget)
		{
			alpha = min(u16(showTimeGainTarget) * 17 / 6, 255)	// here, 17 / 6 = 255 / 90, where 90 is half the variable's max.
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_green", seconds / 10), px_timer - 17, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_green", seconds % 10), px_timer - 9, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_period_green", seconds % 10), px_timer - 2, py_timer, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini_green", centiseconds / 10), px_timer + 2, py_timer + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
			Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini_green", centiseconds % 10), px_timer + 10, py_timer + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud + 2, 0, alpha)
		}

		// Draw the ring counter
		s16 px_rings = max(getScreenWidth()/2 - 100, 100) - 24
		s16 py_rings = 12
		s16 px_ringstext = px_rings - 44	// use - 68 instead of - 44 if using RINGS text instead of a ring icon

		// Renderer.drawCustomSprite("sonic2_rings", px_ringstext, py_rings, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
		Renderer.drawCustomSprite("hud_ring_s2", px_ringstext, py_rings, 0, SPRITE_FLAG_PRIO, renderQueue_hud)

		for (u32 value = ringsToDisplay;;)
		{
			if (ringsToDisplay < ringTargetThird)
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d", value % 10), px_rings - 4, py_rings, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
			else
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_yellow", value % 10), px_rings - 4, py_rings, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
			px_rings -= 8
			value /= 10
			if (value == 0)
				break
		}

		if (ringsToDisplay < ringTargetThird)
			Renderer.drawCustomSprite("sonic2_specialdigit_slash_mini", px_ringstext + 48, py_rings + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)		// use 72 instead of 48 if using RINGS text instead of a ring icon
		else
			Renderer.drawCustomSprite("sonic2_specialdigit_slash_mini_yellow", px_ringstext + 48, py_rings + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)

		px_ringtarget = px_ringstext + 71	// this aligns the rightmost digit, not the leftmost. Use 95 instead of 71 if using RINGS text instead of a ring icon
		if (ringTargetCurrent < 100)
			px_ringtarget -= 8
		for (u32 value = ringTargetCurrent;;)
		{
			if (ringsToDisplay < ringTargetThird)
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini", value % 10), px_ringtarget, py_rings + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
			else
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini_yellow", value % 10), px_ringtarget, py_rings + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)

			px_ringtarget -= 8
			value /= 10
			if (value == 0)
				break
		}

		// Draw the sphere counter
		s16 px_spheres = getScreenWidth() - px_ringstext - 15	// this aligns the rightmost digits for current and target, not the leftmost
		if (bluespheres.blue_total >= 100)
			px_spheres -= 8
		s16 px_spheresOrig = px_spheres
		s16 py_spheres = py_rings

		Renderer.drawCustomSprite("sonic2_spheresicon", px_spheresOrig - 57, py_rings, 0, SPRITE_FLAG_PRIO, renderQueue_hud)

		for (u32 value = spheresToDisplay;;)
		{
			if (spheresToDisplay < bluespheres.blue_total)
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d", value % 10), px_spheres - 17, py_spheres, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
			else
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_yellow", value % 10), px_spheres - 17, py_spheres, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
			px_spheres -= 8
			value /= 10
			if (value == 0)
				break
		}

		if (spheresToDisplay < bluespheres.blue_total)
			Renderer.drawCustomSprite("sonic2_specialdigit_slash_mini", px_spheresOrig - 9, py_rings + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
		else
			Renderer.drawCustomSprite("sonic2_specialdigit_slash_mini_yellow", px_spheresOrig - 9, py_rings + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)

		s16 px_spheretarget = px_spheresOrig + 14
		if (bluespheres.blue_total < 100)
			px_spheretarget -= 8
		for (u32 value = bluespheres.blue_total;;)
		{
			if (spheresToDisplay < bluespheres.blue_total)
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini", value % 10), px_spheretarget, py_rings + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
			else
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d_mini_yellow", value % 10), px_spheretarget, py_rings + 4, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
			px_spheretarget -= 8
			value /= 10
			if (value == 0)
				break
		}

		// Draw "XX RINGS TO GO!" warning message
		if (BS_remainingTime <= 300 && ringsToDisplay < ringTargetCurrent && (level.framecounter.low & 0x06))	// less than five seconds left, lacking rings (i.e., not finished the stage), and in the six of eight frames for display
		{
			u16 neededRings = ringTargetCurrent - ringsToDisplay
			u16 px_warning = getScreenWidth()/2 - 47	// assuming a three-digit number of rings to go when centering the message
			if (neededRings < 100)
				px_warning -= 4
			if (neededRings < 10)
				px_warning -= 4
			if (neededRings == 1)
				px_warning += 4
			u16 px_warningText = (neededRings == 1) ? px_warning + 60 : px_warning + 64

			if (neededRings == 1)
				Renderer.drawCustomSprite("sonic2_ringtogo", px_warningText, py_rings, 0, SPRITE_FLAG_PRIO, renderQueue_hud, 0, 128)
			else
				Renderer.drawCustomSprite("sonic2_ringstogo", px_warningText, py_rings, 0, SPRITE_FLAG_PRIO, renderQueue_hud, 0, 128)
			for (u32 valueWarning = neededRings;;)
			{
				Renderer.drawCustomSprite(stringformat("sonic2_specialdigit_%d", valueWarning % 10), px_warning, py_rings, 0, SPRITE_FLAG_PRIO, renderQueue_hud, 0, 128)
				px_warning -= 8
				valueWarning /= 10
				if (valueWarning == 0)
					break
			}
		}
	}
		

	Game.writeBlueSpheresData()

	u32 ptr = 0x800000
	u16 count = u16[ptr]
	ptr += 2
	for (u16 i = 0; i < count; ++i)
	{
		// Read sphere properties
		u16 px = u16[ptr] + getScreenExtend() - 40
		u16 py = u16[ptr+2] // + 46	// 46 is for new screen size
		u16 size = u16[ptr+4]

		u8 sphereType = u8[ptr+6]
		ptr += 7

		if (sphereType == 0x05)	// used for yellow sphere renderhook
			size -= 0x20

		// Size of sphere (0 = largest at 32x32, 0x0f = smallest at 8x8, the last ones include 3x 2 duplicates, which makes only 13 different sizes in total, with 2 pixels size difference between them)
		u8 form
		if (size < 0x1740)
			form = 0x0f
		else if (size < 0x18a0)
			form = 0x0e
		else if (size < 0x1a10)
			form = 0x0d
		else if (size < 0x1b90)
			form = 0x0c
		else if (size < 0x1d30)
			form = 0x0b
		else if (size < 0x1f00)
			form = 0x0a
		else if (size < 0x2100)
			form = 0x09
		else if (size < 0x2330)
			form = 0x08
		else if (size < 0x25a0)
			form = 0x07
		else if (size < 0x2960)
			form = 0x06
		else if (size < 0x2c80)
			form = 0x05
		else if (size < 0x3180)
			form = 0x04
		else if (size < 0x35c0)
			form = 0x03
		else if (size < 0x3c80)
			form = 0x02
		else if (size < 0x4500)
			form = 0x01
		else
			form = 0x00

		py -= (16 - form) * 2/3 + 1

		// Lift spheres when stage was won
		py -= bluespheres.lifted_height

		if (sphereType == 0x05)	// used for yellow sphere renderhook
			size += 0x20

		bool behindHorizon = (size < 0x1b00)

		u16 renderQueue = (behindHorizon ? 0x2000 : 0x9000) + size / 0x100
		u8 alpha = ((sphereType == 0x0a || sphereType == 0x0c) && !original_mode) ? 0xa0 : 0xff	// 0x0c check is new for green spheres
		u32 fog = clamp(s32(0x100000) / size - 0x68, 0, 0x80) * 0x010101

		D0.u16 = u8(sphereType) * 8

		if (sphereType == 0x0e)
			D0.u16 -= 0x10

		A3 = u32[0xffffe480 + D0.s16]
		D6.u16 = u16[0xffffe480 + D0.s16 + 4]

		D0.u16 = u16[0xffffe480 + D0.s16 + 6]
		D1 = (D0.u16 & 0x8000) ? 0 : (form * 2)
		D1.u16 += D0.u16 * 2
		A3 += u16[A3 + D1.s16]

		D1.u16 = u16[A3] - 1	// This is always 0, except for Super Emeralds
		A3 += 2

		while (D1.s16 >= 0)
		{
			if (sphereType == 0x05 && !original_mode)
			{
				Renderer.drawCustomSprite(stringformat("YellowSphere%x", min(form, 0x0c)), px, py, 0x00, 0, renderQueue)
				u8[0xffffef7c] = form
			}
			else if (Game.getSetting(SETTING_BS_VISUAL_STYLE) & 0x02 && !original_mode)
			{
				Renderer.drawVdpSpriteWithTint(px + u16[A3+4], py + s8[A3], u8[A3+1], u16[A3+2] + D6.u16, renderQueue, (0xffffff - fog) + (u32(alpha) << 24), fog)
			}
			else
			{
				Renderer.drawVdpSprite(px + u16[A3+4], py + s8[A3], u8[A3+1], u16[A3+2] + D6.u16, renderQueue)
			}
			A3 += 6
			--D1.s16
		}
	}
}




function void BlueSpheres.renderCustomGround()
{
	if (original_mode)
		return

	u32 tint = 0xffffffff

	// Check the ROM location of the palette, which is written to 0xffffe446, to determine how to tint the horizon
	if (palette_set >= 2)
	{
		if (u32[0xffffe446] == 0x2d420c)		// S3 Stage 1
			tint = 0xffffffff
		else if (u32[0xffffe446] == 0x2d4232)	// S3 Stage 2
			tint = 0xff8080ff
		else if (u32[0xffffe446] == 0x2d4258)	// S3 Stage 3
			tint = 0xffff80e0
		else if (u32[0xffffe446] == 0x2d427e)	// S3 Stage 4
			tint = 0xa0c0ffff
		else if (u32[0xffffe446] == 0x2d42a4)	// S3 Stage 5
			tint = 0xffffa0a0
		else if (u32[0xffffe446] == 0x2d42ca)	// S3 Stage 6
			tint = 0xffe0ffe0
		else if (u32[0xffffe446] == 0x2d42f0)	// S3 Stage 7
			tint = 0xff6060ff
		else if (u32[0xffffe446] == 0x2d4316)	// S3 Stage Bonus
			tint = 0xff7070ff
		else if (u32[0xffffe446] == 0x2d433c)	// S&K Stage 1
			tint = 0xffffc0ff
		else if (u32[0xffffe446] == 0x2d4362)	// S&K Stage 2
			tint = 0xfff0e0ff
		else if (u32[0xffffe446] == 0x2d4388)	// S&K Stage 3
			tint = 0xfff0c0ff
		else if (u32[0xffffe446] == 0x2d43ae)	// S&K Stage 4
			tint = 0xffff80c0
		else if (u32[0xffffe446] == 0x2d43d4)	// S&K Stage 5
			tint = 0xffffc0a0
		else if (u32[0xffffe446] == 0x2d43fa)	// S&K Stage 6
			tint = 0xff7090ff
		else if (u32[0xffffe446] == 0x2d4420)	// S&K Stage 7
			tint = 0x80d0a080
		else if (u32[0xffffe446] == 0x2d4446)	// S&K Stage Bonus
			tint = 0xf0ff6080
/*
		else if (u32[0xffffe446] == 0x2d5384)	// S2 Stage C-1
			tint = 0xff2080c0
		else if (u32[0xffffe446] == 0x2d53aa)	// S2 Stage C-2
			tint = 0xff2080c0
		else if (u32[0xffffe446] == 0x2d53d0)	// S2 Stage C-3
			tint = 0xff2080c0
		else if (u32[0xffffe446] == 0x2d53f6)	// S2 Stage C-4
			tint = 0xff2080c0
		else if (u32[0xffffe446] == 0x2d541c)	// S2 Stage C-5
			tint = 0xff00a020
		else if (u32[0xffffe446] == 0x2d5442)	// S2 Stage C-6
			tint = 0xff2080c0
		else if (u32[0xffffe446] == 0x2d5468)	// S2 Stage C-7
			tint = 0xff8080a0
		else if (u32[0xffffe446] == 0x2d548e)	// S2 Stage Bonus
			tint = 0xffc020c0
*/
	}

	BlueSpheres.replacePlaneRendering()

	// Render glow effect for background
	if (Game.getSetting(SETTING_BS_VISUAL_STYLE) & 0x02)
	{
		Renderer.drawCustomSprite("bluespheres_glow_background", getScreenWidth() / 2, 20, 0x00, 0, 0x2000, 0, tint, 0x10000)
	}

	// Render our own version of the ground
	//  -> This only works in combination with a palette set in V-Int, see "fn000c50"
	string spriteKey1
	string spriteKey2
	{
		Game.setupBlueSpheresGroundSprites()

		u16 px = bluespheres.position.x
		u16 py = bluespheres.position.y
		u8 rotation = bluespheres.direction
		bool isRotating = (rotation & 0x3f) != 0
		if (isRotating || (rotation & 0x40) == 0)
			px = (px + 0x80) & 0xff00
		if (isRotating || (rotation & 0x40) != 0)
			py = (py + 0x80) & 0xff00

		if (isRotating)
		{
			u8 rotationStep = (rotation & 0x3f) / 4
			spriteKey1 = stringformat("bluespheres_ground_alpha_rotation_0x%02x", rotationStep)
			spriteKey2 = stringformat("bluespheres_ground_opaque_rotation_0x%02x", rotationStep)
		}
		else
		{
			u8 movementStep = 0
			if ((rotation & 0x80) == 0)
			{
				movementStep = (0xff - ((rotation & 0x40) ? px : py) & 0xff) / 8
			}
			else
			{
				movementStep = (((rotation & 0x40) ? px : py) & 0xff) / 8
			}
			spriteKey1 = stringformat("bluespheres_ground_alpha_movement_0x%02x", movementStep)
			spriteKey2 = stringformat("bluespheres_ground_opaque_movement_0x%02x", movementStep)
		}
	}
	Renderer.drawSprite(spriteKey1, 0, 0, 0x100, 0, 0x3000)
	Renderer.drawSprite(spriteKey2, 0, 0, 0x100, SPRITE_FLAG_FULLY_OPAQUE, 0x3000)		// Draw fully opaque (here meant only as a rendering optimization, primarily for software renderer)

	// Render glow effect on top
	if (Game.getSetting(SETTING_BS_VISUAL_STYLE) & 0x02)
	{
		Renderer.drawCustomSprite("bluespheres_glow_foreground", getScreenWidth() / 2, 30, 0x00, 0, 0x3100, 0, tint, 0x10000)
	}
}

// From 6 Aug 2023 AIR commit 6a4b5dc
function void BlueSpheres.replacePlaneRendering()
{
	// Disable rendering of plane B prio
	Renderer.enableDefaultPlane(3, false)

	// Manually render the HUD parts of this plane (blue spheres and rings counter)
	if (!challenge_greenspheres)
	{
		Renderer.setupPlane(0, 0, 160, 32, 0x11, 3, 0x2f00)		// 0, 0, 160 in older versions of AIR and 0, 0, 120 in new versions
		Renderer.setupPlane(getScreenWidth()-160, 0, 160, 32, 0x11, 3, 0x2f00)	// -160, 0, 160 in older versions of AIR and -120, 0, -120 in new versions.
	}
}



function void BlueSpheres.renderCustomCharacterShadows()
{
	if ((Game.getSetting(SETTING_BS_VISUAL_STYLE) & 0x02) && !original_mode)
	{
		Renderer.drawSprite((getNumPlayers() < 2 || bluespheres.minigame_mode) ? "bluespheres_shadow_1P_smooth" : "bluespheres_shadow_2P_smooth", 143 + getScreenExtend(), 149, 0x00, 0, 0x3100)
	}
	else
	{	// renderQueue value here changed from 0x3100 to 0x4001 since S3&K ground rendering is Plane 1 Prio at 0x4000
		Renderer.drawSprite((getNumPlayers() < 2 || bluespheres.minigame_mode) ? "bluespheres_shadow_1P_pixel" : "bluespheres_shadow_2P_pixel", 143 + getScreenExtend(), 149, 0x00, 0x40, 0x4001)
	}
}

function void S2Special.swapRingsAndSpheres()
{
	// Swap the rings and spheres counts to represent their normal meanings
	u16 swap = bluespheres.rings_remaining
	bluespheres.rings_remaining = bluespheres.blue_remaining
	bluespheres.blue_remaining = swap

	swap = bluespheres.rings_collected
	bluespheres.rings_collected = bluespheres.blue_collected
	bluespheres.blue_collected = swap
}


// In marathon mode, skip blue spheres results screen.
// Function taken from level\special\bs_results.lemon
//# address-hook(0x02e3da) end(0x02e40e)
function void fn02e3da()
{
	if (time_attack)	// Skip level results and award bonuses directly. The continue is actually awarded the moment 50 rings are collected, not in results.
	{
		global.game_mode = 0x0c
		results.ring_bonus = u32(bluespheres.rings_collected) * 10
		if (challenge_greenspheres)
			results.ring_bonus = u32(bluespheres.blue_collected) * 10	// rings and blue spheres were swapped for other results screen checks
		results.time_bonus = (bluespheres.rings_remaining == 0) ? 5000 : 0
		addScore(results.time_bonus + results.ring_bonus)
		results.time_bonus = 0
		results.ring_bonus = 0
		CheckSaveGameSlotAfterBlueSpheres()
		return
	}

	A1 = A0 + 0x4a
	A2 = 0x02e834
	D1 = 0x12
	fn02e802()

	results.ring_bonus = u32(bluespheres.rings_collected) * 10
	if (challenge_greenspheres)
		results.ring_bonus = u32(bluespheres.blue_collected) * 10	// rings and blue spheres were swapped for other results screen checks
	results.time_bonus = (bluespheres.rings_remaining == 0) ? 5000 : 0

	// Wait for six seconds
	objA0.countdown_value = 360
#if STANDALONE
	if (!original_mode)
	{
		// Shorten the wait time a bit
		objA0.countdown_value -= 20
	}
#endif
	objA0.base_state += 2
}


// In Sonic 2 special stages, check for half of blue spheres collected to show CONTINUE and icon in results.
// Functions taken from level\special\bs_results.lemon
//# address-hook(0x02e4d6) end(0x02e50e)
function void fn02e4d6()
{
	// Tie continues to spheres in Sonic 2 special stages instead of to rings. We need at least half of the total spheres for a continue.
	// We will still check bluespheres.rings_collected because of value swaps done on special stage exit.
	u16 continueSpheres = (bluespheres.blue_total & 0x01) ? (bluespheres.blue_total + 1)/2 : bluespheres.blue_total/2
	if ((!challenge_greenspheres && bluespheres.rings_collected >= 50) || (challenge_greenspheres && bluespheres.rings_collected >= continueSpheres))
	{
		if (objA0.countdown_value != 0)
		{
			--objA0.countdown_value
			return
		}

		u16[0xffffeee0] = 0
		if (allocDynamicObjectAfterA0())
		{
			// Spawn character continue icons
			u16[0xffffeee0] = A1.u16
			objA1.update_address = 0x02ebe8
			objA0.countdown_value = 0x010e
			playSound(0xac)
		}
	}

	objA0.base_state += 2
	fn02e512()
}

//# address-hook(0x02e616) end(0x02e744)
function void fn02e616()
{
	// Tie continues to spheres in Sonic 2 special stages instead of to rings. We need at least half of the total spheres for a continue.
	// We will still check bluespheres.rings_collected because of value swaps done on special stage exit.
	u16 continueSpheres = (bluespheres.blue_total & 0x01) ? (bluespheres.blue_total + 1)/2 : bluespheres.blue_total/2

	if (objA0.countdown_value != 0)
	{
		--objA0.countdown_value
		return
	}

	D0.u16 = camera.position.y.u16
	if (D0.u16 < 0x0320)
	{
		++D0.u16
		camera.position.y.u16 = D0.u16
		if (D0.u16 != 0x02a0)
			return

		D0 = 4
		if ((!challenge_greenspheres && bluespheres.rings_collected >= 50) || (challenge_greenspheres && bluespheres.rings_collected >= continueSpheres))
		{
			debugLog(stringformat("collected = %d, threshold = %d, total = %d", bluespheres.blue_collected, continueSpheres, bluespheres.blue_total))
			debugLog("Passed!")
			D1.u16 = u16[0xffffeee0]
			if (D1.u16 != 0)
			{
				A1 = 0xffff0000 + D1.u16
				objA1.update_address = 0x02ec4a
				u16[A1 + 0x2e] = 0x14
			}
			++D0.u16
		}
		u16[A0 + 0x30] = D0.u16

		A1 = 0xffffb98a
		while (D0.s16 >= 0)
		{
			objA1.update_address = 0x02ec1e
			A1 += 0x4a
			--D0.s16
		}

		D0 = (global.super_emeralds >= 7) ? 4 : 2
		u16[A0 + 0x30] += D0.u16

		A1 = 0xffffbd96
		while (D0.s16 >= 0)
		{
			objA1.update_address = 0x02ec1e
			A1 += 0x4a
			--D0.s16
		}

		u16[A0 + 0x30] += 2

		A1 = 0xffffb98a
		u16[A1 + 0x2e] = 0x08
		u16[A1 + 0x78] = 0x0c
		u16[A1 + 0xc2] = 0x0c
		u16[A1 + 0x010c] = 0x10
		u16[A1 + 0x0156] = 0x10
		if ((!challenge_greenspheres && bluespheres.rings_collected >= 50) || (challenge_greenspheres && bluespheres.blue_collected >= continueSpheres))
		{
			u16[A1 + 0x01a0] = 0x14
		}
		u16[A1 + 0xaa] = 0
		u16[A1 + 0x013e] = 0

		A1 = 0xffffbd96
		u16[A1 + 0xc2] = 0x04
		if (global.super_emeralds >= 7)
		{
			u16[A1 + 0x0156] = 0x04
		}
	}
	else
	{
		updateSpritePattern(0x18a204, 0xf380, 0x0200)

		if (allocDynamicObjectStd())
		{
			D1 = 0
			D2 = 0
			D3 = 7
			while (D3.s16 >= 0)
			{
				objA1.update_address = 0x02ecd0
				u16[A1 + 0x2e] = D1.u16
				u16[A1 + 0x30] = D2.u16
				u16[A1 + 0x34] = A0.u16
				D1.u16 += 0x10
				++D2.u16
				if (!allocDynamicObjectAfterA1())
					break

				--D3.s16
			}
		}

		objA0.countdown_value = 0x1e
		u16[A0 + 0x30] = 0
		objA0.base_state += 2

		playSound(0xb8)
	}
}

//# address-hook(0x02ea7c) end(0x02eaa4)
function void fn02ea7c()	// CONTINUE text and associated character-colored icon. The character sprite for continues is in the previous functions.
{
	// Tie continues to spheres in Sonic 2 special stages instead of to rings. We need at least half of the total spheres for a continue.
	// We will still check bluespheres.rings_collected because of value swaps done on special stage exit.
	u16 continueSpheres = (bluespheres.blue_total & 0x01) ? (bluespheres.blue_total + 1)/2 : bluespheres.blue_total/2
	if ((!challenge_greenspheres && bluespheres.rings_collected < 50) || (challenge_greenspheres && bluespheres.rings_collected < continueSpheres))
	{
		UnloadObject()
	}
	else
	{
		fn02ea1e()
	}
}





// In marathon mode, ignore HPZ special stage entrance scene(s) and jump directly to first unfinished S&K stage
// Function taken from objects\basics\giantring.lemon
//# address-hook(0x0618ac) end(0x0618ca)
function void fn0618ac()	// Here, it's already been determined that we're going to an S&K stage
{
	if (time_attack && global.chaos_emeralds)	// marathon mode and you have at least one chaos emerald
	{
	//	 if (!global.super_emeralds)		// if no super emeralds
	//		global.next_bluespheres = 0		// start from first stage
		for (s8 i = 6; i >= 0; i--)			// step through all collected emeralds and turn any chaos emeralds into inactive super emeralds
		{
			if (u8[0xffffffb2 + i] == 1)	// 0xffffffb2 is the first emerald, with others occupying consecutive bytes.
				u8[0xffffffb2 + i] = 2		// A value of 0 is uncollected, 1 is collected chaos, 2 is inactive super, and 3 is collected super.
			if (u8[0xffffffb2 + i] == 2)	// Now, if any super emerald is uncollected,
				global.next_bluespheres = i	// make it the next special stage to do. Since we step through backwards, it becomes the *earliest* unfinished stage.
		}
		global.traded_emeralds = 0xff		// mark emeralds as traded from chaos to super

		global.sk_bluespheres = 1
		global.stage_type = 1
		global.game_mode = 0x34
		global.in_extra_stage = 1
		fn0618d0()
	}
	else	// normal play as well as if you try to enter in marathon mode with no chaos emeralds (in AIR, can only happen at MHZ1 start)
	{
		global.stage_type = 2
		global.zone_act = 0x1701
		global.zone_act.apparent = 0x1701
		checkpoint.number = 0
		level.restart.u8 = 1
		global.in_extra_stage = 1
		fn0618d0()
	}
}






// In Original Mode, ignore the setting to not advance the special stage on failure and enforce Super/Hyper Tails classic behavior.
// Function taken from level\special\bluespheres.lemon
//# address-hook(0x02df64) end(0x02e2be)
function void fn02df64()
{
	playMusic(MUSIC_CTRL_FADEOUT)

	u8[0xffffef6e] = global.next_bluespheres

	bool goToNextStage = true
#if STANDALONE
	if (Game.getSetting(SETTING_BS_REPEAT_ON_FAIL) && !original_mode)
	{
		// Do not go to next stage if failed this stage
		goToNextStage = (bluespheres.stage_exit_state != 0)
	}
#endif
	if (goToNextStage)
	{
		// Go the next special stage
		D0.u8 = global.next_bluespheres
		D1.u8 = u8[0xffffef70]
		if (D1.u8 != 0)
		{
			D0.u8 = D1.u8 & 0x7f
		}
		else
		{
			++D0.u8
			if (D0.u8 >= 7)
				D0 = 0
		}
		global.next_bluespheres = D0.u8
	}

#if !STANDALONE
	set_status_register(0x2700)
#endif

	VDP.Config.setActiveDisplay(false)
	fn0011ca()

	VDP.Config.enableHInt(false)
	VDP.Config.setNameTableBasePlaneA(0xc000)
	VDP.Config.setNameTableBasePlaneB(0xe000)
	VDP.Config.setVerticalScrolling(false, 0xff)
	VDP.Config.setRenderingModeConfiguration(false)
	VDP.Config.setPlayfieldSizeInPixels(512, 256)

	zeroMemory(0xffffac00, 0x400)
	zeroMemory(0xffffb000, 0x2000)

	u16[0xfffffb00] = 0
	u32[0xfffffbfc] = 0xfffffb00

	sram.block_interrupts.u16 = 0
	CheckSaveGameSlotAfterBlueSpheres()

	competition_mode.active = 0
	u16[0xfffff100] = 0
	gfx.plane_update_routine = 0
	hud.dirty.timer = 0
	global.fade_timer = 0
	bluespheres.backup.zone_act = global.zone_act

	addPatternLoadingCue(0x02e310)

	Kosinski.addToDMAQueue(0x0d6a62, 0xb700)		// Common results graphics shared

	// Choose text: "Super" or "Hyper"
	if (isMainCharacter(CHARACTER_SONIC))
	{
		A1 = (global.super_emeralds < 7) ? 0x15b374 : 0x15b678
	}
	else if (isMainCharacter(CHARACTER_TAILS))
	{
	#if STANDALONE
		if (Game.getSetting(SETTING_HYPER_TAILS) && !original_mode)
		{
			A1 = (global.super_emeralds < 7) ? 0x15b374 : 0x15b678
		}
		else
	#endif
		{
			A1 = 0x15b374
		}
	}
	else
	{
		A1 = (global.super_emeralds < 7) ? 0x15b4f6 : 0x15b7ea
	}
	Kosinski.addToDMAQueue(A1, 0xa1e0)		// "Super" or "Hyper" nameplate appropriate for the character and form

	if (isMainCharacter(CHARACTER_SONIC))
	{
		A1 = 0x15b95c
	}
	else if (isMainCharacter(CHARACTER_TAILS))
	{
		A1 = (global.region_code & 0x80) ? 0x39ab6a : 0x39aa18
	}
	else
	{
		A1 = 0x0d67f0
	}
	Kosinski.addToDMAQueue(A1, 0x9e20)		// Character nameplate

	Kosinski.addToDMAQueue(0x15babe, 0xa460)		// Special Stage results graphics

	vint.update_subroutine = 0x02df62

	while (true)
	{
		global.frame_state = 0x1e
		Kosinski.ProcessDecompressionQueue()

		waitForNextFrame()

		LoadRequiredSpritePatterns()
		Kosinski.ProcessModules()

		if (kosinski.waiting_modules == 0 && u32[0xfffff680] == 0)
			break
	}

#if STANDALONE
	Renderer.resetSprites()
#endif

	ResetScoreDisplay()
	hud.dirty.score = 0x01

	copyMemory(0xfffffc00, 0x02e318, 0x80)
	copyMemory(0xfffffc80, 0x02e318, 0x80)

#if STANDALONE
	globalComponentTintColorR = 0xff
	globalComponentTintColorG = 0xff
	globalComponentTintColorB = 0xff
	globalComponentAddedColorR = 0
	globalComponentAddedColorG = 0
	globalComponentAddedColorB = 0
#endif

	fn02e2c0()

	if (global.lock_on_state == 0 && global.sk_bluespheres)
	{
		copyMemory(0xfffffc00, 0x02e318, 0x20)
		copyMemory(0xfffffc20, 0x02e318, 0x20)
		copyMemory(0xfffffc80, 0x02e318, 0x20)
		copyMemory(0xfffffca0, 0x02e318, 0x20)
	#if STANDALONE
		// This is needed to avoid the red Super Emerald's colors from being corrupted
		u16[0xfffffc24] = 0x0eee
		u16[0xfffffc26] = 0x0eee
		u16[0xfffffc28] = 0x0eee
	#endif

		fn02e2c0()

		fillMemory_u32(0xfffffc40, 0x40, 0x0ccc0ccc)
		copyMemory(0xfffffcc0, 0x0a9d5c, 0x40)
		copyMemory(0xffff8000, 0x0a7924, 0x1000)	// load S3&K HPZ layout
		if (original_mode)
			u8[0xffff821d] = 0x7c		// match the original ROM hack's layout just to the left of the leftmost super emerald

		// Load Hidden Palace level blocks and chunks from ROM
	//	Kosinski.decompress(0x1bfbea, 0xffff0000)	// After this (Primary chunk loading), A1 points to where uncompressed data ends
		System.loadExternalRawData(stringformat("hpz_chunks_p", global.act + 1), KosinskiRawdataBuffer)		// copy Primary chunks to shared memory
		Kosinski.decompress(KosinskiRawdataBuffer, 0xffff0000)												// decompress them to their proper RAM

	//	Kosinski.decompress(0x1c71fe, A1)			// Secondary chunk loading
		System.loadExternalRawData(stringformat("hpz2_chunks_s", global.act + 1), KosinskiRawdataBuffer)		// copy Primary chunks to shared memory
		Kosinski.decompress(KosinskiRawdataBuffer, A1)														// decompress them to their proper RAM
		
		Kosinski.decompress(0x1becf8, 0xffff9000)	// Same here (Primary block loading)
		Kosinski.decompress(0x1c30fc, A1)			// Secondary block loading

		// Load Hidden Palace level tiles from ROM
		D4.u16 = u16[0x1bee58]
		Kosinski.addToDMAQueue(0x1bee58, 0x0000)
		Kosinski.addToDMAQueue(0x1c3f2c, D4.u16)

		requestLoadingPatterns(0x48)	// HPZ object sprites

		global.zone_act = 0x1701
		camera.position.x.u16 = 0x15a0 - getScreenExtend()
		camera.position.y.u16 = 0x0240
		dynobjects.routine = 0

		DynamicObjectsLoading()
		camera.position.x.u16 = u16[0x02e398 + u8[0xffffef6e] * 2] - getScreenExtend()

	#if !STANDALONE
		set_status_register(0x2700)
	#endif
		InitLevelDisplay()
	#if !STANDALONE
		set_status_register(0x2300)
	#endif

		if (bluespheres.blue_remaining == 0)
		{
			D0.u8 = u8[0xffffef6e] | 0x80
			u8[0xfffffac0] = D0.u8
			u8[0xfffffac1] = 0xff
		}
	}

	fn01aa6e()
	u16[0xffffef68] = 0x98
	u8[0xffffef6c] = 0xff
	u32[0xffffb940] = 0x02e3b8

	VDP.Config.setActiveDisplay(true)

	while (true)
	{
		global.frame_state = 0x08
		Kosinski.ProcessDecompressionQueue()

		waitForNextFrame()

		++level.framecounter
		D1.u16 = emerald.animframe + 1
		if (D1.u16 >= 3)
			D1 = 0
		emerald.animframe = D1.u16

		UpdateGameObjects()
		if (global.lock_on_state == 0 && global.sk_bluespheres)
		{
			UpdateLevelDisplay()
		}

		RenderSprites()
		LoadRequiredSpritePatterns()
		Kosinski.ProcessModules()

		if (global.fade_timer > 0)
		{
			--global.fade_timer
			FadeInFromWhite()
		}

		if (global.game_mode != 0x48)
			break
	}

	global.zone_act = bluespheres.backup.zone_act
}



// In Original Mode, enforce classic Super/Hyper Tails behavior.
// Function taken from level\special\bs_results.lemon
//# address-hook(0x02e512) end(0x02e5be)
function void fn02e512()
{
	if (global.lock_on_state == 0 && global.sk_bluespheres && bluespheres.blue_remaining == 0)
	{
		objA0.countdown_value = 0x3c
		objA0.base_state = 0x0e
		fn02e616()
		return
	}

	if (objA0.countdown_value != 0)
	{
		--objA0.countdown_value
		return
	}

	if (bluespheres.blue_remaining == 0 && global.chaos_emeralds >= 7)
	{
		if (isMainCharacter(CHARACTER_TAILS) && (!Game.getSetting(SETTING_HYPER_TAILS) || original_mode))
		{
			// Tails
			if (bluespheres.backup.zone != 4 && bluespheres.backup.zone < 7)
			{
				global.game_mode = 0x0c
				return
			}
			objA0.base_state = 0x0a
		}
		else
		{
			// Sonic, Knuckles (or Tails if using Hyper Tails setting)
			if (global.lock_on_state == 0)
			{
				if (bluespheres.backup.zone == 4 || bluespheres.backup.zone >= 7)
				{
					objA0.base_state = 0x0a
				}
			}
		}

		A1 = 0xffffbd96
		for (u8 i = 0; i < 5; ++i)
		{
			objA1.update_address = 0x02ec1e
			A1 += 0x4a
		}

		u16[0xffffbe58] = 4
		u16[0xffffbeec] = 4
		u16[A0 + 0x30] = 5
		objA0.base_state += 2
	}
	else
	{
		global.game_mode = 0x0c
	}
}








// Don't allow speeding up special stage result point tallies in Original Mode
// Function taken from level\special\bs_results.lemon
//# address-hook(0x02e410) end(0x02e4d2)
function void fn02e410()
{
	if (objA0.countdown_value != 0)
	{
		// Still waiting
		--objA0.countdown_value
		if (objA0.countdown_value == 0 && global.lock_on_state == 0 && global.sk_bluespheres && bluespheres.blue_remaining == 0)
		{
			palette_fade.range = 0x003f
			global.fade_timer = 0x16

			A1 = 0xfffffc00
			u16[A1 + 0x42] = 0x0eee
			u16[A1 + 0x44] = 0x0eee
			u16[A1 + 0x4c] = 0x0eee
			u16[A1 + 0x62] = 0x0eee
			u16[A1 + 0x66] = 0x0eee
			u16[A1 + 0x6e] = 0x0eee
			u16[A1 + 0x70] = 0x0eee
			u16[A1 + 0x7c] = 0x0eee
			u16[A1 + 0x7e] = 0x0eee
		}

		u16 countdownCompare = (original_mode ? 289 : 269)
		if (objA0.countdown_value == countdownCompare)
		{
			playMusic(MUSIC_LEVELCLEAR)
		}
	}
	else
	{
		// Counting bonusses towards score
		u16 delta = 10
	#if STANDALONE
		if (Game.getSetting(SETTING_LEVELRESULT_SCORE) && !original_mode)
		{
			// Count faster over time
			if (results.total_bonus >= 3000)
				delta = 30
			else if (results.total_bonus >= 1000)
				delta = 20

			// Allow for manually (more or less) skipping the counter
			if (control.pad1.state & (CONTROL_ABC | CONTROL_START))
			{
				delta = 200
			}
		}
	#endif

		D0 = 0
		if (results.time_bonus != 0)
		{
			u16 diff = min(delta, results.time_bonus)
			D0.u16 += diff
			results.time_bonus -= diff
		}
		if (results.ring_bonus != 0)
		{
			u16 diff = min(delta, results.ring_bonus)
			D0.u16 += diff
			results.ring_bonus -= diff
		}

	#if STANDALONE
		// Needed for SETTING_LEVELRESULT_SCORE
		results.total_bonus += D0.u16
	#endif
		if (D0.u16 != 0)
		{
			// Still counting
			AddScore()
			if ((level.framecounter & 0x03) == 0)
			{
				playSound(SFX_CLICK)
			}
		}
		else
		{
			playSound(0xb0)
			objA0.countdown_value = 120
			objA0.base_state += 2
			fn02e4d6()
		}
	}
}