// Adjust screen boundaries for MGZ1 boss to match screen height extension
//# address-hook(0x0885a4) end(0x088600)
function void fn0885a4()
{
#if STANDALONE
	objA0.position.x.u16 += getScreenExtend() * 2
#endif

	setupObjectAttributesFull(0x088af6)

	boss.remaining_hits = 6
	objA0.hitbox_extends.y = 0x28
	move_area.right = 0x2e00 + getScreenExtend() * 2
	move_area.bottom.target = 0x0e10 - getScreenHeightExtend()
	u16[A0 + 0x3a] = 0x2e00
	objA0.countdown_callback = 0x088616
	fn0685e2()
	objA0.flags38 |= 0x02

	addPatternLoadingCue(0x088b88)		// Falling pointy rocks and boss explosion sprites

	if (allocDynamicObjectStd())
	{
		// Create the object that fades out level music and starts the boss theme afterwards
		objA1.update_address = 0x085b30
		u8[A1 + 0x2c] = MUSIC_MINIBOSS_2
	}

	// "spawnChildObjects(0x088b2c)" replaced by:
	spawnChildObject(0x0887f6, 0x00, -28, -22)
	spawnChildObject(0x0887f6, 0x02, 28, -22)
}

// Ensure the call to 16x16 block drawing function fn04ee9e() receives the appropriate number of rows of blocks for the screen height
//# address-hook(0x05130c) end(0x051328)
function void fn05130c()
{
	fn05134c()

	if ((camera.screenshake.state & 0x8000) == 0)
	{
		LoadTileContentDefault()
		return
	}

	A4 = 0x23d070
	A5 = 0xffffa900
	D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	D5 = 0x0a
	fn04ee9e()
}

// Set the proper height for the platform that assists Knuckles in the fight
//# address-hook(0x088864) end(0x0888a4)
function void fn088864()
{
	setupObjectAttributesFull(0x088b20)
	objA0.update_address = 0x0888a6

	objA0.position.x.u16 = camera.position.x.u16 + ((objA0.render_flags & render_flag.FLIP_X) ? getScreenWidth() - 0x30 : 0x30)
	objA0.position.y.u16 = camera.position.y.u16 + 0xf0 + getScreenHeightExtend()
	u16[A0 + 0x3a] = objA0.position.y.u16
	objA0.base_state = 0
	objA0.countdown_value = 0x0f
}

// Adjust MGZ2 background to
// 1. not show empty space below the background at low y coordinates, and
// 2. not show the background buildings during the MGZ2 flying boss due to increased screen height.
// The buildings break the illusion of flying high in the sky and do not change palette during the sunset.
// D1 is used in two functions as a modifier to camera.background.y.u16: once in a function with D1 = 0,
// and once in a function to shift the background when approaching the MGZ2 flying boss.
//# address-hook(0x23d21e) end(0x23d21e)
function void fn23d21e()
{
	D1 = 0
	fn23d220()
    if (getScreenHeightExtend() > 0)
    {
		u16[0xfffffc40] = u16[0xfffffc74]	// set the transparency color to the color of the bottom of the background
    }
}

//# address-hook(0x23d1e4) end(0x23d1e8)
function void fn23d1e4()
{
	D1.u16 = 0x0500 + (getScreenHeightExtend() * 4)
	fn23d220()
}


// MGZ2: unload Eggman cutscenes in time attack modes
// Functions taken from level\03_mgz\mgz_robotnikencounters.lemon
//# address-hook(0x051504) end(0x05155e)
function void fn051504()
{
	if (!original_mode && u16[0xffffb010] < 0x1000)	// do not try to set the camera locks for the unused encounter
		return
	
	base.fn051504()
}

// We can adjust MGZ2 mid-act Eggman encounter screen boundaries to account for screen height,
// but this reveals a Relief above the Knuckles-specific encounter that has its art overwritten
// during the encounter.
// If this is uncommented, remove the version above.
// //# address-hook(0x051504) end(0x05155e)
// function void fn051504()
// {
//	if (!original_mode && u16[0xffffb010] < 0x1000)	// do not try to set the camera locks for the unused encounter
//		return
//
// 	A5 = 0xffffeee4
// 	A1 = 0x23cf58
// 	D2 = 4
// 	D3 = 2
// 	while (D3.s16 >= 0)
// 	{
// 		if (u8[A5] == 0)
// 		{
// 			if (D0.u16 >= u16[A1] && D0.u16 < u16[A1 + 2] && D1.u16 >= u16[A1 + 4] && D1.u16 < u16[A1 + 6])
// 			{
// 				u16[0xffffeee2] = D2.u16

// 				D0.u16 = u16[A1 + 8] - getScreenHeightExtend()
// 				move_area.bottom.current = D0.u16
// 				move_area.bottom.target = D0.u16

// 				D0.u16 = u16[A1 + 10]
// 				if (D2.u16 == 4)
// 				{
// 					move_area.right = D0.u16
// 				}
// 				else
// 				{
// 					move_area.left = D0.u16
// 				}
// 			#if STANDALONE
// 				// Make sure the screen mover gets stopped (in case it is active here), as it may mess up things here
// 				screenmover_target.right = move_area.right
// 			#endif
// 				return
// 			}
// 		}

// 		A1 += 12
// 		++A5
// 		D2.u16 += 4
// 		--D3.s16
// 	}
// }



// Set the MGZ2 flying boss screen lock in accordance with screen height and make move_area.right here match move_area.left from fn01c96e().
// Also accommodate ultrawide resolutions by checking the character x position, not the camera x position.
//# address-hook(0x01c930) end(0x01c96c)
function void fn01c930()
{
	if (original_mode)
	{
		base.fn01c930()
		return
	}

	if (camera.position.y.u16 >= 0x0600 - getScreenHeightExtend() && camera.position.y.u16 < 0x0700 - getScreenHeightExtend())
	{
		if (u16[0xffffb010] >= 0x3aa0)	// formerly if (camera.position.x.u16 >= 0x3a00)
		{
			D0.u16 = 0x06a0 - getScreenHeightExtend()
			level.vertical_wrap = D0.u16
			move_area.top.target = D0.u16
			move_area.bottom.current = D0.u16
			move_area.bottom.target = D0.u16
			D0.u16 = (getScreenWidth() > 400) ? 0x3c80 + getScreenExtend() : 0x3c80 + ((getScreenExtend() + 0x0f) & 0xfff0)
			move_area.right = D0.u16
			move_area.right.target = D0.u16
			camera.update_routine += 2
		}
	}
}

// Set the MGZ2 non-flying boss spawn position in accordance with screen height and make move_area.left here match move_area.right from fn01c930()
// Also accommodate ultrawide resolutions by checking the character x position, not the camera x position.
//# address-hook(0x01c96e) end(0x01c9c6)
function void fn01c96e()
{
	if (original_mode)
	{
		base.fn01c96e()
		return
	}

	if (u16[0xffffb010] >= 0x3aa0)	// formerly if (camera.position.x.u16 >= 0x3a00)
	{
		D0.u16 = (getScreenWidth() > 400) ? 0x3c80 - getScreenExtend() : 0x3c80 - (getScreenExtend() & 0xfff0)
		if (D0.u16 > camera.position.x.u16)
			return

		move_area.left = D0.u16
		move_area.left.target = D0.u16

		if (allocDynamicObjectStd())
		{
			// Trigger boss
			objA1.update_address = 0x06c31a
			objA1.position.x.u16 = 0x3d20
			objA1.position.y.u16 = 0x0668 - getScreenHeightExtend()
		}

		camera.update_routine += 2
	}
	else
	{
		D0 = 0x1000
		u32[0xffffee18] = D0
		u32[0xffffee10] = D0

		D0.u16 = 0x6000
		move_area.right = D0.u16
		move_area.right.target = D0.u16

		camera.update_routine -= 2
	}
}

// Set the MGZ2 flying boss speed in accordance with screen height (to compensate for altered starting position).
// Allow the MGZ2 flying boss to descend for a longer period of time (ending up lower) when Knuckles fights him.
// Function taken from bosses\boss_mgz2.lemon
//# address-hook(0x06c3ec) end(0x06c414)
function void fn06c3ec()
{
	objA0.base_state = 0x04
	playMusic(MUSIC_MAINBOSS)
	level.default_music.u8 = MUSIC_MAINBOSS

	objA0.velocity.y = 0x80 + (getScreenHeightExtend() * 4/3)
	objA0.countdown_value = (isMainCharacter(CHARACTER_KNUCKLES) && !original_mode) ? 0xff : 0xbf
	objA0.countdown_callback = 0x06c422
}

// When the screen height is extended, we use images
// to recreate the floor collapse during the boss.
// We prepare some things before the collapse here.
//# address-hook(0x05134c) end(0x0514a8)
function void fn05134c()
{
	if (u8[0xffffb000 + 0x05] >= 0x06)
		return

	if ((camera.screenshake.state & 0x8000) == 0)
	{
		if (camera.screenshake.state != 0)
			return

		// Clear parts of the level chunks to get rid of the collision
		A1 = 0xffff0079 + u16[A3 + 0x38]
		D0.u16 = u16[A3 - 0x08]
		D1 = 2
		while (D1.s16 >= 0)
		{
		#if STANDALONE
			u8[A1-1] = 0	// Need to clear one more chunk on the left for widescreen
		#endif
			u8[A1]   = 0
			u8[A1+1] = 0
			u8[A1+2] = 0

			// For our image version of the collapse, we repeat this process for several rows of chunks above the boss area.
			// We then force a single redraw of the area so only the image graphics remain as visible terrain.
			if (getScreenHeightExtend() > 0)
			{
			#if STANDALONE
				u8[A1-0x81] = 0	// Need to clear one more chunk on the left for widescreen
			#endif
				u8[A1-0x80] = 0
				u8[A1-0x7f] = 0
				u8[A1-0x7e] = 0

			#if STANDALONE
				u8[A1-0x101] = 0	// Need to clear one more chunk on the left for widescreen
			#endif
				u8[A1-0x100] = 0
				u8[A1-0xff] = 0
				u8[A1-0xfe] = 0

			#if STANDALONE
				u8[A1-0x181] = 0	// Need to clear one more chunk on the left for widescreen
			#endif
				u8[A1-0x180] = 0
				u8[A1-0x17f] = 0
				u8[A1-0x17e] = 0

			#if STANDALONE
				u8[A1-0x201] = 0	// Need to clear one more chunk on the left for widescreen
			#endif
				u8[A1-0x200] = 0
				u8[A1-0x1ff] = 0
				u8[A1-0x1fe] = 0

			#if STANDALONE
				u8[A1-0x281] = 0	// Need to clear one more chunk on the left for widescreen
			#endif
				u8[A1-0x280] = 0
				u8[A1-0x27f] = 0
				u8[A1-0x27e] = 0

			#if STANDALONE
				u8[A1-0x301] = 0	// Need to clear one more chunk on the left for widescreen
			#endif
				u8[A1-0x300] = 0
				u8[A1-0x2ff] = 0
				u8[A1-0x2fe] = 0

			#if STANDALONE
				u8[A1-0x381] = 0	// Need to clear one more chunk on the left for widescreen
			#endif
				u8[A1-0x380] = 0
				u8[A1-0x37f] = 0
				u8[A1-0x37e] = 0

			#if STANDALONE
				u8[A1-0x401] = 0	// Need to clear one more chunk on the left for widescreen
			#endif
				u8[A1-0x400] = 0
				u8[A1-0x3ff] = 0
				u8[A1-0x3fe] = 0
			}

			A1 += D0.u16
			--D1.s16
		}

		A1 = 0xffffa902
		A5 = 0xffffa93c
		A6 = A5 + 0x28
		D0.u16 = camera.foreground.y.u16 & level.height.tilemask
		D1 = 9
		while (D1.s16 >= 0)
		{
			u16[A1] = D0.u16
			u32[A5] = 0
			u32[A6] = 0
			A1 += 4
			A5 += 4
			A6 += 4
			--D1.s16
		}

		// Create collision objects that replace the terrain during collapse
		//  -> There's an upper and a lower line of these objects
		if (allocDynamicObjectStd())
		{
			D1.u16 = 0x3c90
			D2 = 0x05c00790
			D3 = 0xffffa93c
			D4 = 9
			while (D4.s16 >= 0)
			{
				objA1.update_address = 0x05180a
				objA1.position.x.u16 = D1.u16
				u16[A1 + 0x2e] = D2.u16
				u32[A1 + 0x30] = D3
				D2 = (D2 << 16) + (D2 >> 16)
				if (!allocDynamicObjectAfterA1())
					break

				objA1.update_address = 0x05180a
				objA1.position.x.u16 = D1.u16
				u16[A1 + 0x2e] = D2.u16
				u32[A1 + 0x30] = D3
				D1.u16 += 0x20
				D2 = (D2 << 16) + (D2 >> 16)
				D3 += 4
				if (!allocDynamicObjectAfterA1())
					break

				--D4.s16
			}
		}
		// Blank out the layout parts chunks we set to 0 earlier and render an image for the one frame before the collision objects render the image parts.
		if (getScreenHeightExtend() > 0)
		{
			fillPlaneA_Default(camera.foreground.x.u16, camera.foreground.y.u16, getScreenWidth(), getScreenHeight())
		}

		camera.screenshake.state.hi = 0xff
		u16[0xffffeed8] = 0
		u8[0xffffeea2] = 0xff
		gfx.plane_update_routine = 0x04		// Enter vertical scroll mode
	#if STANDALONE
		verticalScrollOffsetBias = 0
	#endif
	}

	A1 = 0xffffa900
	A4 = A1 + 0x28
	A5 = A4 + 0x14
	A6 = 0x23d05c
	D0.u16 = u16[0xffffeed8]
	++u16[0xffffeed8]

	D1 = 10
	D2 = 9
	while (D2.s16 >= 0)
	{
		if (D0.u16 >= u16[(A6+=2)-2])
		{
			u32[A1 + 0x64] += 0x0500
		}
		D3 = u32[A1 + 0x64]
		u32[(A5+=4)-4] += D3
		D3.u16 = u16[A5 - 0x04]
		if (D3.u16 >= 0x02e0)
		{
			D3.u16 = 0x02e0
			--D1.u16
		}
		D4.u16 = camera.foreground.y.u16 - D3.u16
		u16[(A4+=2)-2] = D4.u16
		u16[A1] = D4.u16
		A1 += 4
		--D2.s16
	}

	D0.u16 = (level.framecounter - 1) & 0x0f
	if (D0.u16 == 0)
	{
		playSound(0xcc)
	}

	if (D1.u16 == 0)
	{
		A1 = 0xffff0079 + u16[A3 + 0x2c]
		D0.u16 = u16[A3 - 0x08] - 3
		D1 = 2
		while (D1.s16 >= 0)
		{
			u8[(A1+=1)-1] = 0
			u8[(A1+=1)-1] = 0
			u8[(A1+=1)-1] = 0
			A1 += D0.u16
			--D1.s16
		}

		camera.screenshake.state = 0
		u32[0xffffeeda] = 0
		u16[0xffffeede] = camera.foreground.x.u16
		gfx.plane_update_routine = 0x0c		// Leave vertical scroll mode again
		u16[0xffffeec0] += 4
	}
}

// Make the floor collision objects render vertical slices of the
// collapsing boss area when the screen height is extended.
//# address-hook(0x05180a) end(0x05183c)
function void fn05180a()
{
	if (u16[0xffffeec0] == 8)
	{
		UnloadObject()
		return
	}

	A1 = u32[A0 + 0x30]
	D0.u16 = objA0.countdown_value + u16[A1]
	objA0.position.y.u16 = D0.u16
	objA0.box_size.x = 0x10
	objA0.flags2a |= 0x80

	D1 = 0x1b
	D2 = 0x40
	D3 = 0x40
	D4.u16 = objA0.position.x.u16
	CheckCharacterOnClimbableObject()

	if (u16[A0 + 0x2e] == 0x05c0 && getScreenHeightExtend() > 0)
	{
		DrawObject()	// call the renderhook to draw image sections of the collapsing terrain
	}
}

// Alter the lowest possible y position a character can reach during the MGZ2 flying boss to match screen height changes
//# address-hook(0x0162d8) end(0x016442)
function void fn0162d8()
{
	objA0.position.x.u16 = camera.position.x.u16 + 0x40
	objA0.position.y.u16 = camera.position.y.u16 + 0x0100 + getScreenHeightExtend()

	if (!isMainCharacter(CHARACTER_TAILS))
	{
		A1 = 0xffffb04a
		if (s8[A1 + 0x04] >= 0)
		{
			objA1.position.x.u16 = objA0.position.x.u16
			objA1.position.y.u16 = objA0.position.y.u16 - 1
			u32[0xffffb04a] = addressof(Character.BaseUpdate.Tails)

			tails.ai_routine = 0x12
			tails.carrying = 0
			tails.catch_timeout = 0

		#if STANDALONE
			// This prevents a bug that makes Tails die just before the main boss fight starts
			player2.control_override = 0
		#endif
		}

		u16[A0 + 0x30] = 360
		objA0.update_address = 0x016334
		fn016334()
	}
	else
	{
		u16[A0 + 0x30] = 360
		objA0.update_address = 0x0163f4
		fn0163f4()
	}
}

// When the MGZ2 flying boss comes from the top or bottom of the screen, adjust its starting y position
// to not show the drill poking onto the screen when the screen height is extended.
// We also adjust the x position in these cases to compensate for the extra time spent flying to the right.
//# address-hook(0x06d710) end(0x06d742)
function void fn06d710()
{
	D0.u16 = u16[A0 + 0x3c]
	A2 = 0x06d744 + D0.s16
	objA0.position.x.u16 = camera.position.x.u16 + s16[(A2+=2)-2]
	objA0.position.y.u16 = camera.position.y.u16 + s16[(A2+=2)-2]
	if (objA0.position.y.u16 < camera.position.y.u16)
	{
		objA0.position.x.u16 -= getScreenHeightExtend()/4
		objA0.position.y.u16 -= getScreenHeightExtend()
	}
	else if (objA0.position.y.u16 > camera.position.y.u16 + getScreenHeight())
	{
		objA0.position.x.u16 -= getScreenHeightExtend()/4
	 	objA0.position.y.u16 += getScreenHeightExtend()
	}
	objA0.velocity.x = s16[0x06d754 + D0.s16]
	objA0.velocity.y = s16[0x06d756 + D0.s16]
	D0.u16 >>= 1
	u16[A0 + 0x26] = u16[0x06d764 + D0.s16]
	D0.u16 >>= 1
	objA0.value3a = u8[0x06d76c + D0.s16]
}

// Adjust screen boundaries for MGZ2 non-flying boss to match screen height extension.
// In Original Mode, use miniboss music for the non-flying MGZ2 boss and undo an AIR widescreen adjustment.
// Functions taken from bosses\boss_mgz2_knuckles.lemon
//# address-hook(0x06c698) end(0x06c6ee)
function void fn06c698()
{
	A1 = 0x06c688
	if (InitBoss(0x06c6a2))
		return

	if (!original_mode)
	{
		// Use main boss music
		objA0.value26 = MUSIC_MAINBOSS
	}
	else
		objA0.value26 = MUSIC_MINIBOSS_2
	
	StartBossFight()

	objA0.update_address = 0x06c6f4
	objA0.countdown_callback = 0x06c6fa

	Kosinski.addToDMAQueue(0x36b340, 0x67e0)		// Boss sprites

	Kosinski.addToDMAQueue(0x36d572, 0x8bc0)		// Falling debris sprites

	requestLoadingPatterns(0x6d)		// Robotnik's ship, boss explosions, and capsule sprites
	loadPaletteLine1(0x06d97c)

	level.bossarea.left -= getScreenExtend()
	level.bossarea.right += getScreenExtend()
    level.bossarea.top -= getScreenHeightExtend()/2
    level.bossarea.bottom -= getScreenHeightExtend()/2

	// Alter some chunks to the right of the level's edge (i.e., the left edge due to wrapping)
	// to allow the correct zone transition in ultrawide resolutions.
	if (!original_mode)
	{
		u8[0xffff8108] = 0x50
		u8[0xffff8188] = 0x4f
		u8[0xffff8208] = 0xbc
	}
}

//# address-hook(0x06d45e) end(0x06d4aa)
function void fn06d45e()
{
	u16 type = D1.u16
	u16 px
	if (!original_mode)
		px = camera.position.x.u16 + getScreenWidth() / 2 + 8 + D0.s16
	else
		px = camera.position.x.u16 + 168 + D0.s16
	u16 py = D3.u16
	u16 offset = u16[0x06d4ac + type * 2]
	u16[A0 + 0x26] = offset

	objA0.position.x.u16 = px
	objA0.position.y.u16 = py
	u16[A2+0] = type * 2
	u16[A2+2] = offset
	u16[A2+4] = px
	u16[A2+6] = py
	u32[A0 + 0x30] = u32[0x06d4bc + type * 4]
	objA0.animation.frame = 0
	objA0.animation.timer = 0

	u32[A0 + 0x18] = u32[0x06d34e + offset * 2]
	if (objA0.render_flags & render_flag.FLIP_X)
	{
		objA0.velocity.x = -objA0.velocity.x
	}
}

// Adjust timing on MGZ2 non-flying boss to ensure it fully disappears into the ground when moving downward.
//# address-hook(0x06c7bc) end(0x06c7d4)
function void fn06c7bc()
{
	objA0.base_state = 0x08
	objA0.countdown_value = 0x87 + getScreenHeightExtend()/2
	objA0.countdown_callback = 0x06c7fe

	A1 = 0xfffffa82
	fn06d51a()
}

// Adjust timing of "entering ground" sound to align with timing change from above.
//# address-hook(0x06c7d8) end(0x06c7f8)
function void fn06c7d8()
{
	if (objA0.countdown_value == 0x28 + getScreenHeightExtend()/2)
	{
		playSound(SFX_COLLAPSE)

		// "spawnSimpleChildObjects(0x06d83e)" replaced by:
		spawnSimpleChildObjects(0x06d16a, 1)
	}

	UpdateMovementStraightSimple()
	Object.CountdownAndTrigger()
}
