// Alter move_area.bottom and level.vertical_wrap values in MHZ1 in accordance with the new screen height
//# address-hook(0x054b20) end(0x054b7c)
function void UpdateLevelTiles.MHZ1()
{
	if (u8[0xffffeed2] == 0 && u16[0xffffeee8] == 0)
	{
		fn054b80()

		D0.u16 = (u16[0xffffb000 + 0x10] >= 0x4100) ? 0x0710 - getScreenHeightExtend() : 0x0aa0 - getScreenHeightExtend()
		if (D0.u16 != move_area.bottom.current)
		{
			move_area.bottom.current = D0.u16
			move_area.bottom.target = D0.u16
		}

		if (camera.position.x.u16 >= 0x4298 - (getScreenWidth() - 320) && camera.position.y.u16 >= 0x0710 - getScreenHeightExtend())
		{
			level.vertical_wrap = (0x0710 - getScreenHeightExtend())
			level.special_scrolling = 0x08
			u8[0xffffeed2] = 0xff

		#if STANDALONE
			if (Game.isTimeAttack())
			{
				// Nothing special to do here
			}
			else
		#endif
			{
				// Spawn boss
				if (allocDynamicObjectStd())
				{
					objA1.update_address = 0x0751ca
				}
			}
		}
	}

	LoadTileContentDefault()
}

// Alter value derived from camera.foreground.y.u16 in accordance with the new screen height when calculating MHZ background height
//# address-hook(0x054c68) end(0x054cae)
function void fn054c68()
{
    // At screen height = 224, the background y position reaches 0x021f. At screen height = 240, it should only reach 0x0210.
    // So the approximate backgroundY:extraScreenHeight ratio is 15:16.
    u32 derivedCameraYPos = camera.foreground.y.u16 * (0x21f - (getScreenHeightExtend() * 15 / 16))/0x21f

    D0.u16 = u16(derivedCameraYPos)
	D0 = (D0 << 16) + (D0 >> 16)
	D0.u16 = 0
	D0.s32 >>= 3
	D1 = D0
	D1.s32 >>= 2
	D0 += D1
	D0 = (D0 << 16) + (D0 >> 16)
	D0.u16 += 0x76
	camera.background.y.u16 = D0.u16
	D0.u16 = u16[0xffffeeb6]
	D0 = (D0 << 16) + (D0 >> 16)
	D0.u16 = 0
	D0.s32 >>= 1
	D1 = D0
	D1.s32 >>= 2
	D0 -= D1
	D1.s32 >>= 1
	camera.background.x.u16 = D0 >> 16
	D0 -= D1
	u16[0xffffeee2] = D0 >> 16
	D0 -= D1
	D0 = (D0 << 16) + (D0 >> 16)
	u16[0xffffeee4] = D0.u16
}

// Adjust MHZ1 boss spawn position in accordance with the new screen height
//# address-hook(0x075220) end(0x0752ce)
function void fn075220()
{
	setupObjectAttributesFull(0x075e52)

	objA0.position.x.u16 = camera.position.x.u16 + getScreenWidth() - 0x30
	objA0.position.y.u16 = camera.position.y.u16 - 0x78 + getScreenHeightExtend()
	boss.remaining_hits = 6
	u16[0xfffffaa4] = A0.u16
	u8[A0 + 0x42] = 0x05
	global.random.seed = global.framecounter
	level.boss_encounter = 1
	objA0.velocity.y = 0x0100
	objA0.countdown_value = 0x97
	objA0.countdown_callback = 0x0752e6
	u32[A0 + 0x30] = 0x075eae
	objA0.hitbox_extends.y = 0x18

	// "spawnChildObjects(0x075e84)" replaced by:
	spawnChildObject(0x0757c0, 0x00, 0, 0)			// Exhaust flame
	spawnChildObject(0x0757c0, 0x02, 0, 0)			// Exhaust flame

	if (allocDynamicObjectStd())
	{
		// Create the object that fades out level music and starts the boss theme afterwards
		objA1.update_address = 0x085b30
		u8[A1 + 0x2c] = MUSIC_MINIBOSS_2
	}

	Kosinski.addToDMAQueue(0x1680ca, 0x75a0)		// Boss sprites
	Kosinski.addToDMAQueue(0x16908c, 0x93e0)		// Rolling chopped tree log sprites

	addPatternLoadingCue(0x075f48)		// Boss explosion sprites

	loadPaletteLine1(0x075f28)
}

// Disallow a minor MHZ1 boss movement fix in Original Mode
//# address-hook(0x075356) end(0x075390)
function void fn075356()
{
	objA0.base_state = 0x08
	objA0.animation.sprite = 5
	objA0.countdown_value = 0x4f

#if STANDALONE
	if (!original_mode)
	{
		// Fix for jump in boss movement, #contributed by HazelSpooder
		if (objA0.value3b == 0)
		{
			// Ignore first movements, the original countdown time is correct in that case
			objA0.value3b = 1
		}
		else
		{
			// For the later movements, we need to add some extra movement time to avoid a sudden jump when reaching the log
			if (isMainCharacter(CHARACTER_KNUCKLES))
			{
				objA0.countdown_value += getScreenExtend() / 2
			}
			else
			{
				objA0.countdown_value += 4		// Fix for a jump for the other characters (this was in the original game already)
			}
		}
	}
#endif

	objA0.countdown_callback = 0x0753a4
	move_area.right.target = 0x6000
	screenmover_target.right = 0x6000

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x075e1a
		u16[A1 + 0x34] = move_area.right
	}
}

// Perform a full-screen redraw when the MHZ1 boss cuts through a pole
//# address-hook(0x075a94) end(0x075ace)
function void fn075a94()
{
	// Wait for trigger by level script...?
	if (u16[0xfffffaa4] != 0)
	{
		A1 = 0xffff0000 + u16[0xfffffaa4]
		if (objA1.update_address == 0x0751ca)
		{
			if (!(objA0.render_flags & render_flag.VISIBLE))
			{
				u8[A1 + 0x42] = 5
			}

			D0.u8 = u8[A1 + 0x42]
			if (D0.u8 != objA0.animation.sprite)
			{
				objA0.animation.sprite = D0.u8
				if (D0.u8 < 5)
				{
					// "spawnSimpleChildObjects(0x075e98)" replaced by:
					spawnSimpleChildObjects(0x075ad4, 1)		// Log

					fillPlaneA_Default(camera.position.x.u16, camera.position.y.u16, getScreenWidth(), getScreenHeight())
				}
			}
		}
	}

	Object.DrawOrUnload()
}

// MHZ2: don't adjust the camera maximum near the boss (as this inhibits Knuckles' gliding) in time attack modes.
// Alter move_area.bottom and level.vertical_wrap values in MHZ2 in accordance with the new screen height.
// Function taken from level\07_mhz\level_mhz.lemon
//# address-hook(0x054dbe) end(0x054e82)
function void fn054dbe()
{
	if (u16[0xffffeec4] != 0)
	{
		u16[0xffffeec4] = 0
		u16[0xffffeec8] = 0x0320
		u16[0xffffeeca] = 0x0a
		u16[0xffffeec0] += 8
		fn054e9c()
		return
	}

	u16 bossStartCamX = 0x3c90 - getScreenExtend() * 2
	if (camera.position.x.u16 >= bossStartCamX && time_attack != 1 && time_attack != 2)
	{
	#if STANDALONE
		{
			// This solves a possible glitch, but can lead to a sudden camera jump when trying to fly over everything with Tails
			move_area.left = max(bossStartCamX, move_area.left)
			level.vertical_wrap = 0x0280
			if (camera.position.x.u16 >= bossStartCamX + 0x200)
			{
				camera.position.y.u16 = 0x0280
			}

			// Refresh parts of the screen to avoid visual glitches
			fillPlaneA_Default(0x3c40, 0x0280, 512, 512)
		}
	#else
		if (camera.position.x.u16 == bossStartCamX)
		{
			move_area.left = bossStartCamX
			if (camera.position.y.u16 >= 0x0280)
			{
				level.vertical_wrap = 0x0280
			}
		}
	#endif
	}
	else
	{
		if (camera.position.x.u16 < 0x0380)
		{
			level.vertical_wrap = 0x0620 - getScreenHeightExtend()
		}
		else
		{
			level.vertical_wrap = (camera.position.x.u16 >= 0x3600) ? 0x01a8  - getScreenHeightExtend() : 0
		}

		if (camera.position.x.u16 < 0x3600 && u16[0xffffeee8] == 0)
		{
			move_area.left = (u16[0xffffb000 + 0x14] >= 0x05c0) ? max(s16(0x98 - getScreenExtend() * 2), 0) : 0x0380
		}

		if (u16[0xffffb000 + 0x10] < 0x3a97)
		{
			D0.u16 = 0x09a0 - getScreenHeightExtend()
		}
		else if (u16[0xffffb000 + 0x10] < 0x3ac0 && u16[0xffffb000 + 0x14] >= 0x0300)
		{
			D0.u16 = 0x09a0 - getScreenHeightExtend()
		}
		else
		{
			D0.u16 = 0x0280
		}
		if (D0.u16 != move_area.bottom.current)
		{
			move_area.bottom.current = D0.u16
			move_area.bottom.target = D0.u16
		}
	}

	fn055008()
	LoadTileContentDefault()
}

// MHZ2: when using Revisited visuals, replace leaves in the winter section with "snow" (pollen).
// A renderhook handles most of this, but when the boss is triggered, we want snow to change to
// pollen rather than becoming leaves.
// Here, A2 contains the address of the main or sidekick character that triggered the pollen/leaves.
//# address-hook(0x03db68) end(0x03dbae)
function void fn03db68()
{
	if (u8[0xfffff7c1] == 0 || (global.act == 1 && u16[A2 + 0x10] > 0x3900 && palette_set >= 2 && !original_mode))
	{
		objA1.mapping_offset = 0x03dc5c
		objA1.sprite_attributes = (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE3 | 0x0368)
		return
	}

	D0.u16 = u8[A0 + 0x32] & 0x07
	++u8[A0 + 0x32]
	D0.u8 = u8[0x03dbb0 + D0.u16]
	if (D0.u8 == 0)
	{
		objA1.mapping_offset = 0x03dc74
		objA1.sprite_attributes = (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE3 | 0x0363)
	}
	else
	{
		objA1.mapping_offset = 0x03dc5c
		objA1.sprite_attributes = (sprite_attribute.PRIORITY | sprite_attribute.PALETTE.LINE3 | 0x0363)
	}
}

// MHZ: ensure pollen/leaf counter, which prevents too many objects from spawning, does not underflow if it is
// somehow decremented multiple times as objects are deleted.
// Also reintroduce a glitch in Original Mode.
//# address-hook(0x03da00) end(0x03da22)
function void MHZLeavesEffect.Update()
{
	u16 debug_mode.state.backup

	if (!original_mode && s8[0xfffff7c0] < 0)
		u8[0xfffff7c0] = 0
	else if (original_mode)
	{
		// Avoid a STANDALONE check that stops leaf creation when in debug mode state.
		debug_mode.state.backup = debug_mode.state
		debug_mode.state = 0
	}

	base.MHZLeavesEffect.Update()

	if (original_mode)
		debug_mode.state = debug_mode.state.backup
}
