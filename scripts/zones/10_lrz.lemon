// Render terrain rock sprites in accordance with screen height
//# address-hook(0x01cb68) end(0x01cbbc)
function void RenderLevelSprites.LRZ()
{
	A0 = u32[0xfffffe66]
	D2 = u32[0xfffffe6a] - A0
	if (D2 != 0)
	{
		A1 = 0x01cbbe
		D3.u16 = 0x78
		D4.u16 = u16[A3 + 4]
		D5.u16 = 0xf0 + getScreenHeightExtend()

		while (D2.u16 != 0)
		{
			D1.u16 = u16[A0 + 4] - D4.u16 + 8
			if (D1.u16 < D5.u16)
			{
				D1.u16 += D3.u16
				D0.u16 = u16[A0 + 2] - u16[A3] + 0x80
				D6.u16 = u16[A0] << 3

				A2 = A1 + D6.s16
				D1.u16 += u16[A2]
				u16 px = D0.u16 + u16[A2+6]
				u16 py = D1.u16
				u8 size = u16[A2+2]
				u16 index = u16[A2+4]

				u16[A6+0] = py
				 u8[A6+2] = size
				u16[A6+4] = index
				u16[A6+6] = px

				#if STANDALONE
					Renderer.drawVdpSprite(px - 0x80, py - 0x80, size, index, 0x9f80)
				#endif

				A6 += 8
				--D7.u16
			}

			A0 += 6
			D2.u16 -= 6
		}
	}
}

// The heat haze effect data is only 0x200 bytes long and repeats every 0x40 bytes.
// If the desired offset within the data exceeds the data size, subtract 0x200 from the offset.
//# address-hook(0x059dde) end(0x059e44)
function void fn059dde()
{
	if (level.results_done || level.capsule_opened || u16[0xffffeec0] < 8)
	{
		WriteScrollOffsets()
		return
	}

	// Supposedly the heat haze effect
	A1 = 0xffffe000		// Location of linewise scroll offsets
	D1.u16 = level.framecounter * 2
	A5 = 0x05077e + ((camera.foreground.y.u16 + D1.u16) & 0x3e)
	D1.s16 >>= 1
	A6 = 0x05077e + ((camera.background.y.u16 + D1.u16) & 0x3e)

	D0.u16 = -camera.foreground.x.u16
	D1.u16 = -camera.background.x.u16
	D2.u16 = getScreenHeight()

	while (D2.s16 > 0)
	{
        if (A5 - 0x05077e >= 0x0200)
            A5 -= 0x0200
        if (A6 - 0x05077e >= 0x0200)
            A6 -= 0x0200
		u16[A1]   = u16[A5] + D0.u16
		u16[A1+2] = u16[A6] + D1.u16
		A1 += 4
		A5 += 2
		A6 += 2
		--D2.s16
	}
}

// Raise the screen when the driller is breaking the floor at extended screen heights, else pipes in the terrain under Sonic's/Tails's driller visibly vanish on screen
//# address-hook(0x0900f0) end(0x0901b2)
function void fn0900f0()
{
	A1 = (objA0.subtype2c == 0) ? 0x0901b8 : 0x0901c4
	if (InitBoss(0x090104, true))
		return

	objA0.update_address = 0x0901d0
	screenmover_target.top = level.vertical_wrap
	screenmover_target.bottom = move_area.bottom.target
	screenmover_target.left = move_area.left
	screenmover_target.right = move_area.right

	objA0.groundspeed = u16[A1]
	move_area.right = u16[(A1+=2)-2] + getScreenExtend()
	move_area.bottom.target = u16[(A1+=2)-2] - getScreenHeightExtend()

	setupObjectAttributesFull(0x090608)

	objA0.base_state = 0
	u8[A0 + 0x29] = 0xff
	objA0.hitbox_extends.y = 0x40
	if (objA0.subtype2c != 0)
	{
		u8[A0 + 0x0a] |= 0x80
	}

	// "spawnSimpleChildObjects(0x09067a)" replaced by:
	spawnSimpleChildObjects(0x0862ae, 1)		// Sprite mask
	if (_equal())
	{
		u8[A1 + 0x2c] = 0x8b
		if (objA0.subtype2c == 0)
		{
			objA1.position.x.u16 = 0x0f40
			objA1.position.y.u16 = 0x0760
		}
		else
		{
			objA1.position.x.u16 = 0x0540
			objA1.position.y.u16 = 0x0860
		}
	}

	Kosinski.addToDMAQueue(0x16f928, 0xa5c0)		// Large driller sprites
	addPatternLoadingCue(0x083d64)		// Boss explosion sprites
	loadPaletteLine1(0x090680)

	// "spawnChildObjects(0x090626)" replaced by:
	spawnChildObject(0x09039a, 0x00, -28, 28)
	spawnChildObject(0x09039a, 0x02, 28, 28)
	spawnChildObject(0x09039a, 0x04, -36, 28)
	spawnChildObject(0x09039a, 0x06, 36, 28)
	spawnChildObject(0x09039a, 0x08, -28, -36)
	spawnChildObject(0x09039a, 0x0a, 28, -36)
	spawnChildObject(0x09039a, 0x0c, -36, -36)
	spawnChildObject(0x09039a, 0x0e, 36, -36)
}

// Raise the screen for the LRZ1 boss to keep the snaking tendrils at the correct height while touching the screen's lower boundary at extended screen heights
//# address-hook(0x0784f0) end(0x07851c)
function void fn0784f0()
{
	A1 = 0x0784e0
	if (InitBoss(0x0784fa))
		return

	objA0.update_address = 0x078522
	objA0.countdown_callback = 0x078528
	A1 = 0x0784e8
	objA0.value26 = MUSIC_MINIBOSS_2
	StartBossFight()

	// Manipulate target values for camera boundaries
	level.bossarea.right += getScreenExtend() * 2
    level.bossarea.top -= getScreenHeightExtend()
    level.bossarea.bottom -= getScreenHeightExtend()

	loadPaletteLine1(0x078e0a)
}

// Reposition the LRZ1 boss's tendrils to the correct height at extended screen heights.
// This function handles the initial position of the lowest joint, from which the rest of each tendril bases its position.
//# address-hook(0x078bee) end(0x078c12)
function void fn078bee()
{
	objA0.position.x.u16 = camera.position.x.u16
	objA0.position.y.u16 = camera.position.y.u16 + 0x01b8 + getScreenHeightExtend()

	if (getScreenWidth() >= 400)
	{
		objA0.position.x.u16 += ((objA0.render_flags & render_flag.FLIP_X) ? (getScreenWidth() - 0x30) : 0x30)
	}
	else
	{
		objA0.position.x.u16 += ((objA0.render_flags & render_flag.FLIP_X) ? 0x120 : 0x20)
	}
}

// Ensure the call to 16x16 block drawing function fn059d24() receives the appropriate number of rows of blocks for the screen height
//# address-hook(0x059d24) end(0x059d7e)
function void fn059d24()
{
	if (u16[0xffffeec6] != 0 && u16[0xffffeedc] == 0)
	{
		u16[0xffffeec6] = 0
		gfx.plane_update_routine = 0x0c		// Leave vertical scroll mode again
		level.scrolling_routine += 4
		fn059d74()
		return
	}

	u8 rows = (getScreenWidth() + 15) / 16

	// Copy vertical scroll data from 0xffffa900+ to 0xffffa800+
	//  -> Search for 0xffffa910 to find the places where 0xffffa900+ get written
	fn059dbc()

	A4 = 0x05a106
	A5 = 0xffffa800
	D6 = getScreenHeight()/16 + 1	// formerly 0x0f, which is for getScreenHeight() = 224
	D5 = rows
	fn04eebc()

	fn059dde()

	// Copy vertical scroll data
	A1 = 0xffffeeea		// Start address of vertical scroll offsets
	A5 = 0xffffa800
	D0 = u32(camera.foreground.y.u16) << 16
	D1 = 20
	while (D1.s16 > 0)
	{
		u32[A1] = u16[A5]
		A5 += 4
		A1 += 4
		--D1.s16
	}

#if STANDALONE
	// Set additional vertical scroll offsets on the right
	for (u8 row = 20; row < rows; ++row)
	{
		Renderer.setScrollOffsetV(0, row, u16[A5])
		A5 += 4
		--D1.s16
	}
#endif
}

// Alter the camera when at the actual boss when using an altered screen height.
// This is commented out at the moment due to causing more visual issues than
// when it is left alone. The address hook would need to be uncommented as well
// if this is implemented.
/*
// //# address-hook(0x059f00)
function void fn059f00()
{
	D2 = 0x020000
	D1 = 0
	if (camera.position.x.u16 >= 0x0bbf - (getScreenWidth() - 320))
	{
		D2 = 0
		if (u16[0xffffb000 + 0x10] >= 0x0c50)
		{
			move_area.left = 0x0a00
			move_area.right = 0x0bc0
			D0.u16 = 0x0560 - getScreenHeightExtend()
			move_area.bottom.current = D0.u16
			move_area.bottom.target = D0.u16
			player1.camera_lock = 0
			level.special_scrolling = 0
			return
		}
	}

	fn059f3c()
}
*/
