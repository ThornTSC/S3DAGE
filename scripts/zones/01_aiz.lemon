// Adjust some timings for Original Mode and add Origins sound effects outside of Original Mode
// Functions taken from level\01_aiz\intro_sonic.lemon
//# address-hook(0x067572) end(0x067592)
function void fn067572()	// Sonic jumping from the Tornado
{
	if (!original_mode)
		playSound(SFX_JUMP)
	
	base.fn067572()
}

// If in Original Mode, we also un-tweak a counter here that is adjusted in AIR
//# address-hook(0x0675c0) end(0x0675f6)
function void fn0675c0()	// Sonic is offscreen after jumping. Actual transformation is handled in other functions. Origins adds a star trail (not added in DAGE yet).
{
	if (!original_mode)
		playSound(SFX_SUPERTRANSFORM)
	
	objA0.velocity.x -= 0x40
	UpdateMovementStraightSimple()
	if (objA0.position.x.u16 >= 0x40)
		return

	objA0.base_state = 0x0c
	objA0.position.x.u16 = 0x40
	objA0.countdown_value = 0x05
	objA0.countdown_callback = 0x0675fa
	u16[A0 + 0x3a] = (original_mode) ? 63 : 47	// Tweaked in AIR

	fn067996()
}

//# address-hook(0x067624) end(0x06764c)
function void fn067624()
{
	fn0679b8()
	Object.CountdownAndTrigger()

	objA0.position.x.u16 += 4
	if (objA0.position.x.u16 >= 512 - 320 + getScreenWidth())
	{
		objA0.base_state = 0x10
		u16[A0 + 0x3a] = (original_mode) ? 0x1f : 0x0f
	}
}


// Select which color is rendered on the palm tree's background at the miniboss cutscene
// and set the camera boundaries to accommodate Knuckles' new path.
//# address-hook(0x01c550) end(0x01c5c4)
function void fn01c550()
{
	if (original_mode)
	{
		fn01c550_Orig()
		return
	}

	A1 = 0x01c60a
	fn01caae()

	level.vertical_wrap = 0
	u16[0xfffffcde] = (palette_set >= 2 && !original_mode) ? 0x42c : 0x020e
	if ((global.game_mode & 0x80) == 0 && global.fade_timer == 0)
	{
		u16[0xfffffc5e] = (palette_set >= 2  && !original_mode) ? 0x42c : 0x020e	// this sets the red color used on some types of flowers
	}														 	// once the level fade-in is over (originally 0x020e)
	if (camera.position.x.u16 >= 0x2b00)
	{
		u16[0xfffffc5e] = 0x0004 // this changes the color again in the area of the hollow tree
	}
	if (camera.position.x.u16 >= 0x2c00)
	{
		level.vertical_wrap = 0x2e0 - getScreenHeightExtend()/2
	}
	if (camera.position.x.u16 >= 0x2d80)
	{
		u16[0xfffffc5e] = u16[0xfffffc76] // u16[0xfffffc5e] = (isMainCharacter(CHARACTER_KNUCKLES)) ? u16[0x04faea] : u16[0xfffffc76]	// second result was originally simply 0x0c02
													// this sets the color to use alongside the palm tree's leaves
		move_area.left = 0x2d80
		requestLoadingPatterns(0x5a)
		camera.update_routine += 2
	}

#if STANDALONE
	// Handling for Knuckles' new path
	if (objA0.position.x.u16 < 0x1880)
	{
//		if (isMainCharacter(CHARACTER_KNUCKLES))
//		{
			move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
			move_area.bottom.target = (objA0.position.x.u16 < 0x04e0) ? 0x0190 : 0x02a0 - getScreenHeightExtend()
			if (camera.position.x.u16 >= 0x1080)
				move_area.bottom.target = 0x01a0 - getScreenHeightExtend()
			level.vertical_wrap = 0x0000 // this is essentially move_area.top; Euka named it for 0xff00 allowing vertical wrapping
			if (camera.position.x.u16 >= 0x12e0 && camera.position.y.u16 >= 0x0280)
			{
				move_area.left = 0x12e0
				level.vertical_wrap = 0x0280 // this is essentially move_area.top; Euka named it for 0xff00 allowing vertical wrapping
				move_area.bottom.target = (camera.position.x.u16 < 0x1620) ? 0x0390 : 0x03b0
			}
		//	move_area.bottom.current = move_area.bottom.target
//		}
//		else
//		{
//			move_area.left = 0x12e0
//			level.vertical_wrap = 0x0280 // this is essentially move_area.top; Euka named it for 0xff00 allowing vertical wrapping
//		}
	}
#endif
}

function void fn01c550_Orig()
{
	A1 = 0x01c60a
	fn01caae()

	level.vertical_wrap = 0
	u16[0xfffffcde] = 0x20e
	if ((global.game_mode & 0x80) == 0 && global.fade_timer == 0)
	{
		u16[0xfffffc5e] = 0x020e
	}

	if (camera.position.x.u16 >= 0x2b00)
	{
		u16[0xfffffc5e] = 0x0004
	}
	if (camera.position.x.u16 >= 0x2c00)
	{
		level.vertical_wrap = 0x2e0
	}
	if (camera.position.x.u16 >= 0x2d80)
	{
		u16[0xfffffc5e] = isMainCharacter(CHARACTER_KNUCKLES) ? u16[0x04faea] : 0x0c02
		move_area.left = 0x2d80
		requestLoadingPatterns(0x5a)
		camera.update_routine += 2
	}

// #if STANDALONE
//	// Handling for Knuckles' new path
//	if (objA0.position.x.u16 < 0x1a00)
//	{
//		if (objA0.position.y.u16 < 0x0180)
//		{
//			move_area.left = 0x1680
//			move_area.bottom.target = (objA0.position.x.u16 < 0x1960) ? 0x0090 : 0x0390
//			move_area.bottom.current = move_area.bottom.target
//		}
//		else
//		{
//			move_area.left = 0x13a8
//		}
//	}
// #endif
}

// Adjust camera position in Knuckles's intro based on screen height.
// Move Knuckles' intro and set Sonic 2 title card variables.
// Functions come from level\07_mhz\intro_knuckles.lemon
//# address-hook(0x0634ca) end(0x063524)
function void fn0634ca()
{
	// New lines to prepare the camera for the new layout section.
	move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
	move_area.bottom.target = 0x0190 - getScreenExtend()
	move_area.bottom.current = move_area.bottom.target

	A1 = 0x0663de
	if (fn084fa4())
		return

	objA0.countdown_value = 0xef
	u8[0xffffb02e] = 0x83

#if STANDALONE
	Game.startSkippableCutscene()

	if (global.zone_act == 0x0000)
	{
//		if (Game.getSetting(SETTING_LEVELLAYOUTS) == 2)
		if (!original_mode)
		{
			objA0.position.x.u16 = 0x0361	// normally 0x17e1
			objA0.position.y.u16 = 0x0225	// normally 0x0125

			camera.position.x.u16 = 0x02e8	// normally 0x1768
			camera.position.y.u16 = 0x0190 - getScreenHeightExtend()	// normally 0x0290
		}
		else
		{
			objA0.position.x.u16 = 0x13f0
			objA0.position.y.u16 = 0x0425

			camera.position.x.u16 = 0x1390
			camera.position.y.u16 = 0x0380 + getScreenHeightExtend()
		}
	}
	else
#endif
	{
		camera.position.x.u16 = max(0x0540, 0x0560 - getScreenExtend())
		camera.position.y.u16 = 0x0948
	}
	player1.camera_lock = 0xff
	global.random.seed = global.framecounter
	global.level_started = 0

	if (allocDynamicObjectStd())
	{
		u32[A1] = 0x063682
	}

	// Spawn the 8 critters (with update routine 0x063694)
	spawnSimpleChildObjects(0x066656)

	copyMemory(0xfffffca0, 0x066a32, 0x20)
}

//# address-hook(0x06364e) end(0x06367c)
function void fn06364e()
{
	checkpoint.number = 1
	checkpoint.x = 0x06f4
	checkpoint.y = 0x09ec
#if STANDALONE
	if (global.zone_act == 0x0000)
	{
//		if (Game.getSetting(SETTING_LEVELLAYOUTS) == 2)
		if (!original_mode)
		{
			checkpoint.x = 0x03b0	// usually 0x1830
			checkpoint.y = 0x0219	// usually 0x0119
		}
		else
		{
			checkpoint.x = 0x1460
			checkpoint.y = 0x041a
		}
	}
#endif
	Checkpoint.SaveCurrentState()
	checkpoint.time = 0

#if !STANDALONE
	// This should already have been set to exactly this value...
	D0.u16 = 0x0700
	global.zone_act = D0.u16
	global.zone_act.apparent = D0.u16
#endif

#if STANDALONE
	Game.endSkippableCutscene()

	// Use this code for a direct start without fade to black (along with the "pointToReach" change above)
	bool manualCutsceneSkip = ((control.pad1.pressed & CONTROL_START) || (control.player2.pressed & CONTROL_START))
	if (global.zone_act == 0x0000 && !manualCutsceneSkip)
	{
		// Three new lines to prepare the camera for the new layout section.
		move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
		move_area.bottom.target = 0x0190
		move_area.bottom.current = move_area.bottom.target

		u32 backupA0 = A0

		u16[0xffffb010] = objA0.position.x.u16
		u16[0xffffb014] = objA0.position.y.u16
		s16[0xffffb018] = objA0.velocity.x
		s16[0xffffb01c] = objA0.velocity.x
		u8[0xffffb02e] = 0

		// Give Knuckles another update, to make sure he's rendered this frame at all
		A0 = 0xffffb000
		call objA0.update_address
		A0 = backupA0

		// Remove the critters, and the object that listens to CONTROL_START
		for (u32 address = 0xffffb128; address < 0xffffcfcb; address += 0x4a)
		{
			A1 = address
			if (objA1.update_address == 0x063682) // originally includes "objA1.update_address == 0x063720 || objA1.update_address == 0x063750 ||" to remove animals
			{
				unloadObjectAt(A1)
			}
		}

		// Load palette line 1 for enemies
		copyMemory(0xfffffc20, 0x0a8b7c, 0x20)

		player1.control_override = 0
		player1.camera_lock = 0
		fn0851e4()

		if (allocDynamicObjectStd())
		{
			// Show title card
			S2TitleCard.disappear = false
			S2TitleCard.loaded = false
			S2TitleCard.full = false
			objA1.update_address = 0x02d690
		}

		global.level_started = -0x6f	// Let HUD fly in
		hud.dirty.timer = 0x80
		timer.alldata = 0
		hud.dirty.lives = 0x01

		UnloadObject()

		// Spawn Tails
		if (getNumPlayers() > 1)
		{
			tails.respawn_counter = 60
			tails.ai_routine = 0x02
		}
	}
	else
#endif
	{
		S2TitleCard.disappear = false
		S2TitleCard.loaded = false
		S2TitleCard.full = true
		level.restart = 1
		Object.TriggerUnloading()
	}
}


// Adjust the AIZ1 camera boundaries for Knuckles.
// The AIZ1 Knux palette patch and the level palette for Sonic as his intro ends are also loaded here.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01c46e) end(0x01c4ce)
function void fn01c46e()
{
	if (original_mode)
	{
		base.fn01c46e()
		return
	}

	// new if statement for Knuckles
	if (isMainCharacter(CHARACTER_KNUCKLES) || (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02)))
	{
		move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
		move_area.bottom.target = (objA0.position.x.u16 < 0x04e0) ? 0x0190 - getScreenHeightExtend() : 0x02a0 - getScreenHeightExtend()
		if (camera.position.x.u16 >= 0x1080)
			move_area.bottom.target = 0x01a0 - getScreenHeightExtend()
		move_area.bottom.current = move_area.bottom.target
		// Change how palettes are loaded for Knuckles based on player palette choice
		if (palette_set < 2 || original_mode)
			Level.loadPaletteData(0x2a)
		else
			System.loadExternalRawData("Palette0000", 0xfffffca0)
	
		// Here is where the palette is patched for Knuckles.
		// A1 = 0xfffffc70
		// A2 = 0x04fae4	// load the palette patch
		// u32[(A1+=4)-4] = u32[(A2+=4)-4]
		// u32[A1] = u32[A2]
		
		#if STANDALONE
			// This serves as a small delay before Tails actually spawns
			tails.respawn_counter = 60
		#endif
		tails.ai_routine = 0x02

		camera.update_routine += 2
		return
	}
	
	u8[0xfffff72e] = 1
	if (camera.position.x.u16 >= 0x1000)
	{
		u8[0xfffff72e] = 0
		move_area.left = camera.position.x.u16
		if (u16[0xffffb010] == 0x13a0)	// AIZ1 start position for Sonic and Tails
			move_area.left = max(camera.position.x.u16, 0x12e0)		// max function and set value added to prevent ultrawide resolutions from showing garbage graphics to left.
		if (camera.position.x.u16 >= 0x1308 - getScreenExtend())	// Not exact, but works for 416px
		{
			if (checkpoint.number == 0 && isMainCharacter(CHARACTER_SONIC))
			{
				requestLoadingPatterns(0x0b)
			}
			
			Level.loadPaletteData(0x2a)

			// Make Tails fly in
			{
			#if STANDALONE
				// This serves as a small delay before Tails actually spawns
				tails.respawn_counter = 60
			#endif
				tails.ai_routine = 0x02
			}

			camera.update_routine += 2
		}
	}
}

//# address-hook(0x01c4d0) end(0x01c54e)
function void fn01c4d0()
{
	if (original_mode)
	{
		base.fn01c4d0()
		return
	}

//	move_area.left = 0x1308
//#if STANDALONE
	// Show a bit more to the left, that looks better in widescreen
	move_area.left = max(0x12e0, move_area.left - getScreenExtend())

	// new if statement for Knuckles
	if (isMainCharacter(CHARACTER_KNUCKLES))	// || (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02))
	{
		move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
		move_area.bottom.target = (objA0.position.x.u16 < 0x04e0) ? 0x0190 - getScreenHeightExtend() : 0x02a0 - getScreenHeightExtend()
		if (camera.position.x.u16 >= 0x1080)
			move_area.bottom.target = 0x01a0 - getScreenHeightExtend()
		move_area.bottom.current = move_area.bottom.target

//		if (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02))
//		{
//			checkpoint.number = 1
//			checkpoint.x = 0x03b0	// usually 0x1830
//			checkpoint.y = 0x0219	// usually 0x0119
//		}
	}

// #endif

	if (camera.position.x.u16 >= 0x12e0)	// usually 0x1400
	{
	#if STANDALONE
		// This additional check here is just one of many changes to make the Sonic intro being skipped correctly in Time Attack
		if (!time_attack)
	#endif
		if (checkpoint.number == 0 && isMainCharacter(CHARACTER_SONIC))
		{
			Kosinski.addToDecompressionQueue(0x3a458a, 0xffff9268)
			Kosinski.addToDMAQueue(0x3a944e, 0x17c0)

			u8[0xffffeec6] = 0xff
			u16[0xfffff7f0] = 0x500
			u16[0xfffff7f2] = 0x500
			u16[0xfffff7f4] = 0x500
		}

		// Switch to new checkpoint -- mainly for Sonic, so his intro gets skipped after death
		if (!isMainCharacter(CHARACTER_KNUCKLES)) // && !(isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] != 0xDA00 || u16[0xffffef7c] != 0xDA02))
		{
			checkpoint.number = 1
			checkpoint.x = 0x13a0
			checkpoint.y = 0x041a
			Checkpoint.SaveCurrentState()

		checkpoint.time = 0
		}
		requestLoadingPatterns(0x08)
		camera.update_routine += 2
	}
}



// Adjust Sonic 2 title card variables in the AIZ intros
// Function taken from level\01_aiz\intro_sonic.lemon
//# address-hook(0x061f10) end(0x061f5a)
function void fn061f10()
{
	if (objA0.render_flags & render_flag.VISIBLE)
	{
		Object.AnimationProgressByLocalA1()
		UpdateMovementStraightSimple()
		return
	}

	u8[0xfffff650] = 0
	player1.control_override = 0
	fn083c06()
	fn0851e4()

	if (allocDynamicObjectStd())
	{
		// Show title card
		S2TitleCard.disappear = false
		S2TitleCard.loaded = false
		S2TitleCard.full = false
		objA1.update_address = 0x02d690
	}

	global.level_started = -0x6f	// Let HUD fly in
	hud.dirty.timer = 0x80
	timer.alldata = 0
	hud.dirty.lives = 0x01
	Object.TriggerUnloading()

#if STANDALONE
	Game.endSkippableCutscene()
#endif
}

// Adjust a hardcoded screen height check to consider the actual screen height
//# address-hook(0x23b0d4) end(0x23b14e)
function void UpdateForegroundScrolling.AIZ1()
{
	A4 = 0x23b258
	A5 = 0xffffa808
	D1.u16 = water.height.current - camera.foreground.y.u16
	if (D1.s16 >= getScreenHeight())
	{
		fn239e8c()
	}
	else
	{
		--D1.u16
		fn239e90()

		u32 backupA1 = A1
		A1 = 0xffffa840
		A6 = 0x23a170
		D0.u16 = water.height.current
		D1.u16 = getScreenHeight() - 2 - D1.u16			// formerly 0xde - D1.u16 = screen height - 2
		D2.u16 = (level.framecounter + D0.u16 * 2) & 0x7e
		A6 += D2.u16
		D6.s16 = -s16(camera.foreground.x.u16)
		fn239e74()

		A1 = backupA1
		A2 = 0xffffa840
		A4 = 0x23b258
		A5 = 0xffffa808
		A6 = 0x23a3b0
		D0.u16 = water.height.current - camera.foreground.y.u16 + camera.background.y.u16
		D2.u16 = ((level.framecounter >> 1) + D0.u16 * 2) & 0x7e
		A6 += D2.u16
		fn239f18()
	}
}

// Adjust a hardcoded screen height check to consider the actual screen height
//# address-hook(0x239e8c) end(0x239e8c)
function void fn239e8c()
{
	D1.u16 = getScreenHeight() - 1	// formerly 0xdf = screen height - 1
	fn239e90()
}

// Remove AIR's behavior that adjusts chunks near the AIZ1 start.
//# address-hook(0x04f906) end(0x04f90e)
function void InitLevelTiles.AIZ1()
{
	AIZ1.ChangeBackgroundForKnuckles()
	
	// new if statement alters the camera settings for Knuckles' layout
	if (!original_mode && (isMainCharacter(CHARACTER_KNUCKLES)  || (isMainCharacter(CHARACTER_TAILS) && (u16[0xffffef7c] == 0xDA00 || u16[0xffffef7c] == 0xDA02))) && checkpoint.number == 0)
	{
		move_area.left = 0x0200	// normally 0x1680. Going further left loads some art from the intro.
		move_area.bottom.target = (objA0.position.x.u16 < 0x04e0) ? 0x0190 : 0x02a0
		move_area.bottom.current = move_area.bottom.target
	}

	Level.GetCameraPosition()
	Level.InitialTilesFill()

// #if STANDALONE
	// Update some chunks on the left of the start area that look broken
	// due with the border being a bit further left in S3AIR (see "fn01c4d0()")
//	for (u32 i = 0; i < 7; ++i)
//		u16[0xffff80ac + i * 0x61] = 0x64
// #endif
}

// Add a call in AIZ1 to draw the sprite to cover up the tree trunk to the right of the miniboss cutscene.
// Force proper drawing to the right of the hollow tree in case the camera is positioned slightly higher.
//# address-hook(0x04f912) end(0x04fa0a)
function void UpdateLevelTiles.AIZ1()
{
	AIZ1_CustomSprites()

	LoadTileContentDefault()

	if (camera.position.x.u16 >= 0x2d00 - getScreenWidth()/2 && !original_mode)
		fillPlaneA_Default(max(camera.foreground.x.u16, 0x2d80), camera.foreground.y.u16, getScreenWidth(), getScreenHeight())
	
	D0.u16 = u16[0xffffeec4]
	if (D0.u16 == 0)
		return

	// Handling of the hollow tree
	if (camera.position.x.u16 < 0x2d30 && D0.u16 < 0x39)
	{
		if (D0.u16 >= 0x34)
		{
			fn04f912_internal(0x04)
		}
		if (D0.u16 >= 0x24)
		{
			fn04f912_internal(0x08)
		}
		if (D0.u16 >= 0x14)
		{
			fn04f912_internal(0x0c)
		}

		A6 = (D0 & 0x01) ? 0x23ac4a : 0x23ac5a

		D0.u16 = (D0.u16 - 1) >> 1
		level.display_routine = min(D0.u16, 2)
		D0.s16 = 0x0470 - (D0.s16 << 4)

		while (true)
		{
			if (D0.u16 < camera.foreground.y.old)
			{
				A6 += 0x20
				D0.u16 += 0x10

				--level.display_routine
				if (level.display_routine & 0x80)
					break
			}
			else
			{
				D1.u16 = 0x2c80		// Tree left side's x-position
				D6 = 0x10

				u32 backupA0 = A0
				LoadTileContentSingleLine()
				A0 = backupA0

				D0.u16 -= 0x280
				D1 = 0
				D6 = 0x0f
				fn23ab96()

				A6 += 0x10
				D0.u16 += 0x290

				--level.display_routine
				if (level.display_routine & 0x80)
					return
			}
		}
	}

	u16[0xffffeec4] = 0
	fn04f912_internal(0x00)
	fn04f912_internal(0x04)
	fn04f912_internal(0x08)
	fn04f912_internal(0x0c)
}

function void AIZ1_CustomSprites()
{
	if (!original_mode && palette_set < 2)
		Renderer.drawCustomSprite("knuckles_intro_rocks_orig", 0x04d0 - camera.foreground.x.u16, 0x01f8 - camera.foreground.y.u16, 0, 0, 0x9dff)
	else if (!original_mode)
		Renderer.drawCustomSprite("knuckles_intro_rocks", 0x04d0 - camera.foreground.x.u16, 0x01f8 - camera.foreground.y.u16, 0, 0, 0x9dff)

	Renderer.drawCustomSprite("tree_base_cover", 0x30f0 - camera.foreground.x.u16, 0x0380 - camera.foreground.y.u16, 0, 0, 0x4001)

	if ((u32[0xfffffc6a] == 0x02ee0aee || u32[0xfffffc6a] == 0x04ee0cee) && getScreenHeightExtend() > 0)	// part of fire wall palette
	{
		AIZ.DrawFireWallImage()
	}
}

//# address-hook(0x04ff16) end(0x04ff22)
function void UpdateLevelTiles.AIZ2()
{
	AIZ2_CustomSprites()

	base.UpdateLevelTiles.AIZ2()
}

function void AIZ2_CustomSprites()
{
	if ((u32[0xfffffc6a] == 0x02ee0aee || u32[0xfffffc6a] == 0x04ee0cee) && getScreenHeightExtend() > 0)	// part of fire wall palette
	{
		AIZ.DrawFireWallImage()
	}
	if (getScreenHeightExtend() > 0)	// && unused.teleport_timer > 0)
	{
		if (camera.position.x.u16 > 0x3f00 && camera.position.x.u16 < 0x4600)
			Renderer.drawCustomSprite("aiz2_autoscrollterrainpatch", 0x4120, 0x0230, 0x00, SPRITE_FLAG_WORLDSPACE, 0x1fff)
		if (!global.game.paused && unused.teleport_timer > 0)
		{
			fillPlaneA_Default(camera.foreground.x.u16, camera.foreground.y.u16, getScreenWidth(), getScreenHeight())
			++unused.teleport_timer
			if (unused.teleport_timer >= 5)
				unused.teleport_timer = 0
		}
	}
}


// Set lower screen boundary for hollow tree and following cutscene based on screen height
//# address-hook(0x01caae) end(0x01caca)
function void fn01caae()
{
	D0.u16 = camera.position.x.u16 + getScreenExtend()
	while (true)
	{
		D1 = u32[(A1+=4)-4]
		if (D0.u16 <= D1.u16)
		{
		#if STANDALONE
			// Additional check for the area at the first Giant Ring
			//  -> Required for extended camera
			if (A1 == 0x01c612 && u16[0xffffb000 + 0x10] >= 0x1b80)
				continue
		#endif
			break
		}
	}
	D1 = (D1 << 16) + (D1 >> 16)
	if (D1.s16 < 0)
	{
		D1.u16 &= 0x7fff
		if (original_mode)
			move_area.bottom.current = D1.u16
	}
	move_area.bottom.target = D1.u16

	if (camera.position.x.u16 >= 0x2ad0)	// hollow tree and beyond
	{
		move_area.bottom.current = D1.u16 - getScreenHeightExtend()/2
		move_area.bottom.target = D1.u16 - getScreenHeightExtend()/2
	}
}

// If the screen height is extended, remove fire wall art from VRAM, as we use images instead
//# address-hook(0x01c5c6) end(0x01c600)
function void fn01c5c6()
{
	A1 = 0x01c60a
	fn01caae()
	move_area.left = camera.position.x.u16
	if (camera.position.x.u16 >= 0x2e00 && kosinski.waiting_modules == 0)
	{
		if (getScreenHeightExtend() <= 0)
			Kosinski.addToDMAQueue(0x3af5d0, 0xa000)
		else
		{
			VDP.setupVRAMWrite(0xa000)
			VDP.zeroVRAM(0xaf20 - 0xa000)
		}
		requestLoadingPatterns(0x0c)		// AIZ2 object sprites
		camera.update_routine += 2
	}
}


function void AIZ.DrawFireWallImage()
{
	u16 fireWallProgressOffset = (global.act == 0 || (level.display_routine != 0x0068 && camera.background.y.u16 >= 0x01c0)) ? 0x10 : 0x50
	for (u16 column = 0; column <= getScreenWidth()/16 + 8; ++column)
	{
		Renderer.drawCustomSprite(stringformat("aiz_firewall_%x", column & 0x07), (column * 0x10) - (camera.background.x.u16 - 0x1000), getScreenHeight() + fireWallProgressOffset - u16[0xffffeeec + ((column * 4) & 0x1f)], 0x00, SPRITE_FLAG_PRIO, 0xdffe)
	}
}

// Changes AIZ1 cutscene fire wall palette to include one more increment of blue
// Functions taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x04fbea) end(0x04fc42)
function void fn04fbea()
{
	// Check if fire wall got triggered
	if (u16[0xffffeec6] == 0)
	{
		UpdateBackgroundScrolling.AIZ1()
		fn04fbf6()
	}
	else
	{
		u16[0xffffeec6] = 0

		// Set fire wall palette
		A1 = 0xfffffc62
		u32[A1]   = (!original_mode) ? 0x024e026e : 0x004e006e
		u32[A1+4] = (!original_mode) ? 0x02ae02ce : 0x00ae00ce
		u32[A1+8] = (!original_mode) ? 0x04ee0cee : 0x02ee0aee

		camera.background.y = 0x0200000
		camera.background.y.old = 0x0010
		level.display_routine = 0x0068
		gfx.plane_update_routine = 0x04		// Enter vertical scroll mode
	#if STANDALONE
		verticalScrollOffsetBias = 0
	#endif
		level.scrolling_routine += 4

		fn04fc46()
	}
}

// Set the initial AIZ2 camera boundaries based on screen height.
// Duplicate palette check from above for Act 2 half of fire wall.
//# address-hook(0x04fd62)
function void fn04fd62()
{
	if (kosinski.waiting_modules == 0)
	{
		// Go to second part of act 1
		//  -> Technically, this is part of act 2 already
		global.zone_act = 0x0001
		camera.update_routine = 0
		dynobjects.routine = 0
		rings.update_routine = 0
		level.boss_encounter = 0
		global.in_extra_stage = 0
		fn04f8f8()

		push(A3)
		push(A2)
		push(A0)
		push(D7)

		fn01c362()
		fn0076a6()
		Level.InitializeWater()
		Level.loadPaletteData(0x0b)		// AIZ 2 level palette

		D7 = pop()
		A0 = pop()
		A2 = pop()
		A3 = pop()

		AIZ2.LevelInitSpecialty()

		// Set fire wall palette
		A1 = 0xfffffc62
		u32[A1]   = (!original_mode) ? 0x024e026e : 0x004e006e
		u32[A1+4] = (!original_mode) ? 0x02ae02ce : 0x00ae00ce
		u32[A1+8] = (!original_mode) ? 0x04ee0cee : 0x02ee0aee

		D0.u16 = 0x2f00
		D1.u16 = 0x80
		u16[0xffffb000 + 0x10] -= D0.u16
		u16[0xffffb000 + 0x14] -= D1.u16
		u16[0xffffb04a + 0x10] -= D0.u16
		u16[0xffffb04a + 0x14] -= D1.u16
		fn04f3a0()

		camera.position.x.u16 -= D0.u16
		camera.position.y.u16 -= D1.u16
		camera.foreground.x.u16 -= D0.u16
		camera.foreground.y.u16 -= D1.u16
		move_area.left = 0x10
		move_area.right = 0x10 + getScreenExtend() * 2
		u32[0xffffee18] = 0x0260
		move_area.bottom.target = 0x0260 - getScreenHeightExtend()/2
		u16[0xffffeeb4] = camera.foreground.x.u16
		u16[0xffffeeb6] = camera.foreground.x.u16
		Level.GetCameraPosition()

		u16[0xffffeec8] = (D0.u16 + getScreenHeight()) & level.height.tilemask
		u16[0xffffeeca] = 0x0f
		level.scrolling_routine = 0

	#if STANDALONE
		// There's a glitch here that is both hard to reproduce and tricky to solve.
		// You have to jump at the start of the fire wall moving and land right when the chunks gets exchanged.
		// There are a few frames between the change of chunk contents and the loading of the chunk layouts (the latter happens right above).
		// If you're falling down fast enough, you can basically glitch through the temporarily messed up collision.
		// As a workaround, just check if the main character glitched through, and reposition him.
		if (u16[0xffffb000 + 0x14] > 0x02fc && !original_mode)
		{
			u16[0xffffb000 + 0x14] = 0x02fc
			u16[0xffffb000 + 0x1a] = 0
		}
	#endif
	}

	fn23b17a()
	WriteScrollOffsets()
}

// Replace hardcoded screen heights for burning AIZ1/AIZ2 foreground/background
// scrolling and water ripple code with flexible ones.
//# address-hook(0x23b680) end(0x23b772)
function void fn23b680()
{
	A1 = 0xffffa800
	A6 = 0x23bc5a
	D0.u16 = camera.foreground.y.u16
	D1.u16 = getScreenHeight() - 1	// formerly 0xdf = screen height - 1
	D2.u16 = level.framecounter + D0.u16 * 2
	D3 = 0x3e
	D6.s16 = -s16(camera.foreground.x.u16)
	if (water.height.current > D0.u16)
	{
		D4.u16 = water.height.current - D0.u16
		if (D4.u16 <= D1.u16)
		{
			D1.u16 = D4.u16 - 1
			D2.u16 &= D3.u16
			A6.u16 += D2.u16
			fn239e74()

			D0.u16 = water.height.current
			D1.u16 = getScreenHeight() - 2 - D1.u16			// formerly 0xde - D1.u16 = screen height - 2 - D1.u16
			D2.u16 = level.framecounter + D0.u16 * 2
			A6 = 0x23a170
			D3 = 0x7e
		}
	}
	else
	{
		D4.u16 = water.height.current - D0.u16	// Still needed?
		A6 = 0x23a170
		D3 = 0x7e
	}

	D2.u16 &= D3.u16
	A6.u16 += D2.u16
	fn239e74()

	A1 = 0xffffe000		// Location of linewise scroll offsets
	A2 = 0xffffa800
	A4 = 0x23bc06
	A5 = 0xffffa9c0 + (2 * getScreenHeightExtend())
	A6 = 0x23be5a
	D0.u16 = camera.background.y.u16
	D1.u16 = getScreenHeight() - 1	// formerly 0xdf = screen height - 1
	D2.s16 = s16(level.framecounter) >> 1
	D2.u16 += D0.u16 * 2
	D3 = 0x3e
	if (water.height.current > camera.foreground.y.u16)
	{
		D4.u16 = water.height.current - camera.foreground.y.u16
		if (D4.u16 <= D1.u16)
		{
			D1.u16 = D4.u16 - 1
			D2.u16 &= D3.u16
			A6.u16 += D2.u16
			fn239f18()

			A4 = 0x23bc06
			A5 = 0xffffa9c0 + (2 * getScreenHeightExtend())
			D0.u16 = water.height.current - camera.foreground.y.u16 + camera.background.y.u16
			D1.u16 = getScreenHeight() - 2 - D1.u16			// formerly 0xde - D1.u16 = screen height - 2 - D1.u16
			D2.u16 = s16(level.framecounter) >> 1
			D2.u16 += D0.u16 * 2
			A6 = 0x23a3b0
			D3 = 0x7e
		}
	}
	else
	{
		D4.u16 = water.height.current - camera.foreground.y.u16	// Still needed?
		A6 = 0x23a3b0
		D3 = 0x7e
	}

	D2.u16 &= D3.u16
	A6.u16 += D2.u16
	fn239f18()

	if (u16[0xffffeed6] != 0)
	{
		A1 = 0xffffe000		// Location of linewise scroll offsets
		D0.s16 = -s16[0xffffee98]
		for (u8 i = 0; i < 0x40; ++i)
		{
			u16[A1] = D0.u16
			A1 += 4
		}
	}
}

//# address-hook(0x23b626) end(0x23b67e)
function void fn23b626()
{
	D0.s16 = s16(camera.foreground.y.u16 - camera.screenshake.offset) >> 1
	camera.background.y.u16 = camera.screenshake.offset + D0.s16
	if (level.scrolling_routine >= 0x10)
	{
		camera.background.y.u16 += u16[0xffffeee8]
	}
	D0 = s32(u32(u16[0xffffeeb6]) << 16) >> 1
	D1 = (D0.s32 >> 5) * 3

	A1 = 0xffffa9c0 + (2 * getScreenHeightExtend())
	A5 = 0x23bc38
	while (true)
	{
		D3.u8 = u8[A5]
		++A5
		if (D3.s8 < 0)
			break

		for (s16 i = 0; i <= D3.s8; ++i)
		{
			D2 = u8[A5]
			++A5
			u16[A1 + D2.u16] = D0 >> 16
		}
		D0 += D1
	}
}

// Prevent AIZ heat wave and water ripple offset application from going out of the
// data's bounds by returning to a previous iteration when necessary.
//# address-hook(0x239e74) end(0x239e8a)
function void fn239e74()
{
	for (u16 i = 0; i <= D1.u16; ++i)
	{
		if (i == 0x40 && !original_mode)			// the heat/ripple data repeats every 0x80 bytes,
			A6 -= (0x40 * 2)	// and A6, the offset pointer, advances by 2 each repeat.
		u16[A1] = u16[A6] + D6.u16
		A1 += 2
		A6 += 2
	}
}

// Despite Euka's comment, this function is used for all linewise scroll offsets in burning AIZ1/AIZ2.
// As with the heat/ripple data, data here repeats every 0x80 bytes.
// When we reach the scroll offset at 0xffffe380, beyond what 224px screen height needs, adjust the pointer
// to not go beyond the data's end.
//# address-hook(0x239f18) end(0x239fb2)
function void fn239f18()
{
	// This function sets line offsets in water in AIZ 1
	D7 = (D7 << 16) + (D7 >> 16)
	D3 = (D3 << 16) + (D3 >> 16)

	while (true)
	{
		D3.u16 = u16[(A4+=2)-2]
		D7.u8 = (D3.s16 < 0) ? 0xff : 0x00
		D3.u16 &= 0x7fff
		D0.u16 -= D3.u16
		if (D0.s16 < 0)
			break

		if (D7.u8 == 0)
		{
			A5 += 2
		}
		else
		{
			A5.u16 += D3.u16 * 2
		}
	}

	if (D7.u8 != 0)
	{
		D3.u16 = (D3.u16 + D0.u16) * 2
		A5.u16 += D3.u16
	}

	D3 = (D3 << 16) + (D3 >> 16)
	D0.s16 = -D0.s16
	D4.u16 = D1.u16 - D0.u16
	if (D4.s16 < 0)
	{
		D0.u16 = D1.u16
	}
	else
	{
		--D0.u16
	}

	while (true)
	{
		if (D7.u8 != 0)
		{
			while (D0.s16 >= 0)
			{
				D6.u16 = u16[(A2+=2)-2]
				D6 = (D6 << 16)
				if (A1 == 0xffffe380 && !original_mode)	// first offset beyond what 224px screen height uses
					A6 -= 0x80							// shift pointer to earlier in the repeating data
				D6.u16 = u16[(A6+=2)-2] - s16[(A5+=2)-2]
				u32[(A1+=4)-4] = D6
				--D0.s16
			}
		}
		else
		{
			D5.s16 = -s16[(A5+=2)-2]
			while (D0.s16 >= 0)
			{
				D6.u16 = u16[(A2+=2)-2]
				D6 = (D6 << 16)
				if (A1 == 0xffffe380 && !original_mode)	// first offset beyond what 224px screen height uses
					A6 -= 0x80							// shift pointer to earlier in the repeating data
				D6.u16 = u16[(A6+=2)-2] + D5.u16
				u32[(A1+=4)-4] = D6
				--D0.s16
			}
		}

		if (D4.s16 < 0)
			break

		D0.u16 = u16[(A4+=2)-2]
		D7.u8 = (D0.s16 < 0) ? 0xff : 0x00
		D0.u16 &= 0x7fff

		D5.u16 = D4.u16
		D4.u16 -= D0.u16
		if (D4.s16 < 0)
		{
			D0.u16 = D5.u16
		}
		else
		{
			--D0.u16
		}
	}
	D7 = (D7 << 16) + (D7 >> 16)
}

// Adjust the lower screen boundary for the AIZ1 boss (two locations) based on screen height.
// AIZ1 boss (actual, not cutscene): direct time attack check from base game to use DAGE time attack flag.
// Also make boss position character dependent in Original Mode -- yes, this reintroduces the original game's softlock.
// Function taken from level\01_aiz\level_aiz.lemon
#if STANDALONE
function void AIZ1a.checkPreBossArea()
{
	// Skip check for boss
//	if (time_attack)
//		return

	// Using the upper or the lower path?
	bool isOnUpperPath = (camera.position.y.u16 < 0x400)
	if (original_mode)
		isOnUpperPath = !isMainCharacter(CHARACTER_KNUCKLES)

	if (isOnUpperPath)
	{
		D0.u16 = (camera.position.x.u16 >= 0x0f00) ? 0x02b8 - getScreenHeightExtend() : 0x0590	// camera x usually checked against 0x0ed0
	}
	else
	{
		D0.u16 = (camera.position.x.u16 >= 0x0f00) ? 0x0450 - getScreenHeightExtend() : 0x0590	// camera x usually checked against 0x0e80
	}
	move_area.bottom.current = D0.u16
	move_area.bottom.target = D0.u16

	if (isOnUpperPath)
	{
		if (camera.position.x.u16 >= 0x0f50)
		{
			move_area.left = 0x0f50
			// Choose boss area depending on which route has been taken, not the character selection
			//  -> Search for this same comment to find another place with similar code
			move_area.right = ((camera.position.y.u16 >= 0x03a0) ? 0x10c0 : 0x10e0) + getScreenExtend()

			if (debug_mode.state == 0 && time_attack != 1 && time_attack != 2)	// make time attack check later than base game to set camera y value nicely
			{
				if (allocDynamicObjectStd())
				{
					// Trigger boss
					objA1.update_address = 0x068a24
					objA1.position.x.u16 = 0x11f0
					objA1.position.y.u16 = 0x0289
				}
			}
			camera.update_routine = 0x06
		}
	}
	else
	{
		if (camera.position.x.u16 >= 0x1040)
		{
			move_area.left = 0x1040
			if (debug_mode.state == 0)
			{
				if (allocDynamicObjectStd() && time_attack != 1 && time_attack != 2)	// make time attack check later than base game to set camera y value nicely
				{
					// Trigger boss
					objA1.update_address = 0x068a24
					objA1.position.x.u16 = 0x11d0
					objA1.position.y.u16 = 0x0420
				}
			}
			water.height.target = 0x0f80
			camera.update_routine = 0x16
		}
	}
}
#endif

//# address-hook(0x01c6dc) end(0x01c6f4)
function void fn01c6dc()
{
	if (camera.position.x.u16 >= 0x1500)
	{
		move_area.bottom.current = 0x0630 - getScreenHeightExtend()
		move_area.bottom.target = 0x0630 - getScreenHeightExtend()
		camera.update_routine += 2
	}
}

// Adjust the lower camera boundary on Knuckles's route based on screen height.
// We'll actually comment this out so grass terrain isn't touching the screen's lower boundary
// when the screen height is extended.
// //# address-hook(0x01c80a) end(0x01c81c)
// function void fn01c80a()
// {
//	if (camera.position.x.u16 >= 0x11a0)
//	{
//		move_area.bottom.target = 0x0820 // - getScreenHeightExtend()
//		camera.update_routine += 2
//	}
// }

// Match this water level change check to the above lower camera boundary.
// Change AIZ2's water to be path-dependent rather than character-dependent
// to better support future mods.
// Chaos the Imposter does not need this; it handles it on its own.
// Function taken from level\level_water.lemon
//# address-hook(0x006dde) end(0x006e6c)
function void UpdateWaterSurfaceLevel.AIZ2()
{
	if (camera.position.y.u16 < 0x0f80) // (isMainCharacter(CHARACTER_KNUCKLES))
	{
		if (move_area.bottom.target == 0x0820 - getScreenHeightExtend() || camera.position.x.u16 >= 0x3b60)
			return
	}

	// Somewhere in here:
	//  - Lower water level
	//  - Cause screen shake to start

	if (camera.position.x.u16 < 0x2440)
	{
		if (water.height.target == 0x0618)
		{
			water.height.target = 0x0528
			water.height.changerate = 2
		}
	}
	else
	{
		if (level.trigger00 == 0)
		{
			if (camera.position.x.u16 < 0x2850)
				return

			level.trigger00 = 1
		}

		if (water.height.target != 0x0618)
		{
			if (camera.position.x.u16 < 0x2900)
			{
				camera.screenshake.state = 0xffff
				if (allocDynamicObjectStd())
				{
					objA1.update_address = 0x006e6e
					u8[A1 + 0x24] = 0xb4
				}
			}

			A3 = 0xffff8024
			D1 = 4
			while (D1 > 0)
			{
				A1 = 0xffff0000 + u16[A3]
				u8[A1 + 0x4e] = 0
				A3 += 4
				--D1
			}
			water.height.target = 0x0618
			// Enforce a full screen refresh of plane A to get rid of wrong waterfall tiles possibly being shown
			fillPlaneA_Default(camera.position.x.u16, camera.position.y.u16, getScreenWidth(), getScreenHeight())
		}
	}
}


// Adjust when the upper camera lock starts when exiting the tunnel before the airship sequence.
// At wider than 400px, we need a more accurate condition for camera locking.
// We also set the value in accordance with the screen height.
// Function taken from level\01_aiz\level_aiz.lemon
//# address-hook(0x01c746) end(0x01c75e)
function void fn01c746()
{
	if (original_mode)
	{
		base.fn01c746()
		return
	}
	if (u16[0xffffb010] >= 0x3fce && u16[0xffffb014] < 0x01c0)
	{
		D0.u16 = 0x015a - getScreenHeightExtend()
		level.vertical_wrap = D0.u16
		move_area.top.target = D0.u16
		camera.update_routine += 2
	}
}

// When even closer to the airship sequence, set the lower camera lock appropriately.
//# address-hook(0x01c760) end(0x01c778)
function void fn01c760()
{
	if (camera.position.x.u16 >= 0x4000)
	{
		D0.u16 = 0x015a - getScreenHeightExtend()
		move_area.bottom.current = D0.u16
		move_area.bottom.target = D0.u16
		camera.update_routine += 2
	}
}

// Load the extra background trees between the airship and the boss
// at an appropriate y position when the screen height is altered.
//# address-hook(0x050664) end(0x050684)
function void fn050664()
{
	objA0.update_address = 0x05068a
	objA0.sprite_attributes = 0x0438
	objA0.mapping_offset = 0x23c248
	objA0.position.y.u16 = 0xe9 + getScreenHeightExtend()
	objA0.countdown_value = 0x01c0
	u16[A0 + 0x30] = u16[0xffffeeb6] + getScreenExtend() * 3	// Screen width dependency is just trial-and-error here
	fn05068a()
}

// Set screen lock appropriately when approaching Knuckles's AIZ2 boss.
//# address-hook(0x01c81e) end(0x01c868)
function void fn01c81e()
{
	if (camera.position.x.u16 >= 0x3b80 && kosinski.waiting_modules == 0)
	{
		Kosinski.addToDecompressionQueue(0x3b1372, 0xffff9ab8)
		Kosinski.addToDMAQueue(0x3b48c6, 0x3f80)

		Level.loadPaletteData(0x30)		// AIZ 2 bombing scene palette

		move_area.left = 0x3b80
		move_area.bottom.target = 0x05da - getScreenHeightExtend()
		if (!original_mode)
			level.vertical_wrap = 0x05da - getScreenHeightExtend()	// new line here disallows upward camera movement
		u8[0xffffeec6] = 0xff
		camera.update_routine += 2
	}
}

// Disable bomber in time attack modes.
// Don't call some scrolling code if the screen height is extended.
//# address-hook(0x04ff3a) end(0x04ff70)
function void fn04ff3a()
{
	if (u16[0xffffeec4] == 0 || time_attack == 1 || time_attack == 2)
	{
		LoadTileContentDefault()
		return
	}

	// This code is only reached in the blimp sequence before AIZ 2 boss

	if (getScreenHeightExtend() <= 0)
	{
		u16[0xffffeec4] = 0
	}
	u16[0xffffeec8] = 0x0180
	u16[0xffffeeca] = 0x05
	u32[0xffffa9f8] = 0
	u16[0xffffa9fe] = (camera.foreground.x.u16 & 0xfff0) - 0x10
	player1.camera_lock = 0xff
	level.special_scrolling = 0x04
	u16[0xffffeec0] += 4

	fn04ff74()
}

// We make some corrections here for the blimp scrolling at extended screen heights
// and set a timer for screen redrawing to correct some issues.
//# address-hook(0x04ff74) end(0x050052)
function void fn04ff74()
{
	D1.u16 = 0x4380
	D2.u16 = camera.foreground.y.u16 - 0x10

	fn04ef56()
	if (_negative())
	{
		D0.u16 = 0x4020
		u16[0xffffa9f6] = D0.u16
		u32[0xffffee98] = (D0.u16 - getScreenExtend() / 2) << 16
		D0.u16 = (camera.foreground.y.u16 + 0x8f0) & level.height.tilemask
		u16[0xffffee9c] = D0.u16
		u16[0xffffeea2] = D0.u16

		if (allocDynamicObjectStd())
		{
			// Spawn Blimp
			objA1.update_address = 0x05034a
		}

		// Set a timer to determine when to use fillPlaneA_Default() to redraw screen oddities from the unique scrolling here
		if (getScreenHeightExtend() > 0)
		{
			fillPlaneA_Default(camera.foreground.x.u16, camera.foreground.y.u16, getScreenWidth() + 16, getScreenHeight())
			unused.teleport_timer = 1
		}

		// Configure H-Int to set a different scroll-y offset in between
		//  -> Namely the one in "camera.foreground.y.u16"
		else
		{
			u8[0xffffeed6] = 0xff
		}
		irq_table.lineupdate = 0x050056
		level.water_present = 0
		h_int.line = 0x40
		u16[0xffffeec0] += 4

		fn04ffd4()
	}
	else
	{
		fn04fff0()
	}
}

// Do not call a drawing function for AIZ2 blimp plane rendering if the screen height is extended
function void fn04fff0()
{
	A4 = 0x050072
	A6 = 0xffffa9f8
	u16[A6 + 4] = camera.foreground.x.u16
	D5 = 2
	D6.u16 = camera.foreground.y.old
	if (getScreenHeightExtend() <= 0)
		fn04ee20()
}

// Adjust how the pre-boss looping area is handled at screen heights above 224.
//# address-hook(0x05001c)
function void fn05001c()
{
	D1.u16 = 0x4380
	D2.u16 = camera.foreground.y.u16 - 0x10

	fn04ef56()
	if (_negative())
	{
		D0.u16 = (camera.foreground.x.u16 & 0xfff0) - 0x10
		camera.foreground.x.old = D0.u16
		if (getScreenHeightExtend() <= 0)
		{
			u16[0xffffeed4] = 0x46c0
		}
		u16[0xffffeed6] = 0
		h_int.line = 0xff
		u16[0xffffeec0] += 4
		LoadTileContentDefault()
	}
	else
	{
		fn04fff0()
	}
}

// Correct chunks at the horizontal wrap point within the trees before the boss
// to account for our scrolling changes and wider screen resolution.
//# address-hook(0x0500e6) end(0x0500e6)
function void fn0500e6()
{
	if (camera.position.x.u16 >= 0x4600)
	{
		u32[0xffff8242] = 0xeaeaeaea
		u16[0xffff8246] = 0xeaea
		u32[0xffff82da] = 0xe9e9e9e9
		u16[0xffff82de] = 0xe9e9
		u32[0xffff8372] = 0xe8e8e8e8
		u16[0xffff8376] = 0xe8e8
	}

	base.fn0500e6()
}

// Have the main blimp controller object render an image of the blimp when the screen height is extended.
// We also need to shift the blimp back a bit in the original bombing sequence, else it hurts player
// characters running full speed.
// Also enforce the base game bombing in Original Mode.
//# address-hook(0x050390) end(0x050424)
function void fn050390()
{
	if (getScreenHeightExtend() <= 0)
	{
		fn050390_NormalHeight()
		return
	}
	
	// Blimp movement
#if STANDALONE
	if (time_attack >= 3 || ((Game.getSetting(SETTING_AIZ_BLIMPSEQUENCE) && !original_mode)))
	{
		u32[0xffffee98] -= 0x10000
	}
	else
	{
		u32[0xffffee98] -= 0x8800 + ((getScreenExtend() / 4) << 8)
	}
#else
	u32[0xffffee98] -= 0x8800
#endif

	bool bomberEnded = false	// We don't want to stop drawing the bomber before it's completely off screen.
	if (u16[0xffffee98] < 0x3cdc)
	{
		u16[0xffffeed4] = 0x46c0
		objA0.update_address = 0x0506be
		u8[0xffffeec4] = 0xff
		if (allocDynamicObjectAfterA0())
		{
			// Spawn the tree spawner
			objA1.update_address = 0x050614
		}
		bomberEnded = true
	//	return
	}

	D1.u16 = u16[0xffffee98]
	D0.u16 = u16[0xffffee98] - 0x3d5c
	if (D0.s16 < 0)
	{
		u16[0xffffee9c] = u16[0xffffeea2] + ((-D0.s16) >> 1)
	}
	else
	{
		D1.u16 = (D1.u16 >> 2) & 0x0f
		u16[0xffffee9c] = u16[0xffffeea2] + u8[0x23c096 + D1.s16]
	}

	u16 bomberOffset = Game.getSetting(SETTING_AIZ_BLIMPSEQUENCE) ? 0 : 20
	Renderer.drawCustomSprite("aiz2_bomber", 0x3d80 - u16[0xffffee98] - bomberOffset, 0x0a00 - u16[0xffffee9c], 0x00, SPRITE_FLAG_PRIO, 0x9f7b)
	if (bomberEnded)
	{
		// Leverage some scratch RAM to track the bomber as it goes offscreen
		unused.player2.total_rings = u16[0xffffee98]
		unused.player2.item_count = u16[0xffffee9c]
		return
	}

	D0.u16 = (level.framecounter - 1) & 0x0f
	if (D0.u16 == 0)
	{
		playSound(0xbd)
	}

	--s16[A0 + 0x32]
	if (s16[A0 + 0x32] == -1)	// Do not check for (s16[A0 + 0x32] < 0) here, as this would lead to different behaviour
	{
		// Table with bomb spawn data from 0x23c0a6 on;
		// consists of 21 entries with the following 2 words each:
		//  - Frames until next bomb drop (0x20 or 0x40)
		//  - Position offset, e.g. 0x3f5c
		A2 = u32[A0 + 0x2e]
		objA0.value32 = u16[A2]

		if (s16[A0 + 0x32] >= 0)
		{
			if (allocDynamicObjectAfterA0())
			{
				// Spawn bomb
				objA1.update_address = 0x05047c
				u16[A1 + 0x2e] = u16[A2+2]

				u32[A0 + 0x2e] += 4
			}
		}
	}
}

function void fn050390_NormalHeight()
{
	// Blimp movement
#if STANDALONE
	if (time_attack >= 3 || (Game.getSetting(SETTING_AIZ_BLIMPSEQUENCE) && !original_mode))
	{
		u32[0xffffee98] -= 0x10000
	}
	else
	{
		u32[0xffffee98] -= 0x8800 + ((getScreenExtend() / 4) << 8)
	}
#else
	u32[0xffffee98] -= 0x8800
#endif

	if (u16[0xffffee98] < 0x3cdc)
	{
		objA0.update_address = 0x0506be
		u8[0xffffeec4] = 0xff
		if (allocDynamicObjectAfterA0())
		{
			// Spawn the tree spawner
			objA1.update_address = 0x050614
		}
		return
	}

	D1.u16 = u16[0xffffee98]
	D0.u16 = u16[0xffffee98] - 0x3d5c
	if (D0.s16 < 0)
	{
		u16[0xffffee9c] = u16[0xffffeea2] + ((-D0.s16) >> 1)
	}
	else
	{
		D1.u16 = (D1.u16 >> 2) & 0x0f
		u16[0xffffee9c] = u16[0xffffeea2] + u8[0x23c096 + D1.s16]
	}

	D0.u16 = (level.framecounter - 1) & 0x0f
	if (D0.u16 == 0)
	{
		playSound(0xbd)
	}

	--s16[A0 + 0x32]
	if (s16[A0 + 0x32] == -1)	// Do not check for (s16[A0 + 0x32] < 0) here, as this would lead to different behaviour
	{
		// Table with bomb spawn data from 0x23c0a6 on;
		// consists of 21 entries with the following 2 words each:
		//  - Frames until next bomb drop (0x20 or 0x40)
		//  - Position offset, e.g. 0x3f5c
		A2 = u32[A0 + 0x2e]
		objA0.value32 = u16[A2]

		if (s16[A0 + 0x32] >= 0)
		{
			if (allocDynamicObjectAfterA0() && u16[A0 + 0x30] != 0x7fff)
			{
				// Spawn bomb
				objA1.update_address = 0x05047c
				u16[A1 + 0x2e] = u16[A2+2]

				u32[A0 + 0x2e] += 4
			}
		}
	}
}

// Align bombs and propellors with the image of the bomber in the original sequence
//# address-hook(0x050586) end(0x0505a2)
function void fn050586()
{
	objA0.position.x.u16 = objA0.countdown_value - u16[0xffffee98] + camera.foreground.x.u16
	if (getScreenHeightExtend() > 0 && !Game.getSetting(SETTING_AIZ_BLIMPSEQUENCE))
	{
		objA0.position.x.u16 -= 20
	}
	objA0.position.y.u16 = D0.u16 + camera.screenshake.offset - camera.screenshake.prev_offset
}

// Set the height for Eggman flying behind trees before the boss based on screen height
//# address-hook(0x0506be) end(0x0506fc)
function void fn0506be()
{
	objA0.update_address = 0x050700
	objA0.sprite_priority = 0x0300
	objA0.sprite_attributes = 0x0500
	objA0.mapping_offset = 0x23c264
	objA0.position.x.u16 = 0x30
	objA0.position.y.u16 = 0xd8 + 2*getScreenHeightExtend()
	objA0.velocity.x = 0x05
	objA0.countdown_value = 0

	copyMemory(0xfffffc22, 0x23c07a, 0x1c)
	fn050700()
}

// The bomber needs more time than usual to get off screen with an extended screen height.
// Continue to draw it and move it as the player character approaches the trees.
//# address-hook(0x050700) end(0x05077c)
function void fn050700()
{
	if (getScreenHeightExtend() <= 0)
	{
		base.fn050700()
		return
	}
	
	if (level.framecounter.low % 2 == 0)
		unused.player2.total_rings -= 1
	if (level.framecounter.low % 4 == 0)
		unused.player2.item_count += 1
	u16 bomberOffset = Game.getSetting(SETTING_AIZ_BLIMPSEQUENCE) ? 0 : 20
	Renderer.drawCustomSprite("aiz2_bomber", 0x3d80 - (unused.player2.total_rings) - bomberOffset, 0x0a00 - (unused.player2.item_count), 0x00, SPRITE_FLAG_PRIO, 0x9f7b)

	base.fn050700()
}

// Change when propellors despawn if the screen height is extended
//# address-hook(0x050458) end(0x050476)
function void fn050458()
{
	if ((u16[0xffffeec0] == 0x0c && getScreenHeightExtend() <= 0) || unused.player2.item_count > 0)
	{
		UnloadObject()
	}
	else
	{
		Object.animationUpdate(0x23c1aa)
		fn05057a()
		DrawObject()
	}
}
