// Extend teleporter beams to the bottom of the screen at all screen heights.
// Fix issues positioning teleport beams when moving across the vertical wrap point.
// Function taken from objects\level\teleporter.lemon
//# address-hook(0x0459b4) end(0x045a64)
function void fn0459b4()
{
	if (level.framecounter.low & 0x01)
	{
		// Update position of the beam
		D0.u16 = min(u16[A0 + 0x44], camera.position.y.u16 + 0x68 + getScreenHeightExtend())
		if (camera.position.y.u16 + 0x68 + getScreenHeightExtend() > 0x0d80 && !original_mode)	// we're coming up from the bottom of the camera boundaries via vertical wrap
			D0.u16 = (camera.position.y.u16 + 0x68 + getScreenHeightExtend()) & 0x0fff
		objA0.position.y.u16 = D0.u16

		D1.u16 = objA0.position.x.u16
		D2 = u8[A0 + 0x46]
		D3.u16 = D2.u16
		D2.u16 = min(D2.u16, 0x12) + 6
		D3.u16 <<= 3

		A1 = (global.zone == 0x0a || global.zone == 0x16) ? 0x046734 : 0x0467fc
		A1.u16 += D3.u16
		A2 = A0 + 0x18
		u16[A2]    = D1.u16 - D2.u16
		u16[A2+2]  = u16[A1] + D0.u16
		u16[A2+4]  = u16[A1+2]
		u16[A2+6]  = D1.u16 + D2.u16
		u16[A2+8]  = u16[A1+4] + D0.u16
		u16[A2+10] = u16[A1+6]
		A2 += 12

		if (objA0.base_state != 0)
		{
			--u8[A0 + 0x46]
			if (s8[A0 + 0x46] >= 0)
			{
				DrawObject()
				return
			}

			objA0.animation.sprite = 0x09
			u16[A0 + 0x16] = 0
			objA0.update_address = addressof(UnloadObject)
			A1 = 0xffff0000 + objA0.respawn_entry
			u8[A1 + 0x38] = 0
		}
		else
		{
			if (level.framecounter.low & 0x02)
			{
				if (u8[A0 + 0x46] < 0x18)
				{
					++u8[A0 + 0x46]
				}
			}
		}
		DrawObject()
	}
}
