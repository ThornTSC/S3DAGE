global bool clean_screenshot = 0

// Show version number on Challenge/Marathon end screens.
// This function assumes Letters.Main() has already been called.
function void PrintVersionNumber()
{
	Letters.Main()

	u16 px = 16

	// Many of these checks are older than mod.json allows, but in case somebody tries to mod around that, it's left for posterity.

	#if GAMEAPP == 0x21092800	// v21.09.28.0 stable
		if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
			px = getScreenWidth() - 16 - 91			// 16 pixels away from right edge, A.I.R. version number is 91 pixels long
		Letters.Show("``DAGE v1.8.1.1`A.I.R. v21.09.28.0", 1, px, 193)
		return
	#endif
	#if GAMEAPP == 0x22051500	// v22.05.15.0 preview
		if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
			px = getScreenWidth() - 16 - 91			// 16 pixels away from right edge, A.I.R. version number is 91 pixels long
		Letters.Show("``DAGE v1.8.1.1`A.I.R. v22.05.15.0", 1, px, 193)
		return
	#endif
	#if GAMEAPP == 0x22070300	// use for old test version
		if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
			px = getScreenWidth() - 16 - 91			// 16 pixels away from right edge, A.I.R. version number is 91 pixels long
		Letters.Show("``DAGE v1.8.1.1`A.I.R. v22.07.03.0", 1, px, 193)
		return
	#endif
	#if GAMEAPP == 0x22082700	// use for latest preview version
		if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
			px = getScreenWidth() - 16 - 91			// 16 pixels away from right edge, A.I.R. version number is 91 pixels long
		Letters.Show("``DAGE v1.8.1.1`A.I.R. v22.08.27.0", 1, px, 193)
		return
	#endif
	#if GAMEAPP == 0x22091000	// use for latest stable version
		if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
			px = getScreenWidth() - 16 - 91			// 16 pixels away from right edge, A.I.R. version number is 91 pixels long
		Letters.Show("``DAGE v1.8.1.1`A.I.R. v22.09.10.0", 1, px, 193)
		return
	#endif
	#if GAMEAPP == 0x23011500	// use for test version
		if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
			px = getScreenWidth() - 16 - 91			// 16 pixels away from right edge, A.I.R. version number is 91 pixels long
		Letters.Show("``DAGE v1.8.1.1`A.I.R. v23.01.15.0", 1, px, 193)
		return
	#endif
	#if GAMEAPP == 0x23032500	// use for latest test version
		if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
			px = getScreenWidth() - 16 - 91			// 16 pixels away from right edge, A.I.R. version number is 91 pixels long
		Letters.Show("``DAGE v1.8.1.1`A.I.R. v23.03.25.0", 1, px, 193)
		return
	#endif
	#if GAMEAPP > 0x23011500	// use for versions that DAGE has not updated to learn yet
		if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
			px = getScreenWidth() - 16 - 96			// 16 pixels away from right edge, A.I.R. version message is 96 pixels long
		Letters.Show("``DAGE v1.8.1.1`A.I.R. New Version", 1, px, 193)
		return
	#endif

	if (time_attack_end && !time_attack_hud)	// time attack left-aligned HUD
		px = getScreenWidth() - 16 - 120		// 16 pixels away from right edge, A.I.R. version message is 120 pixels long
	Letters.Show("``DAGE v1.8.1.1`A.I.R. Unknown Version", 1, px, 193)	// use for old preview/test versions or stable versions before v21.09.28.0 (via modified mod.json)
}











// Functions from standalone\audio.lemon to implement new audio
// and to enforce most original tracks for Original Mode
function void Standalone.playAudio(u8 sfxId)
{
	// Handle music control IDs
	if (sfxId == MUSIC_CTRL_FADEOUT)
	{
		Audio.fadeOutChannel(0, 0x200)	// Fade out over 2 seconds
		return
	}
	else if (sfxId == MUSIC_CTRL_STOP)
	{
		Audio.stopChannel(0)
		return
	}
	else if (sfxId >= 0xe3 && sfxId <= 0xef)
	{
		// Just ignore these
		return
	}

	u64 soundKey = sfxId

	// Choose whether it's music, a jingle or a sound effect
	u8 soundRegType = 0
	if (sfxId <= 0x24)
	{
		soundRegType = SoundRegType.TYPE_MUSIC
	}
	else if (sfxId <= 0x2b)
	{
		soundRegType = (sfxId == 0x26 || sfxId == 0x28) ? SoundRegType.TYPE_MUSIC : SoundRegType.TYPE_JINGLE
	}
	else if (sfxId <= 0x30)
	{
		soundRegType = SoundRegType.TYPE_MUSIC
	}
	else if (sfxId <= 0x32)
	{
		soundRegType = SoundRegType.TYPE_JINGLE
	}
	else if (sfxId <= 0xdb || (sfxId >= 0xdd && sfxId <= 0xe0))
	{
		soundRegType = SoundRegType.TYPE_SOUND
	}
	else
	{
		soundRegType = SoundRegType.TYPE_JINGLE
	}

	// Clear music for level results, emerald jingle, drowning music and outro music
	if (sfxId == 0x29 || sfxId == 0x2b || sfxId == 0x31 || sfxId == 0xdc)
	{
		Audio.stopChannel(0)
	}

	// Check if a script mod wants to change the sound key
	u64 moddedSoundKey = Standalone.getModdedSoundKey(soundKey, sfxId, soundRegType)
	if (moddedSoundKey != soundKey)
	{
		// Sound key got changed by modded function, so don't run the default logic here;
		// instead, ask modded scripts if they want to change the sound reg type as well
		soundKey = moddedSoundKey
		soundRegType = Standalone.getModdedSoundRegType(soundKey, sfxId, soundRegType)
	}
	else
	{
		// Hard-coded handling of special sfx IDs
		if (sfxId == 0x1c)
		{
			// Special Stage
			if (true)	// TODO: Add option to disable the speedup, of course for both music and gameplay
			{
				soundKey = "1c_speedup"
			}
		}
		else if (sfxId == 0x1f && !original_mode)
		{
			// Knuckles' Theme
			if (Game.getSetting(SETTING_AUDIO_KNUCKLES_THEME) == 0)
			{
				soundKey = "1f_sonic3"
			}
			else if (Game.getSetting(SETTING_AUDIO_KNUCKLES_THEME) == 2)
			{
				soundKey = "1f_proto"
			}
			else if (Game.getSetting(SETTING_AUDIO_KNUCKLES_THEME) == 0x10)
			{
				if (!isSonicAndKnucklesZone())
					soundKey = "1f_sonic3"
			}
		}
		else if (sfxId == 0x25 && !original_mode)
		{
			// Title theme
			if (Game.getSetting(SETTING_AUDIO_TITLE_THEME) == 0)
			{
				soundKey = "25_sonic3"
			}
		}
		else if (sfxId == 0x26)
		{
			// Outro music
			if (Game.getSetting(SETTING_AUDIO_OUTRO) == 0 || original_mode)
			{
				soundKey = 0x15			// Sky Sanctuary
			}
			else if (Game.getSetting(SETTING_AUDIO_OUTRO) == 2)
			{
				soundKey = "26_proto"
			}
		}
		else if (sfxId == 0x28 && !original_mode)
		{
			// Continue screen music
			if (Game.getSetting(SETTING_AUDIO_CONTINUE_SCREEN) == 0)
			{
				soundKey = "28_sonic3"
			}
		}
		else if (sfxId == 0x2a)
		{
			// Extra life jingle
			if (Game.getSetting(SETTING_AUDIO_EXTRALIFE_JINGLE) == 0 && !original_mode)
			{
				soundKey = "2a_sonic3"
			}
			else if (Game.getSetting(SETTING_AUDIO_EXTRALIFE_JINGLE) == 0x10 && !original_mode)
			{
				if (!isSonicAndKnucklesZone())
					soundKey = "2a_sonic3"
			}

			// Special handling for this jingle: Play in channel 1, but mark as override for channel 0 (= music)
			Audio.playOverride(soundKey, AudioContext.CONTEXT_MUSIC, 1, 0)
			return
		}
		else if (sfxId == 0x2c && !original_mode)
		{
			// Invincibility Theme
			if (global.game_mode != 0x2c)	// In Blue Sphere game's Perfect screen, always use the S&K version
			{
				if (Game.getSetting(SETTING_AUDIO_INVINCIBILITY_THEME) == 0)
				{
					soundKey = "2c_sonic3"
				}
				else if (Game.getSetting(SETTING_AUDIO_INVINCIBILITY_THEME) == 0x10)
				{
					if (!isSonicAndKnucklesZone())
						soundKey = "2c_sonic3"
				}
			}
		}
		else if (sfxId == 0x2d)	// can  && !original_mode this, but entering Challenges or Competition is naturally outside of Original Mode
		{
			// Competition Menu music
			if (Game.getSetting(SETTING_AUDIO_COMPETITION_MENU) == 1)
			{
				soundKey = "2d_proto"
			}
		}
		else if ((sfxId == 0x18 || sfxId == 0x2e))
		{
			// Mini-boss music
			soundKey = 0x18
			if (Game.getSetting(SETTING_AUDIO_MINIBOSS_THEME) == 0 && !original_mode)
			{
				soundKey = "2e_sonic3"
			}
			else if (Game.getSetting(SETTING_AUDIO_MINIBOSS_THEME) == 0x10 && !original_mode)
			{
				if (!isSonicAndKnucklesZone())
					soundKey = "2e_sonic3"
			}
		}
		else if (sfxId == 0x33)
		{
			// Alternating ring sound
			alternatingRingSoundState = !alternatingRingSoundState
			if (!alternatingRingSoundState)
			{
				soundKey = 0x34
			}
		}
		else if (sfxId == 0xf0)
		{
			// Super Theme
			soundRegType = SoundRegType.TYPE_MUSIC
			u8 configOption = Game.getSetting(SETTING_AUDIO_SUPER_THEME)
			if (original_mode)
				configOption = 4
			if (configOption == 0 || configOption == 1)
			{
				// Enable the fast level music
				if (configOption == 1)
				{
					Standalone.setFastMusicFlag(FastMusicFlag.SUPER_THEME, true)
				}

				// Continue normal level music, start it if necessary
				if (!Audio.isPlayingAudio(level.default_music.u8) && level.default_music.u8 != sfxId)
				{
					Standalone.playAudio(level.default_music.u8)
					return
				}
			}
			else if (configOption == 2)
			{
				// Sonic 2 super theme
				soundKey = "supertheme_sonic2"
			}
			else if (configOption == 3)
			{
				// Sonic 3 invincibility theme
				soundKey = "2c_sonic3"
			}
			else if (configOption == 4)
			{
				// S&K invincibility theme
				soundKey = 0x2c
			}
			else
			{
				// Unused track from Sonic 3 prototypes
				soundKey = "2e_proto"
			}
		}
		else if (sfxId == 0xf2)
		{
			// Sonic 1 boss music
			soundKey = "sonic1_boss"
			soundRegType = SoundRegType.TYPE_MUSIC
		}
		else if (sfxId == 0xf3)
		{
			// Sonic 2 boss music
			soundKey = "sonic2_boss"
			soundRegType = SoundRegType.TYPE_MUSIC
		}
		else if (sfxId == 0xf4)
		{
			// Knuckles' Theme (S3 version enforced)
			soundKey = "1f_sonic3"
			soundRegType = SoundRegType.TYPE_MUSIC
		}
		else if (sfxId == 0xf5)
		{
			// Knuckles' Theme (S&K version enforced)
			soundKey = 0x1f
			soundRegType = SoundRegType.TYPE_MUSIC
		}
		else if (sfxId == 0xf6)
		{
			// Mini-boss music (S3 version enforced)
			soundKey = "2e_sonic3"
			soundRegType = SoundRegType.TYPE_MUSIC
		}
		else if (sfxId == 0xf7)
		{
			// Mini-boss music (S&K version enforced)
			soundKey = 0x18
			soundRegType = SoundRegType.TYPE_MUSIC
		}
		else if (sfxId == 0xf8)
		{
			// Special Stage (generated ones, with speed-up only every 45 seconds)
			if (true)	// TODO: Add option to disable the speedup, of course for both music and gameplay
			{
				soundKey = "1c_speedup45"
				if (!Game.isModdedSound("1c_speedup45") && Game.isModdedSound("1c_speedup30"))
				{
					// Prefer modded 30 seconds version variant over the non-modded 45 seconds version
					soundKey = "1c_speedup30"
				}
				soundRegType = SoundRegType.TYPE_MUSIC
			}
		}
		else if (sfxId == MUSIC_KNUCKLES_FORCED_PROTO)
		{
			// Knuckles' Theme (S3 prototype version enforced)
			soundKey = "1f_proto"
			soundRegType = SoundRegType.TYPE_MUSIC
		}
		
		// Support for Sonic 3 prototype music
		if (!original_mode)
		{
			if (sfxId == 0x07 && (Game.getSetting(SETTING_CNZ_PROTOTYPE_MUSIC) & 0x01))
			{
				soundKey = "07_proto"
			}
			else if (sfxId == 0x08 && (Game.getSetting(SETTING_CNZ_PROTOTYPE_MUSIC) & 0x02))
			{
				soundKey = "08_proto"
			}
			else if (sfxId == 0x0b && (Game.getSetting(SETTING_ICZ_PROTOTYPE_MUSIC) & 0x01))
			{
				soundKey = "0b_proto"
			}
			else if (sfxId == 0x0c && (Game.getSetting(SETTING_ICZ_PROTOTYPE_MUSIC) & 0x02))
			{
				soundKey = "0c_proto"
			}
			else if (sfxId == 0x0d && (Game.getSetting(SETTING_LBZ_PROTOTYPE_MUSIC) & 0x01))
			{
				soundKey = "0d_proto"
			}
			else if (sfxId == 0x0e && (Game.getSetting(SETTING_LBZ_PROTOTYPE_MUSIC) & 0x02))
			{
				soundKey = "0e_proto"
			}
		}
	}

	if (soundRegType == SoundRegType.TYPE_MUSIC)
	{
		if (Audio.isPlayingAudio(soundKey))
		{
			// Do not restart music if already playing
			//  -> But make sure it gets played at full volume (in case it's fading out)
			Audio.fadeInChannel(0, 0x40)
			return
		}
	}

	u8 audioContext = (soundRegType != SoundRegType.TYPE_SOUND) ? AudioContext.CONTEXT_MUSIC : AudioContext.CONTEXT_SOUND
	Audio.playAudio(soundKey, audioContext)
}



// Ensure the Knuckles AIZ1 intro does not play in time attack modes.
// Also aids in setting MHZ2 time attack start, setting Original Mode screen size, and other things.
// Function taken from maingame\maingame.lemon
function void initializeMainGame()
{
	Letters.ClearAll()	// clear the text display queue to ensure previous text from menus does not show for one frame in a level
	ROMManipulation.AIZ2.BlimpSequenceBombs()	// This is usually only called during the A.I.R. menu if a setting changes. Force it here.
	ROMManipulation.BonusSM.Probabilities()		// Same here

	// Specific check for The ECSU Framework
	if (Mods.isModActive("Extra Character Slots") && Mods.getModPriority("Extra Character Slots") < Mods.getModPriority("Sonic 3: D.A. Garden Edition"))
	{
		global.game_mode = 0x58		// go to D.A. Garden Edition main menu, which has an error trapper for improper character mod priority
		return
	}
	 
	// Specific check for the 3D2D Glitches mod
	if (Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") && Mods.getModPriority("3D2D Glitches: Sonic 3 With Bluckles") < Mods.getModPriority("Sonic 3: D.A. Garden Edition"))
	{
		global.game_mode = 0x58		// go to D.A. Garden Edition main menu, which has an error trapper for improper character mod priority
		return
	}

	// Check for character mods and ensure they are higher priority. This only works on the highest-priority character mod.
	u64 characterModName = System.getGlobalVariableValueByName("DAGE_characterModName")
	if (Mods.isModActive(characterModName) && Mods.getModPriority(characterModName) < Mods.getModPriority("Sonic 3: D.A. Garden Edition"))
	{
		global.game_mode = 0x58		// go to D.A. Garden Edition main menu, which has an error trapper for improper character mod priority
		return
	}

	if (!menu_initialized)
	{
		debug_mode.enabled.u8 = Game.getSetting(SETTING_DEBUG_MODE)		// The debug flag may not have been set if we didn't go to the AIR menu first
		marathon_timer = 0
		time_attack = 0
		draw_HUD = true					// Do not draw HUD in menus. initialiizeMainGame() will activate the HUD.
		water.fullscreen = 0				// Set in case we quit the game while totally underwater.
		original_mode = 0					// Remove original mode in main menu
		eggrobos_knuckles = 0				// Default to Normal difficulty
		specialstages_knuckles = 0			// Default to Normal difficulty
		restartSpecialStage = 0
		challenges_normalmode = 0
	}

	if (original_mode)
		Renderer.setScreenSize(320, 224)
	else if (screen_width && !time_attack)
		Renderer.setScreenSize(screen_width, 224)
	else
		Renderer.setScreenSize(400, 224)

	global.game_mode |= 0x80
	if (s16(global.rolling_demo) >= 0)
	{
		playSound(MUSIC_CTRL_FADEOUT)
	}
#if STANDALONE
	// Reset music tempo
	Standalone.setFastMusicFlag(FastMusicFlag.MUSIC_TEMPO, false)
	Standalone.setFastMusicFlag(FastMusicFlag.SUPER_THEME, false)

	// Just to be sure this is not active
	Game.endSkippableCutscene()

	Input.setTouchInputMode(TOUCH_INPUT_MODE_NORMAL_CONTROLS)

#if GAMEAPP
	Game.setUnderwaterAudioEffect(0)
#endif
#endif

	global.pause_disabled = 0
	kosinski.queue_size = 0
	zeroMemory(0xffffff10, 0x1b * 4)
	ClearPatternLoadingQueue()

	if (global.zone_act == 0x0d01)
	{
		FadeScreenToWhiteBlocking()

	#if STANDALONE
		// Avoid some black frames when screen should stay white
		VDP.Config.setActiveDisplay(false)
	#endif
	}
	else if (global.zone_act == 0x1701 && global.in_extra_stage != 0)
	{
		// Hidden Palace when entered through a giant ring
		FadeScreenToWhiteBlocking()

	#if STANDALONE
		// Avoid some black frames when screen should stay white
		VDP.Config.setActiveDisplay(false)
	#endif
	}
	else
	{
		FadeOutScreenBlocking()

	#if STANDALONE
		global.zone_act = Game.onFadedOutLoadingZone(global.zone_act)
	#endif
	}

	#if STANDALONE
	{
		Renderer.resetSprites()

		if (time_attack == 1 || time_attack == 2)
		{
			// Don't use "isMainCharacter" or similar here, it's not initialized yet
			if (global.zone_act == 0x0701 && setting.levelselect.characters != CHARS_KNUCKLES_ALONE)
			{
				// MHZ 2: Start after the initial cutscene
				// TODO: The checkpoint number gets reset to 0 later in initialization again
				//     -> This is fine for Time Attack in MHZ 2, but not in other cases like Time Attack in SSZ
				checkpoint.number = 7
				checkpoint.x = 0x03ec	// 0x052a
				checkpoint.y = 0x0569	// 0x05ac
			}
		}

		if (!Game.getSetting(SETTING_CONTINUE_MUSIC) || original_mode)
		{
			// Stop music
			Audio.stopChannel(0)
		}
	}
	#endif

	if (s16(global.rolling_demo) >= 0)
	{
	#if !STANDALONE
		set_status_register(0x2700)
	#endif
		fn0011ca()
	#if !STANDALONE
		set_status_register(0x2300)
	#endif

		level.framecounter = 0
		if (checkpoint.number != 0)	// this may need to be adjusted for other game modes and for menus
		{
			if (global.stage_type == 0)
			{
				global.zone_act = checkpoint.zone_act
				global.zone_act.apparent = checkpoint.zone_act.apparent
			}
			else
			{
				global.zone_act = level.backup.zone_act
				global.zone_act.apparent = u16[0xffffff9c]
			}
		}

		if (global.zone_act != 0x0401 || checkpoint.number != 6)
		{
			A2 = MainGame.getLevelDataPointer()
			D0 = u8[A2]
			if (D0.u8 != 0)
			{
				requestLoadingPatterns(D0.u8)
			}
		}

		SetGlobalCharacters()

		if (isSonicIntro())
		{
			D0 = 1
			FillPatternLoadingCues()

			requestLoadingPatterns(0x0a)
		}
		else if (competition_mode.active)
		{
			D0 = 6
			// Isn't requestLoadingPatterns misisng here?
		}
		else
		{
			if (isMainCharacter(CHARACTER_SONIC))		// Sonic
			{
				requestLoadingPatterns(0x01)
			}
			else if (isMainCharacter(CHARACTER_TAILS))	// Tails - or Miles
			{
				requestLoadingPatterns((global.region_code & 0x80) ? 0x07 : 0x52)
			}
			else 										// Must be Knuckles then
			{
				requestLoadingPatterns(0x05)
			}
		}
	}

	zeroMemory(0xffffac00, 0x400)
	zeroMemory(0xffffb000, 0x2000)
	zeroMemory(0xfffff628, 0x16 * 4)
	zeroMemory(0xfffff700, 0x100)
	zeroMemory(0xfffffe6e, 0x13 * 4)
	zeroMemory(0xfffffa80, 0x80)

	fn01aa6e()

	VDP.Config.setVerticalScrolling(false, 0xff)	// Good old horizontal scrolling mode
	VDP.Config.setNameTableBasePlaneA(0xc000)
	VDP.Config.setNameTableBasePlaneB(0xe000)
	VDP.Config.setSpriteAttributeTableBase(0xf800)
	VDP.Config.setPlayfieldSizeInPixels(512, 256)
	VDP.Config.enableHInt(false)
	VDP.Config.setupWindowPlane(false, 0)	// Disable window plane
	VDP.Config.setBackdropColor(0x20)
	VDP.Config.setRenderingModeConfiguration(false)

	if (debug_mode.unlocked && control.pad1.state & CONTROL_A)
	{
		debug_mode.enabled.u8 = true
	}

	if (competition_mode.active)
	{
		u16[0xfffffff6] = 0x4ef9		// Machine code for "jump"
		irq_table.lineupdate = 0x000d10

		VDP.Config.enableHInt(true)
		VDP.Config.setNameTableBasePlaneA(0x8000)
		VDP.Config.setNameTableBasePlaneB(0xa000)
		h_int.configuration = 0x8a6b	// H-INT at 0x6b = 107 (near the vertical screen center)

		if (global.zone == 0x0f)
			VDP.Config.setPlayfieldSizeInPixels(512, 512)
		else
			VDP.Config.setPlayfieldSizeInPixels(1024, 256)
	}
	else
	{
		h_int.configuration = 0x8aff
	}
	Renderer.configureHInt()

	u16[0xfffffb00] = 0
	u32[0xfffffbfc] = 0xfffffb00

	Level.loadPaletteData((global.characters == CHARS_KNUCKLES_ALONE) ? 5 : 3)
	Level.InitializeWater()

	zeroMemory(0xfffff0a0, 0x60)

	if (level.water_present)
	{
		VDP.Config.enableHInt(true)
	}

	if (s16(global.rolling_demo) >= 0)
	{
		bool isKnucklesIntro = (global.zone_act == 0x0700 && global.characters == CHARS_KNUCKLES_ALONE && global.lock_on_state != 0 && checkpoint.number == 0)
	#if STANDALONE
		isKnucklesIntro = (Game.getSetting(SETTING_AIZ_INTRO_KNUCKLES) != 0 && global.zone_act == 0x0000 && global.characters == CHARS_KNUCKLES_ALONE && checkpoint.number == 0 && !time_attack && !original_mode)
	#endif

		u8 musicId
		if (global.zone_act == 0x0001 && checkpoint.number == 3)
		{
			musicId = 0x01
		}
		else if (isKnucklesIntro)
		{
		#if STANDALONE
			// Enforce S&K version of Knuckles' theme
			Audio.playAudio("1f", AudioContext.CONTEXT_MUSIC)
			musicId = 0
		#else
			musicId = 0x1f
		#endif
		}
		else
		{
			if (!original_mode)
			{
				// Check if this is the S/T outro
				if (global.zone_act == 0x0d01)
				{
					playMusic(0x26)		// Play Sonic 3 credits (instead of Sky Sanctuary)
				}
				else
				{
					// Bug fix for second parts of AIZ 1 and ICZ 1
					musicId = u8[0x005f82 + global.zone * 2 + global.act.apparent]
				}
			}
			else
				musicId = u8[0x005f82 + global.zone * 2 + global.act]
		}

		level.default_music = musicId
		if (musicId != 0)
		{
			playMusic(musicId)
		}

		bool isAnyIntro = false
		if (global.zone_act == 0)
		{
			isAnyIntro = isSonicIntro()
		}
		if (isKnucklesIntro)
		{
			// This loads the critters graphics
		#if !STANDALONE
			set_status_register(0x2700)

			// Use AIZ critters and not the MHZ critters in Knuckles' intro, #contributed by iCloudius
			//  -> Also requires a ROM manipulation, search for the comment above to find that one
			Nemesis.loadDataToVRAM(0x1935a8, 0xb000)
		#else
			Nemesis.loadDataToVRAM(0x1931d6, 0xb000)
		#endif
			Nemesis.loadDataToVRAM(0x193308, 0xb240)
			
			isAnyIntro = true
		}

		if (!isAnyIntro && global.zone_act != 0x1701 && !level.skip_titlecard)
		{
			// Spawn title card
			u32[0xffffb250] = 0x02d690

			while (true)
			{
				global.frame_state = 0x0c
				Kosinski.ProcessDecompressionQueue()
				waitForNextFrame()

				UpdateGameObjects()
				RenderSprites()
				LoadRequiredSpritePatterns()
				Kosinski.ProcessModules()
				if (u16[0xffffb298] == 0 && u32[0xfffff680] == 0)
					break
			}
		}

		level.skip_titlecard = false

		// Artifical delay in Original Mode
		u8 delay = 58	// measured from entering AIZ2 from Level Select
		if (global.zone >= 0x13 && global.zone <= 0x15)
			delay = 38	// Bonus stages have a smaller delay. This is estimated, mot measured.
		if (global.zone == 0x0c || global.zone_act == 0x1700 || global.zone_act == 0x0a01)	// Final boss stages load few plane graphics and thus load fast. Estimated delay.
			delay = 18
		if (original_mode)	// Original Mode, not Doomsday, not DEZ2 final boss
			for (u8 i = 0; i < delay; i++)	
				waitForNextFrame()

	#if !STANDALONE
		set_status_register(0x2700)
	#endif
		ResetScoreDisplay()
	#if !STANDALONE
		set_status_register(0x2300)
	#endif
	}

	Level.loadNonfadingPaletteData(0x03)

	fn01bc60()

	UpdateCamera()
	fn007812()
	fn01c2b0()

#if !STANDALONE
	set_status_register(0x2700)
#endif
	InitLevelDisplay()
#if !STANDALONE
	set_status_register(0x2300)
#endif

	fn028c80()
	fn0076a6()
	UpdateWater()

	u16[0xffffff7c] = control.pad2
	control.player1 = 0
	control.tails = 0
	control.pad1 = 0
	control.pad2 = 0
	player1.control_override = 1
	player2.control_override = 1
	global.level_started = 0
	if (level.water_present && global.zone == 0x01)
	{
		u32[0xffffcf82] = 0x01f202
		u32[0xffffb172] = 0x0383bc		// HCZ run-on-water handler
		u8[0xffffb19e] = 1
	}
	else if (global.zone == 0x07)
	{
		u32[0xffffb128] = 0x03da00		// MHZ leaves effect
	}

	if (checkpoint.number == 0)
	{
		ring_counter = 0
		timer.alldata = 0
		extra_lives_granted = 0
		u16[0xfffffed0] = 0
		u32[0xfffffed2] = 0
	#if STANDALONE
		bool marathon_shield_keep = (global.zone_act.apparent == 0x0101 || global.zone_act.apparent == 0x0801 || global.zone_act.apparent == 0x0901 || global.zone_act.apparent == 0x0b01)
		if ((!Game.getSetting(SETTING_MAINTAIN_SHIELDS) && !marathon_shield_keep) || original_mode)
	#endif
		{
			global.shields_backup_1 = 0
		}

		// new check
		if (time_attack >= 3 && marathon_shield_keep)
			global.shields_backup_1 = global.shields_backup_2	// restore backup 1 if needed

		if (global.zone_act == 0x1600 || global.zone_act == 0x1700)
		{
			global.in_extra_stage = 0
		}
		else if (global.zone < 0x13 || (global.zone > 0x15 && global.zone_act != 0x1701))
		{
			global.shields_backup_2 = 0
			global.in_extra_stage = 0
		}
	}

	global.time_over = 0
	debug_mode.state = 0
	level.restart = 0
#if !STANDALONE
	unused.teleport_timer = 0
	unused.teleport_active = 0
#endif
	u16[0xfffffec8] = 0
	u16[0xfffffeca] = 0
	u16[0xfffffecc] = 0
	u16[0xfffffece] = 0
	u16[0xfffffede] = 0
	u8[0xfffffe65] = 0
	super.active = 0
	ResetOscillatingNumbers()

	hud.dirty.score = 0x01
	hud.dirty.rings = 0x01
	hud.dirty.timer = 0x01
	global.level_started = 1

	if (global.zone_act == 0x0d01 || global.zone_act == 0x1701)
	{
		// Special handling for S/T Outro and HPZ emerald cave
		hud.dirty.timer = 0
		global.level_started = 0
	}

	fn0067ee()
	DynamicObjectsLoading()
	UpdateListOfRingsAround()

	fn01cacc()

	UpdateGameObjects()
	RenderSprites()
	LevelTilesAnimation()
	global.demo_countdown = 1800	// 30 seconds
	Level.InitializeWater.Part2()

	zeroMemory(0xfffff0a0, 0x60)

	player1.control_override = 0
	player2.control_override = 0
	fn0075d2()

#if STANDALONE
	// Just in case active display got disabled before (when entering Hidden Palace through a Giant Ring)
	VDP.Config.setActiveDisplay(true)
#endif
}


// Disallow alternate camera options in time attack modes and Original Mode.
// Function taken from general\camera.lemon
//# address-hook(0x01c0a8) end(0x01c11c)
function void UpdateCameraPositionX()
{
	u16 oldCamPos = u16[A1]
	D4.u16 = oldCamPos

#if !STANDALONE
	// This check is effectively dead code
	if (unused.teleport_active != 0)
		return
#endif

	u16 px = char.position.x.u16
#if STANDALONE
	// Handle additional camera offset
	//  -> This was only introduced to smooth the camera while using the FBZ monkey bars
	if (globalCameraOffsetX != 0)
	{
		if (abs(globalCameraOffsetX) >= 8)
			globalCameraOffsetX += clamp(-globalCameraOffsetX, -2, 2)
		else
			globalCameraOffsetX += clamp(-globalCameraOffsetX, -1, 1)
		px += globalCameraOffsetX
	}
#endif

	s16 limitLeft = s16[A2]		// "move_area.left"
	s16 limitRight = s16[A2+2]	// "move_area.right"

	// Handle temporary camera lock right e.g. after spindash
	//  u16[A5]   = camera.locktime.player*
	//  u16[A5+2] = posbackup.offset.player*
	if (u16[A5] > 0)
	{
		u16[A5] -= 0x100
		D1 = (u8[A5] * 4) + 4
		D0.u8 = u16[A5+2] - D1.u8
		px = u16[A6 + D0.u8] & 0x7fff
	}

#if STANDALONE
	if (Game.getSetting(SETTING_EXTENDED_CAMERA) && !original_mode)	//  && !time_attack was also in this check when A.I.R. did not allow extended camera in time attack
	{
		if (global.level_started <= 0 || global.stage_type != 0)	// First is relevant e.g. for AIZ 1 Sonic intro
		{
			currentCameraPanning = 0
		}
		else
		{
			if (Game.getSetting(SETTING_EXTENDED_CAMERA) == 1 && !original_mode)
			{
				// Variant A
				s16 diff = 0
				if (u8[0xffffb02e] & 0xc0 || u8[0xffffb03c] != 0)		// Reset to normal it certain situations when the player has no direct control, or when on a convex surface
				{
					diff = clamp(-currentCameraPanning, -2, 2)
				}
				else if (char.state == char.state.SPINDASH || char.spindash == 0x80)
				{
					diff = (char.flags & char.flag.FACING_LEFT) ? -4 : 4
				}
				else
				{
					if (char.groundspeed == 0)
					{
						if (char.flags & char.flag.FACING_LEFT)
							diff = clamp(-currentCameraPanning, -2, 0)
						else
							diff = clamp(-currentCameraPanning, 0, 2)
					}
					else
					{
						if (char.flags & char.flag.FACING_LEFT)
							diff = (char.groundspeed <= -0x600 || currentCameraPanning > 1) ? -2 : 0
						else
							diff = (char.groundspeed >= 0x600 || currentCameraPanning < -1) ? 2 : 0
					}
				}
				currentCameraPanning = clamp(currentCameraPanning + diff, -0x30, 0x30)
			}
			else
			{
				// Variant B
				if (char.state == char.state.SPINDASH || char.spindash == 0x80)
				{
					currentCameraPanning += (char.flags & char.flag.FACING_LEFT) ? -4 : 4
				}
				else
				{
					s16 target = char.groundspeed >> 4
					s16 diff = target - currentCameraPanning
					if (abs(diff) >= 0x30 || target == 0 || (target < 0) == (diff > 0))
					{
						currentCameraPanning += clamp(diff, -2, 2)
					}
				}
				currentCameraPanning = clamp(currentCameraPanning, -0x30, 0x30)
			}

			px += currentCameraPanning
		}
	}

	u16 currentScreenPivot = oldCamPos + getScreenWidth() / 2 - 8		// A bit left of the actual screen center
	s16 diffx = px - currentScreenPivot

	// Standalone's version of this code does the limit checks in each frame, even if there was no camera movement
	//  -> Needed e.g. to prevent a possible camera jump in AIZ 2 boss
	s16 movex = 0
	if (abs(diffx) > 8)
	{
		diffx += (diffx < 0) ? 8 : -8
		s16 range = 24

		if (Game.getSetting(SETTING_CAMERA_OUTRUN) && char.control_flags == 0 && !original_mode)	// The second check is false e.g. in ICZ snowboarding
		{																		// && !time_attack was checked when AIR did not allow this in time attack
			// Allow for out-running the camera
			range = 15
			u16 justOutsideScreen = getScreenWidth() / 2 + 24
			if (abs(diffx) > justOutsideScreen)
			{
				// Never leave the screen
				range = min(range + abs(diffx) - justOutsideScreen, 24)
			}
		}

		movex = clamp(diffx, -range, range)
	}

	limitRight = max(limitLeft, limitRight - (getScreenWidth() - 320))
	px = clamp(s16(oldCamPos + movex), limitLeft, limitRight)

#else

	s16 diffx = px - (oldCamPos + getScreenWidth() / 2 - 16)
	if (diffx < 0)
	{
		diffx = max(diffx, -24)
		px = max(s16(oldCamPos + diffx), limitLeft)
	}
	else if (diffx >= 16)
	{
		diffx = min(diffx - 16, 24)
		px = min(s16(oldCamPos + diffx), limitRight)
	}
	else
	{
		u16[A4] = 0		// No change at all
		return
	}
#endif

	u16[A1] = px	// Update camera position
	u16[A4] = s16(px - oldCamPos) << 8
}







// Restrict level select options in time attack mode and ensure no sprites from the level are rendered.
// Functions taken from menus\levelselect.lemon

//# address-hook(0x007a74) end(0x007d20)
//# translated(0x007d64) end(0x007d6a)
function void LevelSelect()
{
	if (!menu_initialized)
	{
		debug_mode.enabled.u8 = Game.getSetting(SETTING_DEBUG_MODE)		// The debug flag may not have been set if we didn't go to the AIR menu first
		marathon_timer = 0
		time_attack = 0
		draw_HUD = false					// Do not draw HUD in menus. initialiizeMainGame() will activate the HUD.
		water.fullscreen = 0				// Set in case we quit the game while totally underwater.
		original_mode = 0					// Remove original mode in main menu
		eggrobos_knuckles = 1				// Default to Hard difficulty (AIR Act Select uses Normal)
		specialstages_knuckles = 1			// Default to Hard difficulty (AIR Act Select uses Normal) to make all special stages accessible in Level Select
		restartSpecialStage = 0
		Renderer.setScreenSize(400, 224)	// Menus run at the default resolution. This also undoes Original Mode's screen size change.
		challenges_normalmode = 0
	}

	bluespheres.minigame_mode = 0	// ensure that a special stage doesn't take us back to the green sphere menu
	challenge_greenspheres = 0		// make sure this isn't activated from a Challenge attempt

	global.zone_act = 0
	FadeOutScreenBlocking()
	if (original_mode)
		Renderer.setScreenSize(320, 224)
	else if (screen_width && !time_attack)
		Renderer.setScreenSize(screen_width, 224)
	else
		Renderer.setScreenSize(400, 224)

	// Load data that usually gets loaded in the main menu, just in case players use AIR menus to get here
	loadBestActTimes()
	loadRSR()
	if (!System.loadPersistentData(0x840273, "DAGE_Theme", 1))	// load save theme if it exists,
		theme.hud = theme.saturn								// else use the theme matching the menu

#if !STANDALONE
	set_status_register(0x2700)
#endif

	LevelSelect.init()

	Menu.FadeInAfterInit()

	// Perform main update now
	bool running = true
	while (running)
	{
		global.frame_state = 0x16

		// End point for a single frame
		//  -> Right here we place the entry point for the standalone version
		waitForNextFrame()
	@EntryPoint:

		running = LevelSelect.innerUpdate()
	}
}

function void LevelSelect.init()
{
	Letters.ClearAll()
	Letters.Main()
	if (levelselect.selection != 0x20 && !original_mode)
	{
		Letters.Show("Press    to`change characters.", 1, getScreenWidth()/2 + 10, 201)
		Renderer.drawCustomSprite("@input_icon_button_X", getScreenWidth()/2 + 51, 201, 0x00, SPRITE_FLAG_PRIO + 0x08, 0xf003)
	}

	Renderer.resetSprites()	// added for accessing the level select directly from time attack mode
	level.start_location = 0	// remove any alternate start locations set by previous levels

	// Disable active display for now
	VDP.Config.setActiveDisplay(false)

	fn0011ca()

	// Configure VDP registers
	VDP.Config.enableHInt(false)
	VDP.Config.setNameTableBasePlaneA(0xc000)
	VDP.Config.setNameTableBasePlaneB(0xe000)
	VDP.Config.setBackdropColor(0)
	VDP.Config.setRenderingModeConfiguration(false)
	VDP.Config.setPlayfieldSizeInPixels(512, 256)
	VDP.Config.setVerticalScrolling(false, 0)	// Horizontal scrolling mode without scroll mask

	zeroMemory(0xffffac00, 0x400)
	zeroMemory(0xffffb000, 0x2000)

	u16[0xfffffb00] = 0
	u32[0xfffffbfc] = 0xfffffb00
	Nemesis.loadDataToVRAM(0x0ca5e0, 0x0200)

	Enigma.decompress(0x0cab54, 0xffff0000, 0x6000)
	copyRectToVRAM(0xffff0000, 0xe000, 0x28, 0x1c)

	zeroMemory(0xffff0000, 0x460 * 2)

	A3 = 0xffff0000
	A1 = 0x0080e6
	A5 = 0x0080c4
	D0 = 0
	D1.u16 = 0x10

	while (D1.s16 >= 0)
	{
		D3.u16 = u16[(A5+=2)-2]
		A2 = A3 + D3.s16
		D2 = u8[(A1+=1)-1]
		D3.u16 = D2.u16

		while (D2.s16 >= 0)
		{
			u16[(A2+=2)-2] = u8[(A1+=1)-1]
			--D2.s16
		}

		D2.u16 = 0x0d - D3.u16
		while (D2.s16 >= 0)
		{
			u16[(A2+=2)-2] = 0
			--D2.s16
		}

		u16[A2] = 0x11
		A2 = A2 + 0x50
		u16[A2] = 0x12
		--D1.s16
	}

	u16[A2] = 0
	A2 = A2 - 0x50
	u16[A2] = 0x1a
	u16[0xffff018a] = 0x13
	u16[0xffff01da] = 0x14

	copyRectToVRAM(0xffff0000, 0xc000, 0x28, 0x1c)

	D3 = 0
	fn007f62()

	global.characters = CHARS_SONIC_ALONE
	u16[0xffffff02] = 0
	global.level_started = 0
	u16[0xfffff7f0] = 0

	A2 = 0x0081b0
	LevelTilesAnim.Default()

	Level.loadNonfadingPaletteData(0x04)

	copyMemory(0xfffffcc0, 0xfffffc40, 0x20)
	zeroMemory(0xfffffc40, 0x20)

	playMusic(0x2f)

	global.demo_countdown = 1799	// 30 seconds (minus one frame)
	competition_mode.active = 0
	camera.position.x = 0
	camera.position.y = 0
	global.active_saveslot = 0
	level.giantrings_clear = 0
	checkpoint.number = 0
	global.stage_type = 0
	bluespheres.minigame_mode = 0

	u16[0xffffffe4] = 0
	u16[0xffffffe6] = 0
	global.frame_state = 0x16

#if STANDALONE
	// Corrections for widescreen
	for (u16 base = 0xe000; base < 0xee00; base += 0x80)
	{
		for (u16 x = 0; x < 0x30; x += 2)
		{
			setVRAM(base + x + 0x50, getVRAM(base + x + 0x08))
		}
	}

	// Foreground scroll offset
	u16[0xffffe000] = max(s16(getScreenExtend()) - 6, 0)

	// Write sound test digits (they are missing otherwise)
	VDP.setupVRAMWrite(0xcb46)
	LevelSelect.writeHexDigit(levelselect.soundtest >> 4,   0)
	LevelSelect.writeHexDigit(levelselect.soundtest & 0x0f, 0)

#endif

	waitForNextFrame()

	// Re-enable active display again
	VDP.Config.setActiveDisplay(true)
}

//# address-hook(0x007f62) end(0x008010)
//# translated(0x008012) end(0x00803e)
function void fn007f62()
{
	A4 = 0xffff0000
	A5 = 0x008040
	A3 = A5 + levelselect.selection * 4
	D0 = u32(u8[A3]) * 0x50 + u8[A3 + 1]
	A1 = A4 + D0.s16

	D1 = u32(u8[A3]) * 0x80 + u8[A3 + 1]
	D1.u16 += 0xc000
	VDP.setupVRAMWrite(D1.u16)

	for (u8 i = 0; i < 0x0f; ++i)
	{
		D0.u16 = u16[A1] + D3.u16
		VDP.writeData16(D0.u16)
		A1 += 2
	}

	A3 += 2
	D0 = u8[A3]
	if (D0.u8 != 0)
	{
		D0 = u32(D0.u16) * 0x50 + u8[A3 + 1]
		A1 = A4 + D0.u16

		D1 = 0xc000 + u8[A3] * 0x80 + u8[A3 + 1]
		VDP.setupVRAMWrite(D1.u16)

		D0.u16 = u16[A1] + D3.u16
		VDP.writeData16(D0.u16)
		A1 += 2
	}

	if (levelselect.selection != 0x20 && original_mode)	// use digits to display Character ID
	{
		VDP.setupVRAMWrite(0xc19c)
		LevelSelect.writeHexDigit(levelselect.characters >> 4,   D3.u16)
		LevelSelect.writeHexDigit(levelselect.characters & 0x0f, D3.u16)
	}
	else if (levelselect.selection != 0x20 && !original_mode)	// use sprites to display character and message stating how to change
	{
		Renderer.resetSprites()	// Sprites must be manually reset in the level select menu, else they will not update each frame

		// Before Letters.Show was added, additions to getScreenWidth()/2 were 70 and 86 for main + Tails pairings and 78 for solo characters.
		if (levelselect.characters == 0)
		{
			Renderer.drawCustomSprite("continue_icon_sonic", getScreenWidth()/2 + 123, 216, 0, 0, 0xa000)
			Renderer.drawCustomSprite("continue_icon_tails", getScreenWidth()/2 + 136, 216, 0, 0, 0xa000)
		}
		else if (levelselect.characters == 1)
			Renderer.drawCustomSprite("continue_icon_sonic", getScreenWidth()/2 + 127, 216, 0, 0, 0xa000)
		else if (levelselect.characters == 2)
			Renderer.drawCustomSprite("continue_icon_tails", getScreenWidth()/2 + 127, 216, 0, 0, 0xa000)
		else if (levelselect.characters == 3)
			Renderer.drawCustomSprite("continue_icon_knuckles", getScreenWidth()/2 + 127, 216, 0, 0, 0xa000)
		else if (levelselect.characters == 4)
		{
			Renderer.drawCustomSprite("continue_icon_knuckles", getScreenWidth()/2 + 123, 216, 0, 0, 0xa000)
			Renderer.drawCustomSprite("continue_icon_tails", getScreenWidth()/2 + 136, 216, 0, 0, 0xa000)
		}

		Letters.Main()
		Letters.Show("Press    to`change characters.", 1, getScreenWidth()/2 + 10, 201)
		Renderer.drawCustomSprite("@input_icon_button_X", getScreenWidth()/2 + 51, 201, 0x00, SPRITE_FLAG_PRIO + 0x08, 0xf003)
	}
	else
	{
		VDP.setupVRAMWrite(0xcb46)
		LevelSelect.writeHexDigit(levelselect.soundtest >> 4,   D3.u16)
		LevelSelect.writeHexDigit(levelselect.soundtest & 0x0f, D3.u16)
	}
}

function bool LevelSelect.innerUpdate()
{
#if STANDALONE
	// Corrections for widescreen
	//  -> Actually no need to do this each frame, but I like to load level select save states and want it to be corrected after initialization
	for (u16 base = 0xe000; base < 0xee00; base += 0x80)
	{
		for (u16 x = 0; x < 0x30; x += 2)
		{
			setVRAM(base + x + 0x50, getVRAM(base + x + 0x08))
		}
	}

	// Foreground scroll offset
	u16[0xffffe000] = max(s16(getScreenExtend()) - 6, 0)
#endif

#if !STANDALONE
	set_status_register(0x2700)
#endif
	D3 = 0
	fn007f62()
	fn007e64()
	D3.u16 = 0x6000
	fn007f62()
#if !STANDALONE
	set_status_register(0x2300)
#endif

	A2 = 0x0081b0
	LevelTilesAnim.Default()

	if ((control.pad1.pressed | control.pad2.pressed) & CONTROL_START)
	{
		if (global.lock_on_state != 0)
		{
			if (levelselect.characters < CHARS_KNUCKLES_ALONE)
				levelselect.characters = CHARS_SONIC_ALONE
		}

		global.characters = levelselect.characters
	#if STANDALONE
		// Handle Knuckles & Tails
		useKnucklesAndTails = (global.characters == 4)
		global.characters = min(global.characters, 3)
	#endif

		D0.u16 = u16[0x007d22 + levelselect.selection * 2]
		if (D0.u16 & 0x8000)
		{
			global.game_mode = 0
			return true
		}

		if (D0.u16 != 0x5555)
		{
			// Start game
			lives_counter = 3
			global.sk_bluespheres = 0
		#if STANDALONE
			player.next_life_score = 5000
			u32[0xffffffc4] = 5000
		#endif

			if (D0.u16 == 0x4000 || D0.u16 == 0x4001)
			{
				// Start Blue Spheres
				if (D0.u16 == 0x4000)
				{
					// Blue Spheres from Sonic 3
					if (global.lock_on_state != 0)
					{
						global.sk_bluespheres = 1
					}
				}
				else if (D0.u16 == 0x4001)
				{
					// Blue Spheres from Sonic & Knuckles
					global.sk_bluespheres = 1
				}

				// Start Blue Spheres
		//		if (time_attack == 1 || time_attack == 2)
		//		{
		//			playSound(0xb2)
		//			return true
		//		}
		//		else
		//		{

					if (levelselect.soundtest >= 0x20 && levelselect.soundtest <= 0x3f)		// test values for forcing green sphere mode layouts
						challenge_greenspheres = levelselect.soundtest - 0x1f		// not subtracting 0x20 because it needs to be nonzero to load a layout

					global.game_mode = 0x34
		//		}

			#if STANDALONE
				if (control.pad1.state & CONTROL_A)
				{
					// This is needed to make the special stage selection (incl. 8th stage) work
					//  -> You need to start a special stage form level select by pressing A + Start
					//  -> Current sound test selection tells the game which stage to start
					//  -> See "BlueSpheres.getNextOpenStageIndex()" function for more
					debug_mode.unlocked = 1
				}

			#else
				// Tried to start a Sonic 3 stage in S&K ?
				if (global.lock_on_state != 0)
				{
					if (global.zone_act != 0x0400 && global.zone_act < 0x0700)
					{
						global.zone_act = 0x0700
						global.zone_act.apparent = 0x0700
						checkpoint.zone_act = 0x0700
						checkpoint.zone_act.apparent = 0x0700
					}
				}
			#endif
				return false
			}
			else
			{
				// Normal levels
				if (fn007d6c())
				{
					return false
				}
			}
		}
	}
	return true
}

//# translated(0x007d6c) end(0x007e62)
function bool fn007d6c()
{
	if (time_attack == 1 || time_attack == 2)
	{
		bool fail = (D0.u16 == 0x0a01 || D0.u16 == 0x0c00 || D0.u16 == 0x1300 || D0.u16 == 0x1400 || D0.u16 == 0x1500 || D0.u16 == 0x1600 || D0.u16 == 0x1700)
		if (fail)
		{
			playSound(0xb2)
			return false
		}
	}

	if (global.lock_on_state != 0)
	{
		D1.u16 = D0.u16 & 0xff00
		if (D1.u16 != 0x0400 && D1.u16 < 0x0700)
		{
			D0.u16 = 0x0700
		}
	}

	D0.u16 &= 0x3fff
	global.zone_act = D0.u16
	global.zone_act.apparent = D0.u16
	checkpoint.zone_act = D0.u16
	checkpoint.zone_act.apparent = D0.u16
	checkpoint.move_area.bottom = 0x1000
	u16[0xfffffe62] = 0x1000
	global.game_mode = 0x0c

	lives_counter = 3
	u8[0xfffffec6] = 3
	ring_counter = 0
	timer.alldata = 0
	player.score = 0
	u16[0xfffffed0] = 0
	u32[0xfffffed2] = 0
	u32[0xfffffed6] = 0
	continues_counter = 0
	global.rolling_demo = 0
	player.next_life_score = 5000
	u32[0xffffffc4] = 5000

	playSound(MUSIC_CTRL_FADEOUT)

	u16[0xffffff8a] = 0
	competition_mode.active = (global.zone >= 0x0e && global.zone < 0x13)
	return true
}

//# address-hook(0x007e64) end(0x007f1e)
//# translated(0x007f46) end(0x007f60)
function void fn007e64()
{
	bool skipPart = false
	if ((control.pad1.pressed & (CONTROL_UP | CONTROL_DOWN)) == 0)
	{
		--u16[0xffffff80]
		skipPart = (s16[0xffffff80] >= 0)
	}

	if (!skipPart)
	{
		u16[0xffffff80] = 11
		if (control.pad1.state & CONTROL_UP)
		{
			--levelselect.selection
			if (s16(levelselect.selection) < 0)
				levelselect.selection = 0x20
		}
		if (control.pad1.state & CONTROL_DOWN)
		{
			++levelselect.selection
			if (levelselect.selection > 0x20)
				levelselect.selection = 0
		}
		return
	}

	if (levelselect.selection == 0x20)
	{
		// Sound test
		if (control.pad1.pressed & CONTROL_LEFT)
		{
			if (levelselect.soundtest > 0)
				--levelselect.soundtest
		}
		if (control.pad1.pressed & CONTROL_RIGHT)
		{
			levelselect.soundtest = (levelselect.soundtest + 1) & 0xff
		}
		if (control.pad1.pressed & CONTROL_A)
		{
			levelselect.soundtest = (levelselect.soundtest + 0x10) & 0xff
		}

		if (control.pad1.pressed & CONTROL_C)
		{
			playMusic(levelselect.soundtest)
		}
		if (control.pad1.pressed & CONTROL_B)
		{
			playMusic(0xe3)
		}
	}
	else
	{
		if (control.pad1.pressed & (CONTROL_LEFT | CONTROL_RIGHT))
		{
			levelselect.selection = u8[0x007f22 + levelselect.selection]
		}

		if (control.pad1.pressed & CONTROL_C)
		{
			u8 maxCharacterSelection = 3
		#if STANDALONE
			// Knuckles & Tails
			if (Game.isSecretUnlocked(SECRET_KNUX_AND_TAILS) && time_attack != 1 && time_attack != 2 && !original_mode)
			{
				maxCharacterSelection = 4
			}
		#endif

			++levelselect.characters
			if (levelselect.characters > maxCharacterSelection)
				{
					levelselect.characters = 0
					if (time_attack == 1 || time_attack == 2)
						levelselect.characters = 1
				}
		}
	}

#if STANDALONE
	if (control.pad1.pressed & CONTROL_B || Input.buttonPressed(BUTTON_BACK))
	{
		playSound(0xad)

		u32 backupA0 = A0
		FadeOutScreenBlocking()
		A0 = backupA0

		// Do not fade out music in this case, Data Select music is meant to kept playing
		exitGame = 1
	//	Game.returnToMainMenu()
	//	yieldExecution()
	}
#endif
}



// Prevent sidekick Tails from loading in time attack modes
// and ensure Challenge menu settings are set.
// Function taken from maingame\maingame.lemon
//# address-hook(0x0067b6) end(0x0067ec)
function void SetGlobalCharacters()
{
	if (time_attack == 1 || time_attack == 2 || challenges_normalmode)
	{
		global.characters = setting.levelselect.characters
		// Handle Knuckles & Tails
		useKnucklesAndTails = (global.characters == 4 && time_attack != 1 && time_attack != 2)
		global.characters = min(global.characters, 3)
	}
	else if (global.game_mode != 0x88 && competition_mode.active == 0)
	{
		global.characters = levelselect.characters
	#if STANDALONE
		// Handle Knuckles & Tails
		useKnucklesAndTails = (global.characters == 4 && time_attack != 1 && time_attack != 2)
		global.characters = min(global.characters, 3)
	#endif
	}
	else if (global.zone == 0x07)	// MHZ
	{
		global.characters = CHARS_KNUCKLES_ALONE
	}
	else if (global.lock_on_state == 0 )
	{
		global.characters = CHARS_SONIC_AND_TAILS
	}
	else
	{
		global.characters = CHARS_SONIC_ALONE
	}

	if (global.characters == CHARS_SONIC_AND_TAILS && (time_attack == 1 || time_attack == 2))
	{
		global.characters = CHARS_SONIC_ALONE
	}
}



// Disable debug mode in time attack modes
// Functions taken from maingame\character\character.lemon
//# address-hook(0x010a94) end(0x010ae8)
function void Character.BaseUpdate.Sonic()
{
	if (time_attack)
		debug_mode.enabled = 0

	A4 = 0xfffff760		// Address of speed caps
	A5 = 0xffffee2c		// Address of camera.yoffset.player
	A6 = 0xffffcc54		// Base address of dust cloud object

	// Check for debug mode
	if (debug_mode.state == 0)
	{
		// Targets:
		//	- 0x010afa	-> char.base_state = 0x00	-> Character.Initialization.Sonic()	  	-> Initialization
		//	- 0x010bba	-> char.base_state = 0x02	-> Character.UpdateNormalState.Sonic()	-> In normal state
		//	- 0x0122be	-> char.base_state = 0x04	-> Character.UpdateGotHurtState.Sonic()	-> Sonic just got hurt
		//	- 0x012390	-> char.base_state = 0x06	-> Character.UpdateDiedState.Sonic()  	-> Sonic died
		//	- 0x01257c	-> char.base_state = 0x08	-> Character.UpdateRestartDelay()		-> Completely inactive after death
		//	- 0x0125ac	-> char.base_state = 0x0c	-> Character.UpdateDrownedState.Sonic()	-> Sonic died by drowning
		call tableLookupAddress(0x010aec, char.base_state)
	}
	else
	{
		if (updateDebugModeRegular())
		{
			UpdateSonicSpritePatterns()
			DrawObject()
		}
	}
}

//# address-hook(0x01365c) end(0x0136b8)
function void Character.BaseUpdate.Tails()
{
	if (time_attack)
		debug_mode.enabled = 0

	A4 = 0xfffffec0		// Address of Tails' speed caps
	A5 = 0xffffee2e		// Address of camera.yoffset.tails
	A6 = 0xffffcc9e		// Base address of dust cloud object for Tails

	if (debug_mode.state == 0 || global.characters != CHARS_TAILS_ALONE)	// Maybe a check if it's second player Tails?
	{
		// Targets:
		//  - 0x0136ca	-> char.base_state = 0x00
		//  - 0x0137c4	-> char.base_state = 0x02
		//  - 0x01569c	-> char.base_state = 0x04
		//  - 0x01578e	-> char.base_state = 0x06
		//  - 0x0157e0	-> char.base_state = 0x08
		//  - 0x015810	-> char.base_state = 0x0c
		call tableLookupAddress(0x0136bc, char.base_state)
	}
	else
	{
		if (updateDebugModeRegular())
		{
			UpdateTailsSpritePatterns()
			DrawObject()
		}
	}
}

//# address-hook(0x016444) end(0x016498)
function void Character.BaseUpdate.Knuckles()
{
	if (time_attack)
		debug_mode.enabled = 0

	A4 = 0xfffff760		// Address of speed caps
	A5 = 0xffffee2c		// Address of camera.yoffset.player
	A6 = 0xffffcc54		// Base address of dust cloud object

	if (debug_mode.state == 0)
	{
		// Targets:
		//  - 0x0164aa	-> char.base_state = 0x00
		//  - 0x01656c	-> char.base_state = 0x02
		//  - 0x017bb6	-> char.base_state = 0x04
		//  - 0x017c88	-> char.base_state = 0x06
		//  - 0x017cba	-> char.base_state = 0x08
		//  - 0x017cea	-> char.base_state = 0x0c
		call tableLookupAddress(0x01649c, char.base_state)
	}
	else
	{
		if (updateDebugModeRegular())
		{
			UpdateKnucklesSpritePatterns()
			DrawObject()
		}
	}
}




// Remove star posts in time attack mode.
// Function taken from objects\basics\checkpoint.lemon
// Note that there is a second check in that file to not spawn bonus stage stars in time attack, but it is now obsolete.
//# address-hook(0x02cfc0) end(0x02d00c)
function void Checkpoint.Init()
{
#if STANDALONE
	// No checkpoints in Time Attack, as they serve no purpose there
	if (time_attack == 1 || time_attack == 2)
	{
		UnloadObject()
		return
	}
#endif

	objA0.base_state += 2
	objA0.mapping_offset = 0x02d348
	objA0.sprite_attributes = 0x05ec
	objA0.render_flags = render_flag.WORLD
	objA0.box_size.x = 0x08
	objA0.box_size.y = 0x28
	objA0.sprite_priority = 0x280

	A2 = 0xffff0000 + u16[A0 + 0x48]
	if ((u8[A2] & 0x01) || (checkpoint.number & 0x7f) >= (objA0.subtype2c & 0x7f))
	{
		u8[A2] |= 0x01
		objA0.state = 0x02
	}

	fn02d012()
}





// Do not award extra lives in time attack mode and enforce lives in Original Mode.
// Function taken from maingame\character\character.lemon
function void gainExtraLife()
{
#if STANDALONE
	// No extra lives in Time Attack
	if (time_attack == 1 || time_attack == 2)
		return

	if (Game.getSetting(SETTING_INFINITE_LIVES) && !original_mode)
	{
		lives_counter = 3
	}
	else
	{
		lives_counter = min(lives_counter + 1, 99)
		++hud.dirty.lives
		playMusic(MUSIC_EXTRALIFE)
	}
#else
	++lives_counter
	++hud.dirty.lives
	playMusic(MUSIC_EXTRALIFE)
#endif
}



function void RenderMarathonTimer()
{
	// We should switch this timer to use the S3D tall digits instead of blue sphere small digits and position it appropriately.
	// The BEST timer is currently in a good place for TIME, with BEST underneath it. (If no BEST, move TIME to the average height of the two.)
	// We must cap the marathon_timer variable at 999'59"99, allowing for three digits in the minute spot and perform the appropriate calculations.
	// We must save best times to the appropriate persistent data keys based on emeralds collected and show the best time chosen by an option (BtG, all emeralds, no display.)

	// Add timer HUD here.
	u16 px_hud = getScreenWidth() / 2 - 14	// subtract 49 instead for non-small digits without TIME/BEST
	u16 py_hud = 14	// place the BEST time at getScreenHeight() - 14 - 16. Show either Normal or Perfect best time based on a menu option. Use 12 for non-small digits.
	u16 renderQueue_hud = 0xe800

	u64 minutes = marathon_timer / 3600		// u64 values are used in these lines because the calculations may overflow a smaller size before resolving
	u64 seconds = (marathon_timer - (minutes * 3600)) / 60
	u64 frames = marathon_timer - (minutes * 3600) - (seconds * 60)
	u64 centiseconds = (frames * 99 + 30) / 59

	
//	Renderer.drawCustomSprite(stringformat("BlueSphere_digit_%d", minutes % 10), px_hud, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
//	Renderer.drawCustomSprite("BlueSphere_char_seconds", px_hud + 0x12, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
//	Renderer.drawCustomSprite(stringformat("BlueSphere_digit_%d", seconds / 10), px_hud + 0x18, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
//	Renderer.drawCustomSprite(stringformat("BlueSphere_digit_%d", seconds % 10), px_hud + 0x28, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
//	Renderer.drawCustomSprite("BlueSphere_char_seconds", px_hud + 0x38, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
//	Renderer.drawCustomSprite("BlueSphere_char_seconds", px_hud + 0x3d, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
//	Renderer.drawCustomSprite(stringformat("BlueSphere_digit_%d", centiseconds / 10), px_hud + 0x42, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
//	Renderer.drawCustomSprite(stringformat("BlueSphere_digit_%d", centiseconds % 10), px_hud + 0x52, py_hud, 0, SPRITE_FLAG_PRIO, renderQueue_hud)
	

	// TIME and timer
	Renderer.drawCustomSprite("BlueSphere_smalltext_time", px_hud - 48, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", minutes % 10), px_hud + 5, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x11, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", seconds / 10), px_hud + 0x16, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", seconds % 10), px_hud + 0x21, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x2d, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x31, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", centiseconds / 10), px_hud + 0x35, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", centiseconds % 10), px_hud + 0x40, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)

	// BEST and best time. Right now this just shows the timer again, as best time saving/loading isn't implemented yet.
	py_hud = getScreenHeight() - 14 - 16

	Renderer.drawCustomSprite("BlueSphere_smalltext_best", px_hud - 48, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", minutes % 10), px_hud + 5, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x11, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", seconds / 10), px_hud + 0x16, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", seconds % 10), px_hud + 0x21, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x2d, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite("BlueSphere_smallchar_seconds", px_hud + 0x31, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", centiseconds / 10), px_hud + 0x35, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)
	Renderer.drawCustomSprite(stringformat("BlueSphere_smalldigit_%d", centiseconds % 10), px_hud + 0x40, py_hud, 0, SPRITE_FLAG_PRIO + 0x80, renderQueue_hud)

	// Increment the timer. Checks must be added to be sure the game isn't over!
	if (marathon_timer < 35999)	// Ten minutes less one frame. Once the display accomodates it, it must be increased to one thousand minutes less one frame. (3599999)
		marathon_timer++
	// End of timer HUD code.
}




// Have all calls to RenderHUD() conditionally consider RenderHUD_Challenges() and RenderHUD_Marathon().
// We also make sure special LRZ sprites do not render on the Data Select, as we don't always have the AIR menu to reset displays for us.
// Function taken from general\rendering.lemon
//# address-hook(0x01ad20) end(0x01af68)
function void RenderSprites()
{
#if STANDALONE
	Renderer.resetSprites()
#endif

	if (competition_mode.active)
	{
		RenderSprites_CompetitionMode()
		return
	}

	D7 = 0x4f			// Hard sprite limit: Not more than 0x50 -- but for standalone, we will happily ignore the limit
	D6 = 0
	A5 = 0xffffac00
	A3 = 0xffffee80		// Address of camera.foreground.x
	A6 = 0xfffff800
	if (global.level_started != 0)
	{
	#if STANDALONE
		Renderer.setSpriteTagWithPosition(1, 0, 0)
		Renderer.setLogicalSpriteSpace(Space.SCREEN)
	#endif
		if (original_mode && !((global.game_mode & 0x7f) == 0x4c || (global.game_mode & 0x7f) == 0x2c || global.game_mode == 0x8c))
			RenderHUD_Orig()
		else if (draw_HUD && time_attack != 1 && time_attack != 2 && !((global.game_mode & 0x7f) == 0x4c || (global.game_mode & 0x7f) == 0x2c || global.game_mode == 0x8c))
		{
			RenderHUD_RedRings()
			RenderHUD()
			if (time_attack >= 3)
				RenderHUD_Marathon()
		}
		else if (!((global.game_mode & 0x7f) == 0x4c || (global.game_mode & 0x7f) == 0x2c || global.game_mode == 0x8c))
		{
			RenderHUD_RedRings()
			RenderHUD_Challenges()
		}


	#if STANDALONE
		Renderer.clearSpriteTag()
		Renderer.setLogicalSpriteSpace(Space.WORLD)
	#endif
		RenderStaticRings()
	}

	// Iterate over sprite priority lists
	while (A5 < 0xffffb000)
	{
		if (u16[A5] > 0)
		{
			A4 = A5 + 2
			while (u16[A5] > 0)
			{
				renderNextObject()
				u16[A5] -= 2
			}
		}

		if (A5 == 0xffffac00 && global.zone == 0x09)	// Lava Reef Zone
		{
		#if STANDALONE
			Renderer.clearSpriteTag()
		#endif
			if ((global.game_mode & 0x7f) == 0x0c && draw_HUD)		// Added check so sprites do not overlap Data Select, Green Sphere menu, etc.
				RenderLevelSprites.LRZ()
		}
		A5 += 0x80
	}

#if STANDALONE
	Renderer.clearSpriteTag()
#endif

	// Fill up remaining space
#if STANDALONE
	D7.s16 = max(D7.s16, 0)
#endif
	D6.u16 = D7.u16
	while (D7.s16 >= 0)
	{
		u16[A6] = 0
		A6 += 8
		--D7.u16
	}

	u8[0xfffff62c] = 0x4f - D6.u8
	if (u16[0xffffef3a] != 0)
	{
		if (u8[0xffffb000 + 0x05] < 0x06)
		{
			u16[0xffffef3a] = 0
		}

		A0 = 0xfffff804
		D1 = 0x4e
		while (D1.s8 >= 0)
		{
			if (u16[A0] == 0x07c0)
			{
				u16[A0 + 0x02] = 1
				objA0.sprite_attributes = 0
			}
			A0 += 8
			--D1
		}
	}
}

// Function taken from maingame\hud\hud.lemon
//# address-hook(0x00db3c) end(0x00db42)
function void fn00db3c()
{
#if STANDALONE
	if (debug_mode.state && !((global.game_mode & 0x7f) == 0x4c || (global.game_mode & 0x7f) == 0x2c || global.game_mode == 0x8c))
	{
		Renderer.setLogicalSpriteSpace(Space.SCREEN)
		if (original_mode)
			RenderHUD_Orig()
		else if (time_attack != 1 && time_attack != 2)
		{
			RenderHUD()
			if (time_attack >= 3)
				RenderHUD_Marathon()
		}
		else
		{
			RenderHUD_RedRings()
			RenderHUD_Challenges()
		}
		Renderer.setLogicalSpriteSpace(Space.WORLD)
	}
#else
	if (debug_mode.enabled && !((global.game_mode & 0x7f) == 0x4c || (global.game_mode & 0x7f) == 0x2c || global.game_mode == 0x8c))
	{
		if (original_mode)
			RenderHUD_Orig()
		else if (time_attack != 1 && time_attack != 2)
		{
			RenderHUD_RedRings()
			RenderHUD()
			if (time_attack >= 3)
				RenderHUD_Marathon()
		}
		else
		{
			RenderHUD_RedRings()
			RenderHUD_Challenges()
		}
	}
#endif
}





function void RenderHUD_RedRings()
{
	if (System.getGlobalVariableValueByName("DAGE_characterName") || Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") || u8[0xffffe654])
		return

	redstarring_address = (global.zone >= 0x0c) ? 0x15 : (0x02 * global.zone.apparent) + global.act.apparent	// HPZ gets mapped to zone_act 0x0a01 (SSZ2) to avoid gaps in the data
	if (global.zone_act.apparent == 0x1600)
		redstarring_address = (0x02 * 0x09) + 1	// same calculation as before, but force LRZ2 boss act to use LRZ2 data
	if (global.zone_act.apparent == 0x1700)
		redstarring_address = (0x02 * 0x0b) + 1	// same calculation as before, but force DEZ2 boss act to use DEZ2 data
	redstarring_address += 0x840280
	if (global.characters == 2)
		redstarring_address += 24
	else if (global.characters == 3 || global.characters == 4)
		redstarring_address += 48

	// Draw Red Star Rings (collected and uncollected)
	u32 alpha
	u64 ringKey
	u16 px = getScreenWidth() - 70
	u16 py = getScreenHeight() - 16
	if (time_attack_end && time_attack_hud == 0)
		py -= 6
	// u8 ringNum = objA0.subtype2c & 0x1f
	if (draw_HUD && !original_mode && !debug_mode.enabled && !global.stage_type && global.zone_act != 0x0a01 && global.zone_act != 0x0c00 && global.characters != 0 && !(global.characters == 3 && useKnucklesAndTails))
	{
		if (u8[redstarring_address] & 0x01)
		{
			alpha = 0xffffffff
			ringKey = "redstarring_00"
		}
		else
		{
			alpha = 0x80c0c0c0
			ringKey = "medal_02_00"
		}
		Renderer.drawCustomSprite(ringKey, px, py, 0, SPRITE_FLAG_PRIO, 0xfff1, 0, alpha, 0x8000)	// (12, 12) is center of medal

		if (u8[redstarring_address] & 0xe2)
		{
			alpha = 0xffffffff
			ringKey = "redstarring_00"
		}
		else
		{
			alpha = 0x80c0c0c0
			ringKey = "medal_02_00"
		}
		Renderer.drawCustomSprite(ringKey, px + 12, py, 0, SPRITE_FLAG_PRIO, 0xfff1, 0, alpha, 0x8000)	// (12, 12) is center of medal

		if (u8[redstarring_address] & 0x04)
		{
			alpha = 0xffffffff
			ringKey = "redstarring_00"
		}
		else
		{
			alpha = 0x80c0c0c0
			ringKey = "medal_02_00"
		}
		Renderer.drawCustomSprite(ringKey, px + 24, py, 0, SPRITE_FLAG_PRIO, 0xfff1, 0, alpha, 0x8000)	// (12, 12) is center of medal

		if (u8[redstarring_address] & 0x08)
		{
			alpha = 0xffffffff
			ringKey = "redstarring_00"
		}
		else
		{
			alpha = 0x80c0c0c0
			ringKey = "medal_02_00"
		}
		Renderer.drawCustomSprite(ringKey, px + 36, py, 0, SPRITE_FLAG_PRIO, 0xfff1, 0, alpha, 0x8000)	// (12, 12) is center of medal

		if (u8[redstarring_address] & 0x10)
		{
			alpha = 0xffffffff
			ringKey = "redstarring_00"
		}
		else
		{
			alpha = 0x80c0c0c0
			ringKey = "medal_02_00"
		}
		Renderer.drawCustomSprite(ringKey, px + 48, py, 0, SPRITE_FLAG_PRIO, 0xfff1, 0, alpha, 0x8000)	// (12, 12) is center of medal
	}
}



// Render Marathon Mode HUD elements.
// This is only the emerald count right now. The full-game timer is handed at the end of a frame.
function void RenderHUD_Marathon()
{
	letters_marathonhud = true		// set a flag that says to monospace the character "1" in the marathon hud
	Letters.Main()

	u16 py = 201	// height without Red Star Rings HUD
	if (time_attack == 3 && !debug_mode.enabled && !global.stage_type && global.zone_act != 0x0a01 && global.zone_act != 0x0c00 && global.characters != 0 && !(global.characters == 3 && useKnucklesAndTails))	// Marathon with emeralds
	{
		if (!(System.getGlobalVariableValueByName("DAGE_characterName") || Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") || u8[0xffffe654]))
			py -= 16	// move above Red Star Ring
	}
	if (time_attack == 3)
		Letters.Show(stringformat("Chaos: %01d/7`Super: %01d/7", global.chaos_emeralds, global.super_emeralds), 1, getScreenWidth() - 73, py)
	letters_marathonhud = false

//	RenderMarathonTimer()
}



// Don't draw the life counter or score counter in time attack modes.
// Function modified from maingame\hud\hud.lemon
//# address-hook(0x00db44) end(0x00dbb2)
function void RenderHUD_Challenges()
{
	if ((global.game_mode & 0x7f) == 0x4c || (global.game_mode & 0x7f) == 0x2c)	// stop the HUD from showing in Data Select and Green Sphere menus due to leaving a time attack
		return

	System.callFunctionByName("RenderBoostBar")	// 3D in 2D Shadow boost bar is in standard RenderHUD(), so we need a copy in the Challenges variant
	System.callFunctionByName("shadow.RenderBoostBar")	// same, but for Extra Slot Shadow

#if STANDALONE
	if (DEBUG_DISABLE_HUD)
		return
#endif

	if (!draw_HUD)
		return

	s16 baseX = global.level_started
	if (baseX < 0)
	{
		baseX += 8
		global.level_started = baseX
	}
	baseX += 0x0f
	s16 baseY = 0x08
	u16 renderQueue = 0xe000

	bool isBonusStage = (global.zone >= 0x13 && global.zone <= 0x15)
#if STANDALONE
	if (!debug_mode.state)
	{
		if (!isBonusStage)
		{
			// Score
            if (time_attack != 1 && time_attack != 2)
            {
    			HUD.drawSprite("hud_text_score", baseX, baseY, renderQueue)
	    		++renderQueue
		    	HUD.drawNumber("hud_digit_%d", player.score * 10, baseX + 0x58, baseY, renderQueue)
			    ++renderQueue
            }

			// Time
			{
				bool show = (timer.minutes < 9 || isBonusStage || (level.framecounter & 0x08) || Game.getSetting(SETTING_INFINITE_TIME))
				HUD.drawSprite(show ? "hud_text_time" : "hud_text_time_red", baseX, baseY + 0x10, renderQueue)
				++renderQueue

				// Unfortunately, the time progress is done later inside the frame, so we don't have the right value in "timer.frames" yet
				//  -> If the conditions for time progress are met, add one and everything will be alright
				u16 minutes = timer.minutes
				u16 seconds = timer.seconds
				u16 frames = timer.frames
				if (hud.dirty.timer && timer.alldata < 0x93b3b)	// That is 9:59 and 59 frames. Check used to have && !global.game.paused in middle.
				{
					++frames
					seconds += (frames / 60)
					minutes += (seconds / 60)
					frames %= 60
					seconds %= 60
				}
				u16 centiseconds = (frames * 99 + 30) / 59

				u16 px = (minutes >= 10) ? (baseX + 8) : baseX
				if (Game.getSetting(SETTING_EXTENDED_HUD) || time_attack)
				{
					if (minutes >= 10)
						HUD.drawDigit_Challenges(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit_Challenges(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_minutes", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit_Challenges(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit_Challenges(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_seconds", px + 0x48, baseY + 0x10, renderQueue)
					HUD.drawDigit_Challenges(centiseconds / 10, px + 0x50, baseY + 0x10, renderQueue)
					if (minutes < 10)
						HUD.drawDigit_Challenges(centiseconds % 10, px + 0x58, baseY + 0x10, renderQueue)
				}
				else
				{
					if (minutes >= 10)
						HUD.drawDigit_Challenges(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit_Challenges(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_colon", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit_Challenges(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit_Challenges(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
				}
				++renderQueue
			}
			// Medal Times in Challenges
			RenderHUD_MedalTimes()
		}

		// Rings
		{
			u16 py = (isBonusStage) ? baseY : baseY + 0x20
			bool show = (ring_counter != 0 || (level.framecounter & 0x08))
			HUD.drawSprite(show ? "hud_text_rings" : "hud_text_rings_red", baseX, py, renderQueue)
			++renderQueue

			u16 px = baseX + (!isBonusStage && (Game.getSetting(SETTING_EXTENDED_HUD) && time_attack != 1 && time_attack != 2) ? 0x58 : 0x40)
			for (u32 value = ring_counter;;)
			{
				HUD.drawDigit_Challenges(value % 10, px, py, renderQueue)
				px -= 8
				value /= 10
				if (value == 0)
					break
			}
			++renderQueue
		}

		// Lives (not visible in Time Attack)
		if (time_attack != 1 && time_attack != 2 && !Game.getSetting(SETTING_INFINITE_LIVES) && !original_mode)
		{
			bool useMobilePosition = HUD.useMobileLivesDisplay()
			u16 px = useMobilePosition ? (getScreenWidth() - baseX - 0x30) : baseX
			u16 py = useMobilePosition ? baseY : 200

			u64 characterName
			if (getMainCharacter() == CHARACTER_SONIC)
				characterName = "sonic"
			else if (getMainCharacter() == CHARACTER_TAILS)
				characterName = (global.region_code & 0x80) ? "tails" : "miles"
			else
				characterName = "knuckles"
			HUD.drawSprite(stringformat("hud_lives_icon_%s", characterName), px, py, renderQueue)
			++renderQueue

			if (lives_counter >= 10)
				HUD.drawSmallDigit(u16((lives_counter / 10) % 10), px + 0x20, py + 8, renderQueue)
			HUD.drawSmallDigit(u16(lives_counter % 10), px + 0x28, py + 8, renderQueue)
		}

		// Best time display
		else if (best_time != 0x00ffffff && (time_attack == 1 || time_attack == 2))	// the leading two zeroes on best_time come from it being anded with 0x00ffffff when set
		{
			u16 px = time_attack_hud ? (baseX + (getScreenWidth() / 2 - 64)) : baseX
			u16 py = 200 + 4	// there is a 4-pixel height difference between the life counter and HUD text. We choose to bottom-align.

			if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			{
				Flicky.BestText(px, py, renderQueue)
			//	py += 1
			}
			else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			{
				Saturn.BestText(px, py, renderQueue)
			}
			else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			{
				South.BestText(px, py, renderQueue)
			}
			else
				Renderer.drawCustomSprite("hud_text_best", px, py, 0, SPRITE_FLAG_PRIO, renderQueue)

			u16 minutes = best_time_minutes
			u16 seconds = best_time_seconds
			u16 frames = best_time_frames
			u16 centiseconds = (frames * 99 + 30) / 59

			HUD.drawDigit_Challenges(minutes % 10, baseX + 0x28, py + 0x10, renderQueue)
			HUD.drawSprite("hud_char_minutes", baseX + 0x30, py + 0x10, renderQueue)
			HUD.drawDigit_Challenges(seconds / 10, baseX + 0x38, py + 0x10, renderQueue)
			HUD.drawDigit_Challenges(seconds % 10, baseX + 0x40, py + 0x10, renderQueue)
			HUD.drawSprite("hud_char_seconds", baseX + 0x48, py + 0x10, renderQueue)
			HUD.drawDigit_Challenges(centiseconds / 10, baseX + 0x50, py + 0x10, renderQueue)
			HUD.drawDigit_Challenges(centiseconds % 10, baseX + 0x58, py + 0x10, renderQueue)
		}
	}
	else
#endif
	{
		D4 = (isBonusStage) ? 8 : 0

		if ((level.framecounter & 0x08) == 0)
		{
			if (ring_counter == 0)
			{
				D4 += 2
			}
			if (timer.minutes == 9 && !isBonusStage)
			{
				D4 += 4
			}
		}

		// Targets:
		//  - 0x00dbc2	-> D4.u16 = 0x00
		//  - 0x00dc00	-> D4.u16 = 0x02
		//  - 0x00dc32	-> D4.u16 = 0x04
		//  - 0x00dc96	-> D4.u16 = 0x08
		//  - 0x00dcb6	-> D4.u16 = 0x0a
		A1 = tableLookupAddress(0x00dbb6, D4.u16)

		D4.s16 = u16[A1] - 1
		D0.s16 = baseX + 0x80
		D1.u16 = 0x0108
		D5.u16 = 0x86ca
		A1 += 2
		if (D4.s16 >= 0)
		{
			writeToSpriteTable(renderQueue)
		}
	}
}


function void RenderHUD_MedalTimes()
{
	if ((time_attack == 1 || time_attack == 2) && !time_attack_end && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") && !u8[0xffffe654])
	{
		u16 medal_px = getScreenExtend() - 40 + 400 - 0x35 - 0x10	// 0x35 to make sure it doesn't run off the right edge, and then 0x10 to space it away from the edge
		u16 medal_py = 8 + 1	// most HUDs are 9 pixels from the top of the screen, not 8

		u8 medalOffset = (0x10 * (levelselect.characters - 1))
		// Due to how the timer works by starting at 0'00"02, there's a one-frame timer offset. Thus we use < instead of <= for these checks, to hide that frame.
		if ((timer.alldata < u32[0x840240 + (0x10 * (setting.levelselect.characters - 1))]) && u8[best_time_address] == 3)				// dev time? (only show if gold medal already earned)
		{
			medalOffset = 0x00
			if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				Flicky.DevText(medal_py)
			else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				Saturn.DevText(medal_py)
			else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				South.DevText(medal_py)
			else
				Renderer.drawCustomSprite("angel_text_dev", getScreenWidth() - 97, medal_py + 1, 0, SPRITE_FLAG_PRIO, 0xf003)

		//	Renderer.drawText("sonic3_fontB", getScreenExtend() - 40 + 303, medal_py + 8, "DEV", 0xffffffff, 1, 0, 0xffff, 0)	// one to the left of S3D small text
		}
		else if (timer.alldata < u32[0x840240 + (0x10 * (setting.levelselect.characters - 1)) + 0x04])	// gold medal?
		{
			medalOffset = 0x04
			Renderer.drawCustomSprite("star_gold", getScreenWidth() - 81, medal_py, 0, SPRITE_FLAG_PRIO, 0xf003)
		}
		else if (timer.alldata < u32[0x840240 + (0x10 * (setting.levelselect.characters - 1)) + 0x08])	// silver medal?
		{
			medalOffset = 0x08
			Renderer.drawCustomSprite("star_silver", getScreenWidth() - 81, medal_py, 0, SPRITE_FLAG_PRIO, 0xf003)
		}
		else if (timer.alldata < u32[0x840240 + (0x10 * (setting.levelselect.characters - 1)) + 0x0c])	// bronze medal?
		{
			medalOffset = 0x0c
			Renderer.drawCustomSprite("star_bronze", getScreenWidth() - 81, medal_py, 0, SPRITE_FLAG_PRIO, 0xf003)
		}
		else
			medalOffset = 0xff	// null value that avoids drawing any target times

		if (medalOffset != 0xff)
		{
			if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				Flicky.TargetTime(medal_px, medal_py, medalOffset)
			else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				Saturn.TargetTime(medal_px, medal_py, medalOffset)
			else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
				South.TargetTime(medal_px, medal_py, medalOffset)
			else
			{
				u32 medal_time_address = 0x840240 + (0x10 * (setting.levelselect.characters - 1)) + medalOffset
				u16 medal_time_minutes = u8[medal_time_address + 1]
				u16 medal_time_seconds = u8[medal_time_address + 2]
				u16 medal_time_frames = u8[medal_time_address + 3]
				u16 medal_time_centiseconds = (medal_time_frames * 99 + 30) / 59

				Renderer.drawCustomSprite(stringformat("angel_smalldigit_%d", medal_time_minutes % 10), getScreenExtend() - 40 + medal_px, medal_py + 1, 0, SPRITE_FLAG_PRIO, 0xf003)
				Renderer.drawCustomSprite("angel_smallchar_minutes", getScreenExtend() - 40 + medal_px + 0x07, medal_py + 1, 0, SPRITE_FLAG_PRIO, 0xf003)
				Renderer.drawCustomSprite(stringformat("angel_smalldigit_%d", medal_time_seconds / 10), getScreenExtend() - 40 + medal_px + 0x0d, medal_py + 1, 0, SPRITE_FLAG_PRIO, 0xf003)
				Renderer.drawCustomSprite(stringformat("angel_smalldigit_%d", medal_time_seconds % 10), getScreenExtend() - 40 + medal_px + 0x15, medal_py + 1, 0, SPRITE_FLAG_PRIO, 0xf003)
				Renderer.drawCustomSprite("angel_smallchar_seconds", getScreenExtend() - 40 + medal_px + 0x1d, medal_py + 1, 0, SPRITE_FLAG_PRIO, 0xf003)
				Renderer.drawCustomSprite(stringformat("angel_smalldigit_%d", medal_time_centiseconds / 10), getScreenExtend() - 40 + medal_px + 0x25, medal_py + 1, 0, SPRITE_FLAG_PRIO, 0xf003)
				Renderer.drawCustomSprite(stringformat("angel_smalldigit_%d", medal_time_centiseconds % 10), getScreenExtend() - 40 + medal_px + 0x2d, medal_py + 1, 0, SPRITE_FLAG_PRIO, 0xf003)
			}
		}
	}
}




// This is a copy of RenderHUD() that always considers the HUD to not be extended, for use in Original Mode.
// Function mimicked from maingame\hud\hud.lemon
function void RenderHUD_Orig()
{
	if (Mods.isModActive("Megamix HUD"))	// popular mod that uses unique sprite keys for RINGS text display
	{
		RenderHUD()							// While most HUD mods are disabled in Classic Mode, this one uses scripting
		return								// and is best not interfered with.
	}

#if STANDALONE
	if (DEBUG_DISABLE_HUD)
		return
#endif

	if (!draw_HUD)
		return

	s16 baseX = global.level_started
	if (baseX < 0)
	{
		baseX += 8
		global.level_started = baseX
	}
	baseX += 0x0f
	s16 baseY = 0x08
	u16 renderQueue = 0xe000

	bool isBonusStage = (global.zone >= 0x13 && global.zone <= 0x15)
#if STANDALONE
/*
	if (!debug_mode.state)
	{
		if (!isBonusStage)
		{
			// Score
			HUD.drawSprite("hud_text_score", baseX, baseY, renderQueue)
			++renderQueue
			HUD.drawNumber("hud_digit_%d", player.score * 10, baseX + 0x58, baseY, renderQueue)
			++renderQueue

			// Time
			{
				bool show = (timer.minutes < 9 || isBonusStage || (level.framecounter & 0x08) || Game.getSetting(SETTING_INFINITE_TIME))
				HUD.drawSprite(show ? "hud_text_time" : "hud_text_time_red", baseX, baseY + 0x10, renderQueue)
				++renderQueue

				// Unfortunately, the time progress is done later inside the frame, so we don't have the right value in "timer.frames" yet
				//  -> If the conditions for time progress are met, add one and everything will be alright
				u16 minutes = timer.minutes
				u16 seconds = timer.seconds
				u16 frames = timer.frames
				if (hud.dirty.timer && !global.game.paused && timer.alldata < 0x93b3b)	// That is 9:59 and 59 frames
				{
					++frames
					seconds += (frames / 60)
					minutes += (seconds / 60)
					frames %= 60
					seconds %= 60
				}
				u16 centiseconds = (frames * 99 + 30) / 59

				u16 px = (minutes >= 10) ? (baseX + 8) : baseX
//				if (Game.getSetting(SETTING_EXTENDED_HUD))
//				{
//					if (minutes >= 10)
//						HUD.drawDigit(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
//					HUD.drawDigit(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
//					HUD.drawSprite("hud_char_minutes", px + 0x30, baseY + 0x10, renderQueue)
//					HUD.drawDigit(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
//					HUD.drawDigit(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
//					HUD.drawSprite("hud_char_seconds", px + 0x48, baseY + 0x10, renderQueue)
//					HUD.drawDigit(centiseconds / 10, px + 0x50, baseY + 0x10, renderQueue)
//					if (minutes < 10)
//						HUD.drawDigit(centiseconds % 10, px + 0x58, baseY + 0x10, renderQueue)
//				}
//				else
//				{
					if (minutes >= 10)
						HUD.drawDigit(minutes / 10, px + 0x20, baseY + 0x10, renderQueue)
					HUD.drawDigit(minutes % 10, px + 0x28, baseY + 0x10, renderQueue)
					HUD.drawSprite("hud_char_colon", px + 0x30, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds / 10, px + 0x38, baseY + 0x10, renderQueue)
					HUD.drawDigit(seconds % 10, px + 0x40, baseY + 0x10, renderQueue)
//				}
				++renderQueue
			}
		}

		// Rings
		{
			u16 py = (isBonusStage) ? baseY : baseY + 0x20
			bool show = (ring_counter != 0 || (level.framecounter & 0x08))
			HUD.drawSprite(show ? "hud_text_rings" : "hud_text_rings_red", baseX, py, renderQueue)
			++renderQueue

//			u16 px = baseX + (!isBonusStage && Game.getSetting(SETTING_EXTENDED_HUD) ? 0x58 : 0x40)
			u16 px = baseX + 0x40
			for (u32 value = ring_counter;;)
			{
				HUD.drawDigit(value % 10, px, py, renderQueue)
				px -= 8
				value /= 10
				if (value == 0)
					break
			}
			++renderQueue
		}

		// Lives (not visible in Time Attack or with infinite lives setting)
		if (!Game.isTimeAttack() && (!Game.getSetting(SETTING_INFINITE_LIVES) || original_mode))
		{
			bool useMobilePosition = HUD.useMobileLivesDisplay()
			u16 px = useMobilePosition ? (getScreenWidth() - baseX - 0x30) : baseX
			u16 py = useMobilePosition ? baseY : 200

			HUD.drawSprite(getCharacterLivesIcon(getMainCharacter()), px, py, renderQueue)
			++renderQueue

			if (lives_counter >= 10)
				HUD.drawSmallDigit(u16((lives_counter / 10) % 10), px + 0x20, py + 8, renderQueue)
			HUD.drawSmallDigit(u16(lives_counter % 10), px + 0x28, py + 8, renderQueue)
		}
	}
	else
*/
#endif
	{
		D4 = (isBonusStage) ? 8 : 0

		if ((level.framecounter & 0x08) == 0)
		{
			if (ring_counter == 0)
			{
				D4 += 2		// Set rings HUD text to flicker
			}
			if (timer.minutes == 9 && !isBonusStage)
			{
				D4 += 4		// Set timer HUD text to flicker
			}
		}

		// Targets:
		//  - 0x00dbc2	-> D4.u16 = 0x00		// Complete HUD text
		//  - 0x00dc00	-> D4.u16 = 0x02		// HUD with rings text flickering
		//  - 0x00dc32	-> D4.u16 = 0x04		// HUD with time text flickering
		//  - 0x00dc6a	-> D4.u16 = 0x06		// HUD with both rings and time flickering
		//  - 0x00dc96	-> D4.u16 = 0x08		// Bonus stage HUD
		//  - 0x00dcb6	-> D4.u16 = 0x0a		// Bonus stage HUD with rings text flickering
		A1 = tableLookupAddress(0x00dbb6, D4.u16)

		D4.s16 = u16[A1] - 1
		D0.s16 = baseX + 0x80
		D1.u16 = 0x0108
		D5.u16 = 0x86ca
		A1 += 2
		if (D4.s16 >= 0)
		{
			writeToSpriteTable(renderQueue)
		}
	}
}






// Stop the timer from progressing if time should be frozen and play a sound effect every second
// and enforce Time Over in Original Mode
// Function taken from maingame\hud\hud.lemon
//# address-hook(0x00dd06) end(0x00de86)
function void UpdateTimeAndHud()
{
	if (competition_mode.active == 0)
	{
		if (debug_mode.state == 0)
		{
			// Update score
			if (hud.dirty.score)
			{
				hud.dirty.score = 0
				D0 = 0x5c800003
				D1 = player.score
				RefreshScoreHudDisplay()
			}

			// Update rings
			if (hud.dirty.rings != 0)
			{
				if (hud.dirty.rings & 0x80)
				{
					ResetRingsDisplay()
				}
				hud.dirty.rings = 0
				D0 = 0x5f400003
				D1 = ring_counter
				RefreshRingsHudDisplay()
			}

			// Update time
			bool updateTimerHUD = false
			if (freeze_time)	// if there is freeze time remaining
			{
//				if (freeze_time % 15 == 0)	// if we are on a quarter-second of frozen time
//					playSound(0x5b)			// play appropriate sound	// 0x89 could also be appropriate

				if (freeze_time % 60 == 0 && !global.game.paused)	// if we are on an exact second of frozen time remaining
					playSound(0xdf)			// play appropriate sound	// 0x89 could also be appropriate
				if (!global.game.paused)
					--freeze_time			// decrement frames remaining by 1
			}
			else if (hud.dirty.timer & 0x80)
			{
				hud.dirty.timer = 0x01
				updateTimerHUD = true
			}
			else if (hud.dirty.timer != 0 && !global.game.paused)
			{
			#if STANDALONE
				if (Game.getSetting(SETTING_INFINITE_TIME) && !(time_attack == 1 || time_attack == 2) && !original_mode)	// force certain time attack modes to ignore infinite time settings
				{
					if (timer.alldata == 0x3b3b3b)		// That is 59:59 and 59 frames
					{
						// Reset back to 0
						timer.alldata = 0
					}
				}
				else
			#endif
				{
					if (timer.alldata == 0x93b3b)		// That is 9:59 and 59 frames
					{
						// Time over
						hud.dirty.timer = 0
						A0 = 0xffffb000
						if (objA0.base_state < 0x06 && global.zone != 0x15)
						{
							A2 = A0
							Character.Die()
						}
						global.time_over = 1
						return
					}
				}

				// Time progress

//				if (freeze_time)	// if there is freeze time remaining
//				{
//					if (freeze_time % 15 == 0)	// if we are on a quarter-second of frozen time
//						playSound(0x5b)			// play appropriate sound	// 0x89 could also be appropriate
//					--freeze_time	// decrement frames remaining by 1
//				}
//				else
//				{
					++timer.frames
					if (timer.frames >= 60)
					{
						timer.frames = 0
						++timer.seconds
						if (timer.seconds >= 60)
						{
							timer.seconds = 0
							++timer.minutes

						#if STANDALONE
							if (!Game.getSetting(SETTING_INFINITE_TIME) || original_mode)
						#endif
							{
								timer.minutes = min(timer.minutes, 9)
							}
						}
					updateTimerHUD = true
					}
//				}
			}

			if (updateTimerHUD)
			{
				D0 = VDPHelper.getDirectVRAMWriteCode(0xde40)
				D1 = min(timer.minutes, 9)
				RefreshTimeMinutesHudDisplay()

				D0 = VDPHelper.getDirectVRAMWriteCode(0xdec0)
				D1 = timer.seconds
				RefreshTimeSecondsHudDisplay()
			}

			// Update lives
			if (hud.dirty.lives != 0)
			{
				hud.dirty.lives = 0
				UpdateHudLivesDisplay()
			}
		}
		else
		{
			// Debug mode
			DebugModePositionDisplay()
			if (hud.dirty.rings != 0)
			{
				if (hud.dirty.rings & 0x80)
				{
					ResetRingsDisplay()
				}
				hud.dirty.rings = 0
				D0 = 0x5f400003
				D1 = ring_counter
				RefreshRingsHudDisplay()
			}

			D0 = VDPHelper.getDirectVRAMWriteCode(0xde40)
			D1 = global.lag_frames
			RefreshTimeMinutesHudDisplay()

			D0 = VDPHelper.getDirectVRAMWriteCode(0xdec0)
			D1 = u8[0xfffff62c]
			RefreshTimeSecondsHudDisplay()

			if (hud.dirty.lives != 0)
			{
				hud.dirty.lives = 0
				UpdateHudLivesDisplay()
			}

			if (!global.game.paused)
			{
				A1 = 0xfffffe26
				--A1
				++u8[A1]
				if (u8[A1] >= 60)
				{
					u8[A1] = 0
					--A1
					++u8[A1]
					if (u8[A1] >= 60)
					{
						u8[A1] = 0
						--A1
						++u8[A1]
						if (u8[A1] >= 9)
						{
							u8[A1] = 9
						}
					}
				}
			}
		}
	}
	else
	{
		if (debug_mode.enabled)
		{
			DebugModePositionDisplay()
		}
	}
}




// Draw on top of the existing time digits and text with graphics that fade out as frozen time prepares to resume
// Functions taken from maingame\hud\hud.lemon
function void HUD.drawSprite(u64 key, u16 px, u16 py, u16 renderQueue)
{
	u64 theme_key
	if (!original_mode)
	{
		if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		{
			theme_key = stringformat("%s%s", "flicky_", key)
			Flicky.HUD.drawSprite(theme_key, px, py, renderQueue)
			return
		}
		else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		{
			theme_key = stringformat("%s%s", "saturn_", key)
			Saturn.HUD.drawSprite(theme_key, px, py, renderQueue)
			return
		}
		else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		{
			theme_key = stringformat("%s%s", "south_", key)
			South.HUD.drawSprite(theme_key, px, py, renderQueue)
			return
		}
	}

    u16 inputY = py
  	if ((time_attack == 1 || time_attack == 2) && py != 0x48 && !HUD.isShadowTarget(key))	// 0x48 is the height of Shadow's boost bar
	{
        py -= 0x10
		if (time_attack_hud)	// center HUD?
		{
			//px += 136			// move time and rings to the right, half a pixel left of center
			px += getScreenWidth() / 2 - 64
			if (inputY == 0x28)	// rings?
				px += 13		// move even more to the right. Note that this is 1px more than it should be for aesthetics, lining up TIME's M with RINGS' R.
		}
	}
//	if (px >= 0x58 && px <= 0x68 && py == 0x28)	// Rings in Mania HUD position
//		px -= 0x18								// move to classic position
	Renderer.drawCustomSprite(key, px, py, 0, SPRITE_FLAG_PRIO, renderQueue)
	if (inputY == 0x18 && freeze_time)	// HUD graphics have a base py of 0x08, and the TIME row is 0x10 beyond that
	{
		if (freeze_time >= 64)
		{
			if (key == "hud_char_minutes")
				Renderer.drawCustomSprite("hud_char_minutes_chaosstage", px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, 255)
			else if (key == "hud_char_seconds")
				Renderer.drawCustomSprite("hud_char_seconds_chaosstage", px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, 255)
			else if (key == "hud_char_colon")
				Renderer.drawCustomSprite("hud_char_colon_chaosstage", px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, 255)
			else if (key == "hud_text_time")
				Renderer.drawCustomSprite("hud_text_time_chaosstage", px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, 255)
		}
		else
		{
			if (key == "hud_char_minutes")
				Renderer.drawCustomSprite("hud_char_minutes_chaosstage", px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, freeze_time * 4)
			else if (key == "hud_char_seconds")
				Renderer.drawCustomSprite("hud_char_seconds_chaosstage", px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, freeze_time * 4)
			else if (key == "hud_char_colon")
				Renderer.drawCustomSprite("hud_char_colon_chaosstage", px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, freeze_time * 4)
			else if (key == "hud_text_time")
				Renderer.drawCustomSprite("hud_text_time_chaosstage", px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, freeze_time * 4)
		}
	}
}

function void HUD.drawDigit_Challenges(u8 digit, u16 px, u16 py, u16 renderQueue)
{
	if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
	{
		Flicky.HUD.drawDigit_Challenges(digit, px, py, renderQueue)
		return
	}
	else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
	{
		Saturn.HUD.drawDigit_Challenges(digit, px, py, renderQueue)
		return
	}
	else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
	{
		South.HUD.drawDigit_Challenges(digit, px, py, renderQueue)
		return
	}

    u16 inputY = py
    if (time_attack == 1 || time_attack == 2)
	{
        py -= 0x10
		if (time_attack_hud)	// center HUD?
		{
			// px += 136			// move time and rings to the right, half a pixel left of center
			px += getScreenWidth() / 2 - 64
			if (inputY == 0x28)	// rings?
				px += 12		// move even more to the right
		}
	}
	Renderer.drawCustomSprite(stringformat("hud_digit_%d", digit), px, py, 0, SPRITE_FLAG_PRIO, renderQueue)
	if (inputY == 0x18 && freeze_time)	// HUD graphics have a base py of 0x08, and the TIME row is 0x10 beyond that
		if (freeze_time >= 64)
			Renderer.drawCustomSprite(stringformat("hud_digit_%d_chaosstage", digit), px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, 255)
		else
			Renderer.drawCustomSprite(stringformat("hud_digit_%d_chaosstage", digit), px, py, 0, SPRITE_FLAG_PRIO, renderQueue + 1, 0, freeze_time * 4)
}





// Custom function that ensures Time Attack and Time Stone Trial HUD repositionings don't affect Shadow's boost bar
function bool HUD.isShadowTarget(u64 key)
{
	if (key == "shadow_target_0" || key == "shadow_target_1" || key == "shadow_target_2" || key == "shadow_target_3" || key == "shadow_target_4" || key == "shadow_target_5" || key == "shadow_target_6" || key == "shadow_target_7" || key == "shadow_target_8")
		return true
	else
		return false
}








// All calls to Character.GettingHurt() must be preceded by a check for if frozen time should resume.
// Unfreezing time in Character.GettingHurt() directly means any mod that modifies hurt behavior (e.g., 3D in 2D Shadow) won't unfreeze time properly.

// Function taken from maingame\character\character.lemon
//# address-hook(0x01028a) end(0x010392)
function void Character.OnThreatCollisionInner()
{
	if (char.invuln.countdown != 0)
	{
		D0 = 0xffffffff
	}
	else
	{
		A2 = A1
		if (((char.bonus_effect & char.bonus.ANY_SHIELD) == 0) && (u8[0xffffb037] & 0x80) == 0)	// if the character is not protected by a shield or object (e.g. MGZ top)
			freeze_time = 0
		Character.GettingHurt()
	}
}

// Function taken from bosses\boss_lbz2_3.lemon
// Since there are no bosses in Time Stone Trial, this is theoretically unnecessary, but it's harmless to cover this case.
//# address-hook(0x074640) end(0x0746c2)
function void fn074640()
{
	objA0.base_state = 0x2a
	u8[A0 + 0x30] = 0
	objA0.position.y.u16 -= 0x10
	objA0.flags38 &= ~0x02

	objA0.velocity.x = (objA0.render_flags & render_flag.FLIP_X) ? -0x400 : 0x400
	objA0.velocity.y = -0x600
	objA0.countdown_value = 0x3f

	if (u8[0xffffb02b] & char.bonus.INVINCIBLE)
	{
		// Handling primarily for Super forms
		A1 = 0xffffb000
		u8[A1 + 0x05] = 0x02
		objA1.velocity.x = -objA0.velocity.x
		objA1.velocity.y = -0x400
		objA1.state = char.state.ROLLING
		objA1.flags2a |= char.flag.IN_AIR
		objA1.flags2a &= ~char.flag.ON_OBJECT
		u8[A1 + 0x2e] = 0
		u8[A1 + 0x3d] = 0
		u8[A1 + 0x40] = 0

		playSound(0xb1)
	}
	else
	{
		A2 = A0
		A0 = 0xffffb000
		if (((char.bonus_effect & char.bonus.ANY_SHIELD) == 0) && (u8[0xffffb037] & 0x80) == 0)	// if the character is not protected by a shield or object (e.g. MGZ top)
			freeze_time = 0
		Character.GettingHurt()
		A0 = A2
	}
}

// Function taken from enemies\icz_freezer.lemon
//# address-hook(0x08a84c)
function void fn08a84c()
{
	A1 = 0xffff0000 + u16[A0 + 0x44]
	D0.u16 = objA0.position.x.u16
	D1.u16 = objA0.position.y.u16
	if (u8[A1 + 0x38] == CHARACTER_KNUCKLES)
	{
		D2 = (u8[A1 + 0x04] & 0x01) ? 4 : -4
		D0.u16 += D2.u16
		D1.u16 += 2
	}

	objA1.position.x.u16 = D0.u16
	objA1.position.y.u16 = D1.u16
	--objA0.countdown_value
	if (objA0.countdown_value >= 0)
	{
		fn08aa38()
		if (_equal())
		{
			DrawObject()
			return
		}
	}
	else
	{
		A1 = 0xffff0000 + u16[A0 + 0x44]
		A2 = A0
		A0 = A1
		if (((char.bonus_effect & char.bonus.ANY_SHIELD) == 0) && (u8[0xffffb037] & 0x80) == 0)	// if the character is not protected by a shield or object (e.g. MGZ top)
			freeze_time = 0
		Character.GettingHurt()
		if (objA0.state != 0x18)
		{
			objA0.velocity.x = (objA0.render_flags & render_flag.FLIP_X) ? 0x200 : -0x200
		}
		A0 = A2
	}

	A1 = 0xffff0000 + u16[A0 + 0x44]
	u8[A1 + 0x2a] |= 0x02
	u8[A1 + 0x2e] = 0
	u8[A1 + 0x34] = 0x78
	spawnChildObjects(0x08aaea)
	UnloadObject()
}

// Function taken from objects\05_icz\icz_icecrystal.lemon
//# address-hook(0x08b4ec) end(0x08b526)
function void fn08b4ec()
{
	D0 = u8[A0 + 0x29]
	if (D0.u8 == 0)
	{
		Enemy.DrawOrUnload()
		return
	}

	D0.u16 *= 2
	A1 = 0xffff0000 + u16[0x08b52a + D0.s16]
#if STANDALONE
	// Also check for:
	//  - Invulnerability frames
	//  - And for the fire shield
	if (u8[A1 + 0x34] == 0 && (u8[A1 + 0x2b] & char.bonus.INVINCIBLE) == 0 && (u8[A1 + 0x2b] & char.bonus.SHIELD_FIRE) == 0)
#else
	if ((u8[A1 + 0x2b] & char.bonus.INVINCIBLE) == 0)
#endif
	{
		A2 = A0
		A0 = A1
		if (((char.bonus_effect & char.bonus.ANY_SHIELD) == 0) && (u8[0xffffb037] & 0x80) == 0)	// if the character is not protected by a shield or object (e.g. MGZ top)
			freeze_time = 0
		Character.GettingHurt()
		A0 = A2
	}

	spawnSimpleChildObjects(0x08b54a)
	Object.TriggerUnloading()
	playSound(0x80)
	DrawObject()
}

// Function taken from enemies\shared.lemon
//# address-hook(0x0857b4) end(0x0857c0)
function void Enemy.DamageCharacter()
{
	A2 = A0
	A0 = A1
	if (((char.bonus_effect & char.bonus.ANY_SHIELD) == 0) && (u8[0xffffb037] & 0x80) == 0)	// if the character is not protected by a shield or object (e.g. MGZ top)
		freeze_time = 0
	Character.GettingHurt()
	A0 = A2
}

// Function taken from objects\basics\spikes.lemon
//# address-hook(0x024280) end(0x0242b4)
function void DamageCharacter()
{
	if ((u8[A1 + 0x2b] & char.bonus.INVINCIBLE) == 0)
	{
		if (u8[A1 + 0x34] == 0 && u8[A1 + 0x05] < 4)
		{
			D3 = u32[A1 + 0x14]
			D0 = s32(objA1.velocity.y) << 8
			D3 -= D0
			u32[A1 + 0x14] = D3
			A2 = A0
			A0 = A1

			// Hurt character
			if (((char.bonus_effect & char.bonus.ANY_SHIELD) == 0) && (u8[0xffffb037] & 0x80) == 0)	// if the character is not protected by a shield or object (e.g. MGZ top)
				freeze_time = 0
			Character.GettingHurt()
			A0 = A2
		}
	}
}







// If the timer is frozen and the player loses rings or dies, unfreeze the timer.
// This is handled in multiple functions: one for taking damage and others for instant death (pits, crush, etc.)
// Functions taken from maingame\character\character.lemon
//# address-hook(0x010366) end(0x01036c)
function void Character.Die()
{
	freeze_time = 0				// Unfreeze the timer on death

	if (debug_mode.state == 0)
	{
		Character.Die_noSound()
		playSound(0x35)
	}
	D0 = 0xffffffff
}

//# address-hook(0x01036e) end(0x0103b8)
function void Character.Die_internal()
{
	freeze_time = 0				// Unfreeze the timer on death

	u8 soundId = D0.u8
	Character.Die_noSound()
	playSound(soundId)
	D0 = 0xffffffff
}


function void Character.Die_noSound()
{
	freeze_time = 0				// Unfreeze the timer on death

	char.bonus_effect = 0
	char.protection_flag = 0
	char.base_state = 0x06		// Character died

	Character.LandingOnGroundNoSpindash()

	char.flags |= char.flag.IN_AIR
	char.velocity.x = 0
	char.velocity.y = -0x700	// Moving up over the screen one last time
	char.groundspeed = 0
	char.state = char.state.DIED

	u16[0xffffffce] = char.sprite_attributes
	u8[A0 + 0x0a] |= 0x80
}





//-------------------------------------------------------//
// Mini Time Stone (based on debug mode ring)            //
//-------------------------------------------------------//

//# address-hook(0x01a51c)
function void MiniTimeStone()
{
	if (time_attack != 2)
	{
		UnloadObject()
		return
	}

	call 0x01a51e + objA0.base_state	// Each function in order is 0x02 apart in address hooks.
										// 0x1a528 is used by debug rings, so more functions *cannot* be added via this system without other changes! Use if/else instead.

//	if (objA0.base_state == 0)
//		MiniTimeStone_Init()
//	else if (objA0.base_state == 2)
//		MiniTimeStone_Animate()
//	else if (objA0.base_state == 4)
//		MiniTimeStone_Collect()
//	else if (objA0.base_state == 6)
//		MiniTimeStone_CollectAnimate()
//	else
//		UnloadObject()
}


//# address-hook(0x01a51e)
function void MiniTimeStone_Init()
{
	objA0.base_state += 2
	objA0.mapping_offset = 0x01a99a
	objA0.sprite_attributes = 0xa6bc
	objA0.render_flags = render_flag.WORLD
	objA0.sprite_priority = 0x0100
	u8[A0 + 0x28] = 0x47	// collision response bitfield
	objA0.box_size.x = 0x08
	objA0.box_size.y = 0x08		// added to hopefully cut down on pop in/out
	if (objA0.subtype2c == 1)
	{
		objA0.box_size.x = 0x20
		objA0.box_size.y = 0x40		// added to hopefully cut down on pop in/out
		objA0.hitbox_extends.x = 0x10
		objA0.hitbox_extends.y = 0x10
		u8[A0 + 0x28] = 0x56	// Collision response bitfield.
								// The first two bits are type: 00 for enemy, 01 for increment objA0.base_state by 2 (next routine), 10 harms player, 11 is for star post.
								// The last six bits map to table entries in Touch_Sizes in the disassembly, which give widths and heights. (Here, width = height = 0x20.)
	}

	MiniTimeStone_Animate()
}


//# address-hook(0x01a520)
function void MiniTimeStone_Animate()
{
	// Smoother ring animations taken from maingame\static_rings.lemon. This doesn't render without more hooked up to it.
//	u8 animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8
//	u64 key = stringformat("ring_0%d", animFrame)
//	u16 x = D0.u16 - 0x80
//	u16 y = D1.u16 - 0x80
//	Renderer.drawCustomSprite(key, objA0.position.x.u16, objA0.position.y.u16, 0x00, 0, 0xa000)

//	objA0.animation.sprite = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 4 // spin twice as fast as normal rings with only 4 animation frames
//	u64 key = stringformat("ring_0%d", objA0.animation.sprite * 2)
//	Renderer.drawCustomSprite(key, objA0.position.x.u16 - camera.foreground.x.u16, objA0.position.y.u16 - camera.foreground.y.u16, 0x00, 0, 0xa000)

	objA0.animation.sprite = static_rings.animframe
	fn01b662()
}


//# address-hook(0x01a522)
function void MiniTimeStone_Collect()
{
	objA0.base_state += 2
	u8[A0 + 0x28] = 0
	objA0.sprite_priority = 0x80

	// Alternating twinkle sound mimics and switches the ring sound panning state.
	// This functionality is not hooked up to the sound test.
	if (objA0.subtype2c == 0)
	{
		alternatingRingSoundState = !alternatingRingSoundState
		if (!alternatingRingSoundState)
			playSound(0xde)
		else
			playSound(0xdd)

		freeze_time += 60	// freeze time for 1 second (60 frames)
	}
	else if (objA0.subtype2c == 1)
	{
		playSound(0xe0)		// formerly 0xb8
		freeze_time += 420	// freeze time for 7 seconds (420 frames)
	}
	MiniTimeStone_CollectAnimate()
}


//# address-hook(0x01a524)
function void MiniTimeStone_CollectAnimate()
{
	Object.animationUpdate(0x01a992)
	DrawObject()
}


//# address-hook(0x01a526)
function void MiniTimeStone_Unload()
{
	UnloadObject()
}








// Replace giant rings in Time Stone Trial mode and remove them in standard Time Attack.
// Function taken from objects\basics\giantring.lemon
//# address-hook(0x06166a) end(0x06167c)
function void GiantRing.Init()
{
#if STANDALONE
	if (time_attack == 1 || time_attack == 4)
	{
		UnloadObject()
		return
	}
	else if (time_attack == 2)
	{
		objA0.update_address = 0x01a51c
		objA0.subtype2c = 0x01
		MiniTimeStone_Init()
		return
	}
#endif

	D0.u8 = objA0.subtype2c
	if (level.giantrings_clear & (1 << D0))
	{
		UnloadObject()
	}
	else
	{
		Object.InitWithUpdateAddress(0x061682)
	}
}







// Set giant rings to appear or not appear appropriately for time attack modes
// and set MHZ2 to use a post-cutscene start for Sonic and Tails
// Functions taken from standalone\gamecallbacks.lemon
function void Standalone.onLevelStart()
{
	draw_HUD = true
	System.setGlobalVariableValueByName("ChaosPath", 0)	// At the moment there are some incompatibilities with Chaos starting from the AIZ1 Knuckles start.
														// If these are resolved, ChaosPath must be considered as 0 for Challenges and Marathon modes.
	if (global.zone_act != 0x0301)	// Standalone.onLevelStart() is run in Marathon modes between CNZ1 and CNZ2, and the following background camera lines cause a visual glitch
	{
		camera.background.x = 0		// from function void restartLevel(), which Euka uses as the
		camera.background.y = 0		// fix for the AIZ1 background issue
	}

	if (time_attack >= 3 && original_mode)
	{
		setting.time_attack = time_attack
		time_attack = 0
	}

	green_spheres.active = 0x01	// This is for compatibility with Blue Sphere Time Attack. Without it, entering a randomly-generated Hard Layout
								// Knux Green Sphere stage in the main game would not play the correct music.
	specialstages_knuckles.shared = specialstages_knuckles
	bluespheres.minigame_mode = 0	// ensure that a special stage doesn't take us back to the green sphere menu
	challenge_greenspheres = 0		// ensure normal special stages are loaded
	time_attack_end = 0			// make sure we aren't marked as finishing a challenge

	if (Game.getSetting(SETTING_FIX_GLITCHES) >= 2 || time_attack == 1 || time_attack == 2)
	{
		if (checkpoint.number == 0 && ((global.zone_act == 0x0001 && global.zone_act.apparent == 0x0000) || (global.zone_act == 0x0501 && global.zone_act.apparent == 0x0500)))
			global.zone_act = global.zone_act.apparent	// If in the parts of AIZ1 and ICZ1 that are internally Act 2 with no checkpoints, fully return to Act 1
	}
	if (global.zone_act == 0x0201 && checkpoint.number == 6)
		level.trigger08 = 1	// If we went through the "loop" of MGZ2 and returned to the star post, set the loop's trigger ID

	freeze_time = 0
	air_time = 0

	// These lines don't actually seem to help.
//	ClearPositionBackup()
//	camera.locktime.player1 = 0		// prevent the camera from snapping if the level restarts during a dash camera lock
//	camera.locktime.player2 = 0

//	if (u8[0xffffef7d] == 0 && (time_attack == 1 || time_attack == 2))		// if we've made it into time attack without going through the DAGE main menu (e.g., A.I.R. act select),
//	{
//		time_attack = 0		// revert to standard game behavior
//	}

	loadTASettings()	// without this, levels may restart or exit due to the initial value being zero. It doesn't hurt anything outside of TA mode.

	// Handle achievements
	Game.setAchievementValue(ACHIEVEMENT_MGZ_GIANTRINGS, 0)
	Game.setAchievementValue(ACHIEVEMENT_LBZ_STAY_DRY, (global.zone_act == 0x0601) ? 1 : 0)
	Game.setAchievementValue(ACHIEVEMENT_MHZ_OPEN_MONITORS, 0)
	Game.setAchievementValue(ACHIEVEMENT_FBZ_FREE_ANIMALS, 0)
	Game.setAchievementValue(ACHIEVEMENT_ELECTROCUTE, 0)

	// Load data that usually gets loaded in the main menu, just in case players use AIR menus to get here
	loadBestActTimes()
	loadRSR()

	if (!time_attack)
	{
		// Intentionally not using the (more deterministic) "getRandomNumber" here
		global.level_random_base = 1 + (System.rand() % 0xff)		// Avoid the 0 value
	}
	else if (time_attack == 1 || time_attack == 2)	// time attack or Time Stone Trial start
	{
		lives_counter = 3
		player.score = 0
		TA_menu_selection = 0
		time_attack_end = 0

		loadMedalTimes()

		/*
		if (time_attack == 1)
		{
			key = "DAGE_SonicTA"
			if (levelselect.characters == 0x02)
				key = "DAGE_TailsTA"
			else if (levelselect.characters >= 0x03)
				key = "DAGE_KnuxTA"
		}
		else
		{
			key = "DAGE_SonicTST"
			if (levelselect.characters == 0x02)
				key = "DAGE_TailsTST"
			else if (levelselect.characters >= 0x03)
				key = "DAGE_KnuxTST"
		}
		if !System.loadPersistentData(0x840000, key, 0x60)	// load best times for this character and mode, with a 0 returned if they don't exist
			for (u8 i = 0; i < 0x60; i += 4)
				u32[0x840000 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
		*/

		// Find the best time to display
		best_time_address = global.zone >= 0x0c ? 0x54 : (0x08 * global.zone) + (0x04 * global.act)	// HPZ gets mapped to zone_act 0x0a01 (SSZ2) to avoid gaps in the data
		best_time_address += 0x840000
		if (setting.levelselect.characters == 2 && !System.getGlobalVariableValueByName("DAGE_characterName"))
			best_time_address += 0x60
		if (setting.levelselect.characters >= 3 && !System.getGlobalVariableValueByName("DAGE_characterName"))
			best_time_address += 0xc0
		if (time_attack == 2)
			best_time_address += 0x120

		best_time = u32[best_time_address] & 0x00ffffff	// remove leading byte, which is used for other info regarding saved times
		best_time_minutes = u8[best_time_address + 1]
		best_time_seconds = u8[best_time_address + 2]
		best_time_frames = u8[best_time_address + 3]


//		if (time_attack == 1)		// standard time attack mode
//			level.giantrings_clear = 0xff	// mark all giant rings as already collected
//		else if (time_attack == 2)	// Time Stone Trial mode
//			level.giantrings_clear = 0		// mark all giant rings as uncollected

		// Borrow a check from maingame\maingame.lemon for MHZ2 Sonic/Tails: start post-cutscene
		// Don't use "isMainCharacter" or similar here, it's not initialized yet

//		if (global.zone_act == 0x0000 && levelselect.characters == CHARS_KNUCKLES_ALONE)
//		{
//			checkpoint.number = 1
//			checkpoint.x = 0x03b0	// usually 0x1830
//			checkpoint.y = 0x0219	// usually 0x0119
//		}

		if (global.zone_act == 0x0701 && (setting.levelselect.characters != CHARS_KNUCKLES_ALONE || Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles")))
		{
			// MHZ 2: Start after the initial cutscene
			// TODO: The checkpoint number gets reset to 0 later in initialization again
			//     -> This is fine for Time Attack in MHZ 2, but not in other cases like Time Attack in SSZ
			checkpoint.number = 7
			checkpoint.x = 0x03ec	// 0x052a
			checkpoint.y = 0x0569	// 0x05ac
		}
	}

	// This check for 3D2D Glitches to skip intros in Challenges and Marathon does not work.
//	if (time_attack && Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") && checkpoint.number == 0 && global.zone_act == 0x0000)
//	{
//		checkpoint.number = 1
//		checkpoint.x = 0x06f4
//		checkpoint.y = 0x09ec
//	}

	Game.onLevelStart()
}

function void Standalone.onRestartAtCheckpoint()
{
	draw_HUD = true
	freeze_time = 0

	if (time_attack == 1 || time_attack == 2)
	{
		checkpoint.number = 0
		Standalone.onLevelStart()
	}
	else
	{
		if (global.zone_act == 0x0201 && checkpoint.number == 6)
			level.trigger08 = 1	// If we went through the "loop" of MGZ2 and returned to the star post, set the loop's trigger ID

		// Handle achievements
		Game.setAchievementValue(ACHIEVEMENT_MGZ_GIANTRINGS, 0)
		Game.setAchievementValue(ACHIEVEMENT_FBZ_FREE_ANIMALS, 0)

//		if (time_attack == 1)		// standard time attack mode
//			level.giantrings_clear = 0xff	// mark all giant rings as already collected
//		else if (time_attack == 2)	// Time Stone Trial mode
//			level.giantrings_clear = 0		// mark all giant rings as uncollected
	}
}









function void loadBestActTimes()
{
	if (Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
	{
		loadBestActTimes3D2DGlitches()
		return
	}
	if (System.getGlobalVariableValueByName("DAGE_characterName"))
	{
		loadBestActTimesModded()
		return
	}

	if (!System.loadPersistentData(0x840000, "DAGE_SonicTA", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840000 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x840060, "DAGE_TailsTA", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840060 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x8400c0, "DAGE_KnuxTA", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x8400c0 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x840120, "DAGE_SonicTST", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840120 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x840180, "DAGE_TailsTST", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840180 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x8401e0, "DAGE_KnuxTST", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x8401e0 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned

	// The following section addresses an old glitch in which a vanilla AIR bug could cause a death in the sections of AIZ1 and ICZ1 that are in Act 2 internally
	// to load the player at the miniboss location, finishing the acts in one frame and saving it as an Act 2 record.
	// This glitch has been fixed in DAGE, but times saved while the glitch was present must be removed.
	u32 saved_record_address = 0x840004	// address of AIZ2 saved time, which will get iterated to other things
	while (saved_record_address < 0x840240)	// while working within the saved best times
	{
		if (u32[saved_record_address] == 0x03000001)	// if a time was erroneously set to a gold medal time of 0'00"02,
			u32[saved_record_address] = 0x00ffffff			// remove it
		if (u32[saved_record_address] != 0x8401e4)		// if we didn't just check the time for AIZ2 Knuckles Time Stone Trial,
			saved_record_address += 0x60					// iterate to next saved record for the same act (which ends the while loop after ICZ2 Knux TST)
		else
			saved_record_address = 0x84002c				// shift from AIZ2 times to ICZ2 times
	}
}

function void loadBestActTimes3D2DGlitches()
{
	if (!System.loadPersistentData(0x840000, "DAGE_AshuraTA", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840000 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x840060, "DAGE_WechniaTA", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840060 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x8400c0, "DAGE_BluxTA", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x8400c0 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x840120, "DAGE_AshuraTST", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840120 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x840180, "DAGE_WechniaTST", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840180 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x8401e0, "DAGE_BluxTST", 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x8401e0 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
}

function void loadBestActTimesModded()
{
	u64 moddedCharacterBaseKey = System.getGlobalVariableValueByName("DAGE_characterName")
	u64 moddedCharacterTAKey = stringformat("DAGEmod_%sTA",moddedCharacterBaseKey)
	u64 moddedCharacterTSTKey = stringformat("DAGEmod_%sTST",moddedCharacterBaseKey)

	if (!System.loadPersistentData(0x840000, moddedCharacterTAKey, 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840000 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
	if (!System.loadPersistentData(0x840120, moddedCharacterTSTKey, 0x60))	// load best times for this character and mode, with a 0 returned if they don't exist
		for (u8 i = 0; i < 0x60; i += 4)
			u32[0x840120 + i] = 0x00ffffff	// initialize saved records to 0x00ffffff if a 0 was returned
}

function void loadMedalTimes()
{
	// Load dev and medal times
	u32 medalTimeOffset = (0x20 * global.zone) + (0x10 * global.act) + (0x0480 * (time_attack - 1))
	if (global.zone_act == 0x1601)
		medalTimeOffset -= 0x0180	// reposition HPZ (global.zone_act = 0x1601) to align with SSZ2 (global.zone_act =  0x0a01)
	System.loadExternalRawData("MedalTimes", 0x840240, medalTimeOffset, 0x10, 1, 1)				// load Sonic times
	System.loadExternalRawData("MedalTimes", 0x840250, medalTimeOffset + 0x0180, 0x10, 1, 1)	// load Tails times
	System.loadExternalRawData("MedalTimes", 0x840260, medalTimeOffset + 0x0300, 0x10, 1, 1)	// load Knuckles times
}









// Bosses: do not fade level music and start boss music in time attack modes.
// Most bosses don't even load in time attack, but this is useful for scenes where a boss arena object or camera settings should load, such as the DEZ1 boss eye.
// Function taken from level\level_shared.lemon
//# address-hook(0x085d70) end(0x085d78)
function void fn085d70()
{
	if (time_attack != 1 && time_attack != 2)
		playMusic(MUSIC_CTRL_FADEOUT)
	objA0.countdown_value = 120
	InitBossArea()
}

// Function taken from bosses\bosses_shared.lemon
//# address-hook(0x085ca4) end(0x085d68)
function void CheckForBossStart()
{
	// Condition 1: Countdown (can be zero from start)
	if ((u8[A0 + 0x27] & 0x01) == 0)
	{
		if (time_attack != 1 && time_attack != 2)
			--objA0.countdown_value
		if (objA0.countdown_value < 0)
		{
			u8[A0 + 0x27] |= 0x01
			level.default_music.u8 = objA0.value26
			playMusic(objA0.value26)
		}
	}

	// Condition 2: Camera Y position
	if ((u8[A0 + 0x27] & 0x02) == 0)
	{
		bool fulfilled = false
		if (u8[A0 + 0x27] & 0x80)
		{
			fulfilled = (camera.position.y.u16 <= level.bossarea.bottom + 0x60)
		}
		else
		{
			fulfilled = (camera.position.y.u16 >= level.bossarea.top)
			level.vertical_wrap = camera.position.y.u16		// To be overwritten if condition fulfilled
		}

		if (fulfilled)
		{
			u8[A0 + 0x27] |= 0x02
			level.vertical_wrap = level.bossarea.top
			move_area.bottom.target = level.bossarea.bottom
		}
	}

	// Condition 3: Camera X position
	if ((u8[A0 + 0x27] & 0x04) == 0)
	{
		u16 widthDelta = (getScreenWidth() - 448)
		bool fulfilled = false
		if (u8[A0 + 0x27] & 0x40)
		{
			fulfilled = (camera.position.x.u16 > level.bossarea.right)
			move_area.right = camera.position.x.u16
		}
		else
		{
			fulfilled = (camera.position.x.u16 >= level.bossarea.left)
			if (global.zone_act == 0x0301 && getScreenWidth() > 448)
			{
				fulfilled = (camera.position.x.u16 >= (level.bossarea.left - widthDelta))
			}
			move_area.left = camera.position.x.u16
		}

		if (fulfilled)
		{
			u8[A0 + 0x27] |= 0x04
			move_area.left = level.bossarea.left
			if (global.zone_act == 0x0301 && getScreenWidth() > 448)
			{
				move_area.left = level.bossarea.left - widthDelta
			}
			move_area.right = level.bossarea.right
		}
	}

	// All conditions must be fulfilled to pass, and actually start the boss fight
	if ((u8[A0 + 0x27] & 0x07) != 0x07)
		return

	u8[A0 + 0x27] = 0
	u16[A0 + 0x1c] = 0
	objA0.value26 = 0

	A1 = objA0.countdown_callback
	call A1
}






// Sonic AIZ intro: direct time attack check from base game to use DAGE time attack flag
// fn01c4d0() is handled in main.lemon since it also has checks for Knuckles' new AIZ1 area.
// Function taken from level\01_aiz\level_aiz.lemon





// Sonic AIZ intro: direct time attack check from base game to use DAGE time attack flag
// Function taken from maingame\maingame.lemon
function bool isSonicIntro()
{
	if (global.zone_act == 0x0000 && checkpoint.number == 0 && isMainCharacter(CHARACTER_SONIC))
	{
	#if STANDALONE
		return !time_attack
	#else
		return true
	#endif
	}
	return false
}






// Knuckles AIZ intro: direct time attack check from base game to use DAGE time attack flag
// SetupCharacterAtStartPosition() and fn0067ee() are handled in main.lemon since they also sets Knux's AIZ1 starting location
// Functions taken from maingame\maingame.lemon









// Knuckles AIZ intro: direct time attack check from base game to use DAGE time attack flag
// Function taken from level\07_mhz\intro_knuckles.lemon
//# address-hook(0x063446) end(0x063460)
function void fn063446()
{
	bool showKnucklesIntro = (isMainCharacter(CHARACTER_KNUCKLES) && checkpoint.number == 0)
#if STANDALONE
	// Show in AIZ instead of MHZ
	showKnucklesIntro &= (global.zone_act == 0x0000 && Game.getSetting(SETTING_AIZ_INTRO_KNUCKLES) != 0 && !time_attack && !original_mode)
#else
	// Show only in S&K alone
	showKnucklesIntro &= (global.lock_on_state != 0)
#endif

	if (showKnucklesIntro)
	{
		objA0.update_address = 0x063466
		fn063466()
	}
	else
	{
		UnloadObject()
	}
}





// AIZ1 all intros: Ensure Tails spawns in Marathon modes.
// This is handled in main.lemon in Character.TailsAI.Init().






// AIZ1 cutscene boss: direct time attack check from base game to use DAGE time attack flag
//# address-hook(0x0684ec) end(0x0684fa)
function void AIZ1.Transition.Update()
{
	// Called addresses:
	//  - 0x068508	-> objA0.base_state = 0x00	-> Initialization
	//  - 0x06852c	-> objA0.base_state = 0x02	-> Waiting until character reaches the right position
	//  - 0x068574	-> objA0.base_state = 0x04	-> Short wait time
	//  - 0x0685b8	-> objA0.base_state = 0x06	-> Flying in
	//  - 0x0685fc	-> objA0.base_state = 0x08	-> Firing its rockets
	call tableLookupAddress(0x0684fe, objA0.base_state)

#if STANDALONE
	// Not in Time Attack please, as this can do funny things like spawn a sign post
	if (!time_attack)
#endif
	{
		Boss.AIZ1.RegularUpdate()
	}
}

//# address-hook(0x06852c) end(0x068550)
function void fn06852c()
{
#if STANDALONE
	// Extend level chunks a bit
	u8[0xffff82ce] = u8[0xffff82cd]
	u8[0xffff832f] = u8[0xffff832e]
	u8[0xffff8390] = u8[0xffff838f]
#endif

	D5.u16 = 0x2f10
	if (camera.position.x.u16 < D5.u16)
	{
	#if STANDALONE
		// Set right border here already to prevent camera going too far for one frame
		move_area.right = D5.u16 + (getScreenWidth() - 320)
	#endif
		return
	}

#if STANDALONE
	// In Time Attack, skip most of the transition
	if (time_attack)
	{
		// Trigger fire wall immediately
		u16[0xffffeec6] = 0xff

		addPatternLoadingCue(0x083d48)

		UnloadObject()
		return
	}
#endif

	// Trigger AIZ 1 transition cutscene
	objA0.countdown_callback = 0x06857a

	A2 = 0x06906a
	SpawnIdenticalChildObjects()

	loadPaletteLine1(0x06917c)

	fn068556()
}





// AIZ1 boss (actual, not cutscene): direct time attack check from base game to use DAGE time attack flag
// Function taken from level\01_aiz\level_aiz.lemon
#if STANDALONE
function void AIZ1a.checkPreBossArea()
{
	// Skip check for boss
//	if (time_attack)
//		return

	// Using the upper or the lower path?
	bool isOnUpperPath = (camera.position.y.u16 < 0x400)

	if (isOnUpperPath)
	{
		D0.u16 = (camera.position.x.u16 >= 0x0f00) ? 0x02b8 : 0x0590	// camera x usually checked against 0x0ed0
	}
	else
	{
		D0.u16 = (camera.position.x.u16 >= 0x0f00) ? 0x0450 : 0x0590	// camera x usually checked against 0x0e80
	}
	move_area.bottom.current = D0.u16
	move_area.bottom.target = D0.u16

	if (isOnUpperPath)
	{
		if (camera.position.x.u16 >= 0x0f50)
		{
			move_area.left = 0x0f50
			// Choose boss area depending on which route has been taken, not the character selection
			//  -> Search for this same comment to find another place with similar code
			move_area.right = ((camera.position.y.u16 >= 0x03a0) ? 0x10c0 : 0x10e0) + getScreenExtend()

			if (debug_mode.state == 0 && time_attack != 1 && time_attack != 2)	// make time attack check later than base game to set camera y value nicely
			{
				if (allocDynamicObjectStd())
				{
					// Trigger boss
					objA1.update_address = 0x068a24
					objA1.position.x.u16 = 0x11f0
					objA1.position.y.u16 = 0x0289
				}
			}
			camera.update_routine = 0x06
		}
	}
	else
	{
		if (camera.position.x.u16 >= 0x1040)
		{
			move_area.left = 0x1040
			if (debug_mode.state == 0)
			{
				if (allocDynamicObjectStd() && time_attack != 1 && time_attack != 2)	// make time attack check later than base game to set camera y value nicely
				{
					// Trigger boss
					objA1.update_address = 0x068a24
					objA1.position.x.u16 = 0x11d0
					objA1.position.y.u16 = 0x0420
				}
			}
			water.height.target = 0x0f80
			camera.update_routine = 0x16
		}
	}
}
#endif







// AIZ2: disable blimp sequence scrolling in time attack modes.
// Function taken from level\01_aiz\aiz2_blimp_sequence.lemon and is called by UpdateSpecialScrolling() in maingame\maingame.lemon.
//# address-hook(0x0502c6) end(0x050348)
function void fn0502c6()
{
	if (time_attack == 1 || time_attack == 2)
		return

	// This does the auto-scrolling!

	u16[0xffffeebc] = 0
	D0.u16 = camera.position.x.u16 + 4
	if (D0.u16 >= u16[0xffffeed4] - getScreenExtend() * 2)
	{
		D1.u16 = 0x0200
		u16[0xffffeebc] = D1.u16
		u16[0xffffb010] -= D1.u16
		u16[0xffffb05a] -= D1.u16

	#if STANDALONE
		// Also update position backup data (e.g. for after-images)
		for (u32 address = 0xffffe500; address < 0xffffe600; address += 4)
			u16[address] -= D1.u16
	#endif

		D0.u16 = camera.position.x.u16 - D1.u16
		D1.u16 = (D0.u16 & 0xfff0) - 0x10
		camera.foreground.x.old = D1.u16
		u16[0xffffa9fe] = D1.u16
	}

	camera.position.x.u16 = D0.u16
	camera.foreground.x.u16 = D0.u16
	move_area.left = D0.u16
	move_area.right = D0.u16

	D1.u16 = D0.u16
	A1 = 0xffffb000
	fn050318()

	D0.u16 = D1.u16
	A1 = 0xffffb04a
	fn050318()
}


// AIZ2: disable blimp in time attack modes.
// Function taken from level_01_aiz\level_aiz.lemon
//# address-hook(0x04ff3a) end(0x04ff70)
function void fn04ff3a()
{
	if (u16[0xffffeec4] == 0 || time_attack == 1 || time_attack == 2)
	{
		LoadTileContentDefault()
		return
	}

	// This code is only reached in the blimp sequence before AIZ 2 boss

	u16[0xffffeec4] = 0
	u16[0xffffeec8] = 0x0180
	u16[0xffffeeca] = 0x05
	u32[0xffffa9f8] = 0
	u16[0xffffa9fe] = (camera.foreground.x.u16 & 0xfff0) - 0x10
	player1.camera_lock = 0xff
	level.special_scrolling = 0x04
	u16[0xffffeec0] += 4

	fn04ff74()
}



// HCZ1 boss: direct time attack check from base game to use DAGE time attack flag
// Function taken from bosses\boss_hcz1.lemon
//# address-hook(0x069ea0) end(0x069ecc)
function void fn069ea0()
{
	#if STANDALONE
		if (time_attack == 1 || time_attack == 2)
		{
			UnloadObject()
			level.vertical_wrap = 0x0300
			return
		}
	#endif

	A1 = 0x069ed2
	if (InitBoss(0x069eaa))
		return

	objA0.update_address = 0x069eda
	level.boss_encounter = 1
	u8[0xffffeee8] = 0xff

	requestLoadingPatterns(0x5b)
	level.vertical_wrap = 0x0300

	spawnChildObjects(0x06ad6e)

	#if STANDALONE
		// There is this one chunk visible with broken palette
		u8[0xffff8634] = 0xb5
	#endif
}





// HCZ1 boss: add time attack check to water level and set proper screen boundaries
// UpdateWaterSurfaceLevel.HCZ1() is handled in main.lemon since it also shifts the water level for the boss itself.
// Function taken from level\level_water.lemon





// HCZ2 boss: add time attack check to water level.
// UpdateWaterSurfaceLevel.HCZ2() is handled in main.lemon since it also determines if Knuckles has gone to the Sonic/Tails boss area.
// Function taken from level\level_water.lemon





// HCZ2 boss: direct time attack check from base game to use DAGE time attack flag
// fn6aeb6() is handled in main.lemon since it also determines when the boss can spawn based on character/path.
// Function taken from level\02_aiz\level_hcz.lemon




// MGZ1: unload boss cutscenes in time attack modes and instead set the appropriate trigger
//# address-hook(0x08845a) end(0x08845a)
function void Driller.Init()
{
	if (time_attack)
	{
		level.trigger08 = 0xff
		UnloadObject()
		return
	}
	Object.InitWithUpdateAddress(0x088460)

#if STANDALONE
	// Need to increase the bounding box just a little bit
	objA0.box_size.x = 0x30
#endif
}




// MGZ1 boss: unload boss in time attack modes and set camera
// Function taken from bosses\boss_hcz1.lemon
//# address-hook(0x088568) end(0x08856c)
function void fn088568()
{
	#if STANDALONE
		if (time_attack == 1 || time_attack == 2)
		{
			UnloadObject()
			move_area.left = 0x2d00
			move_area.bottom.target = 0x0e10
			level.vertical_wrap = move_area.bottom.target
			return
		}
	#endif
	A1 = 0x08859c
	if (InitBoss(0x088572))
		return

	fn088572()
}






// MGZ2: unload Eggman cutscenes in time attack modes
// Functions taken from level\03_mgz\mgz_robotnikencounters.lemon
// fn051560() normally loads the first encounter that is unused in DAGE.
//# address-hook(0x051560) end(0x0515a2)
function void fn051560()
{
/*
	if (D0.u16 < 0x0780)
	{
		fn051656()
		return
	}

	D0.u16 = move_area.right + (320 - getScreenWidth())
	if (camera.position.x.u16 >= D0.u16)
	{
		move_area.left = D0.u16
		u8[0xffffeee4] = 0xff
		u16[0xffffeee2] += 0x0c

		if (allocDynamicObjectStd())
		{
			// Mid-level Robotnik encounter
			objA1.update_address = 0x06bf2a
			objA1.position.x.u16 = 0x08e0
			objA1.position.y.u16 = 0x0690
			camera.screenshake.state.hi = 0xff
			u8[0xffffeeb4] = 0xff
		}
	}
*/
}


//# address-hook(0x0515a4) end(0x05160c)
function void fn0515a4()	// Eggman encounter leading to upper boss
{
	if (D0.u16 >= 0x3200)
	{
		level.vertical_wrap = 0x01df
		fn051656()
		return
	}

	D1.u16 = move_area.bottom.current
	if (D1.u16 == camera.position.y.u16 && D1.u16 != level.vertical_wrap)
	{
		level.vertical_wrap = D1.u16
		u8[0xffffeeb9] = 0xff
	}

	D0.u16 = move_area.left
	if (D0.u16 >= camera.position.x.u16)
	{
		move_area.right = D0.u16
		u8[0xffffeee5] = 0xff
		u16[0xffffeee2] += 0x0c

		camera.screenshake.state.hi = 0xff
		u8[0xffffeeb4] = 0xff

		if (allocDynamicObjectStd() && !time_attack)
		{
			objA1.update_address = 0x06bf2a
			u8[A1 + 0x04] |= render_flag.FLIP_X
			objA1.position.x.u16 = 0x2fa0
			objA1.position.y.u16 = 0x02d0
		}
		else
		{
			level.vertical_wrap = 0x0000
			move_area.bottom.current = 0x1e0
			move_area.bottom.target = 0x1e0
			move_area.left = 0
			move_area.right = 0x2fc0
		}
	}
}

//# address-hook(0x05160e) end(0x051654)
function void fn05160e()	// Eggman encounter leading to lower boss
{
	if (D0.u16 < 0x3480)
	{
		D0.u16 = move_area.left
		if (D0.u16 >= camera.position.x.u16)
		{
			move_area.right = D0.u16 + getScreenExtend() * 2
			u8[0xffffeee6] = 0xff
			u16[0xffffeee2] += 0x0c


			camera.screenshake.state.hi = 0xff
			u8[0xffffeeb4] = 0xff

			if (allocDynamicObjectStd() && !time_attack)
			{
				objA1.update_address = 0x06bf2a
				u8[A1 + 0x04] |= render_flag.FLIP_X
				objA1.position.x.u16 = 0x3300
				objA1.position.y.u16 = 0x0790
			}
			else
			{
				level.vertical_wrap = 0x0000
				move_area.bottom.current = 0x6a0
				move_area.bottom.target = 0x6a0
				move_area.left = 0
				move_area.right = 0x3310
			}
		}
	}
	else
	{
		fn051656()
	}
}



// CNZ1: when approaching boss, update camera and visuals for time attack mode.
// Functions taken from level\level_cnz.lemon
//# address-hook(0x051caa) end(0x051d16)
function void fn051caa()
{
#if STANDALONE
	if (camera.position.x.u16 >= 0x3000 - getScreenExtend() && (camera.position.y.u16 < 0x280 || camera.position.y.u16 >= 0x880))
	{
		// Lock screen here so nobody can get to see the ugly parts to the left
		move_area.left = 0x2f80

#else
	if (camera.position.x.u16 >= 0x3000 - getScreenExtend())
	{
#endif
		if (camera.position.y.u16 >= 0x054c)
		{
			// When taking Knuckles' path, move everything up to Sonic's path
			D0.u16 = 0x0700
			u16[0xffffb014] -= D0.u16
			u16[0xffffb05e] -= D0.u16
			camera.position.y.u16 -= D0.u16
			camera.foreground.y.u16 -= D0.u16
			Level.GetCameraPosition()
		}

		fn051fa4()
		fn04f2f6()

		loadPaletteLine1(0x06e370)
		if (time_attack == 1 || time_attack == 2)
		{
			move_area.bottom.target = 0x180
			level.vertical_wrap = move_area.bottom.target
			u32[0xffff82ac] = 0x6a6a6af5
			u32[0xffff831c] = 0x6d6e6ff5
		}
		else
		{
			D0.u16 = 0x01c0
			level.vertical_wrap = D0.u16
			knuckles.preventclimbing |= 0x80
		}
		level.scrolling_routine += 4
		fn051d26()
	}
	else
	{
		UpdateBackground.CNZ1()

		A6 = 0xffffee90		// Address of camera.background.y
		A5 = 0xffffee96		// Address of camera.background.y.old
		D1 = 0
		D6 = 0x20
		LoadTileContentInDirY()

		A4 = 0x0520fe
		A5 = 0xffffa800
		fn04f0ce()
	}
}

//# address-hook(0x051d1a) end(0x051d22)
function void fn051d1a()
{
	D0.u16 = 0x01c0
	if (time_attack != 1 && time_attack != 2)
		fn0520e8()
	fn051fa4()
	fn051d26()
}

//# address-hook(0x051d2e) end(0x051d4c)
function void fn051d2e()
{
	if (time_attack == 1 || time_attack == 2)	// stops the camera from trying to shift down to the boss arena
		return
	D0.u16 = 0x01c0
	fn0520e8()
	fn051fb0()

	A6 = 0xffffee8c		// Address of camera.background.x
	A5 = 0xffffee94		// Address of camera.background.x.old
	D1.u16 = 0x0200
	D6 = 0x10
	LoadTileContentInDirX()
	WriteScrollOffsets()
}




// CNZ1 boss: do not load in time attack mode
// Function taken from bosses\boss_cnz1.lemon
//# address-hook(0x06d99c) end(0x06d9fa)
function void fn06d99c()
{
	if (time_attack == 1 || time_attack == 2)
		return

	D0.u16 = 0x31e0
	if (D0.u16 > camera.position.x.u16)
		return

	screenmover_target.right = move_area.right
	level.vertical_wrap = 0x01c0
	move_area.left = D0.u16
	D0.u16 += 0x80
	move_area.right = D0.u16
	move_area.bottom.current = 0x02b8
	move_area.bottom.target = 0x02b8
	objA0.update_address = 0x08488a		// Address of "Object.CountdownAndTrigger"
	objA0.countdown_value = 120
	objA0.countdown_callback = 0x06da00

	playMusic(MUSIC_CTRL_FADEOUT)
	level.boss_encounter = 1

	requestLoadingPatterns(0x5d)
	loadPaletteLine1(0x06e370)
}





// CNZ2: direct time attack checks from base game to use DAGE time attack flag
// Functions taken from level\04_cnz\cnz2_knuckles_lights_out.lemon
// Note that the function for the pre-boss cutscene that goes unused in DAGE (cnz2_knuckles_preboss.lemon) is left unaltered.
// The function that loads the special egg prison in CNZ2 for the Knux path in the base game (level_cnz.lemon) is also left unaltered.
//# address-hook(0x06229e) end(0x0622ac)
function void fn06229e()
{
	if (isMainCharacter(CHARACTER_KNUCKLES) && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
	{
		UnloadObject()
		return
	}

	#if STANDALONE
		if (time_attack)
		{
			UnloadObject()
//			fn065c78()		// In maingame\cutscene_knuckles.lemon, turns off the lights and sets water.height.target = 0x0350 and
							// water.height.next = camera.position.y.u16 + 0x0100. Note that this can trigger within the giant ring chamber beforehand,
							// making the water too high for a bit and making for an awkward trigger position.
			return
		}
	#endif

	A1 = 0x06228e
	if (InitBoss(0x0622b2))
		return

	fn0622b2()
}

// The water height change is in fn065c78() of maingame\cutscene_knuckles.lemon.



// fn065d8c() in main.lemon handles the switch that reactivates the lights in CNZ2.
// The function's time attack check is deliberately ignored to allow standard water behavior.





/* This function from level\level_cnz.lemon is only here for reference.
// It has a time attack check for the capsule at the original game's Knuckles exit, which doesn't exist in DAGE.
// //# address-hook(0x05215a) end(0x052200)
function void fn05215a()
{
	if (global.characters == CHARS_KNUCKLES_ALONE)
	{
	#if STANDALONE
		if (!time_attack)
	#endif
		{
			A1 = 0xffffb000
		#if STANDALONE
			if (objA1.position.x.u16 >= 0x4820 && objA1.position.y.u16 >= 0x0a00)
		#else
			if (objA1.position.x.u16 >= 0x4880 && objA1.position.y.u16 >= 0x0b00)
		#endif
			{
				if (allocDynamicObjectStd())
				{
					objA1.update_address = 0x0522a0

					// Spawn capsule
					if (allocDynamicObjectAfterA1())
					{
						objA1.update_address = 0x086540
						objA1.position.x.u16 = 0x4980 - getScreenExtend()
						objA1.position.y.u16 = 0x0a20

						u32 backupD7 = D7
						u32 backupA0 = A0
						u32 backupA2 = A2
						u32 backupA3 = A3

						addPatternLoadingCue(0x083d74)

						D7 = backupD7
						A0 = backupA0
						A2 = backupA2
						A3 = backupA3
					}
				}

				move_area.left = 0x4750
				move_area.right = 0x48e0
				level.results_done = 0
				u16[0xffffeec0] += 4

				fn0521d2()
				return
			}
		}
	}
	else
	{
		u16[0xffffeec0] = 8
	}

	LoadTileContentDefault()
}
*/



// CNZ2: in time attack mode, make sure the lights and water adjust for Sonic and Tails even without the cutscene.
// Function taken from level\level_cnz.lemon
//# address-hook(0x052110) end(0x05214a)
function void UpdateLevelTiles.CNZ2()
{
	if (time_attack && (!isMainCharacter(CHARACTER_KNUCKLES) || Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles")) && u16[0xffffb010] >= 0x1ce8 && u16[0xffffb010] <= 0x1d60 && u16[0xffffb014] < 0x0380 && u8[0xfffffaa3] == 0)
		fn065c78()			// In maingame\cutscene_knuckles.lemon, turns off the lights and sets water.height.target = 0x0350 and
							// water.height.next = camera.position.y.u16 + 0x0100.

	D0.u16 = camera.screenshake.offset
	camera.foreground.y.u16 += D0.u16
	if (u16[0xffffb010] < 0x4600)
	{
		D0 = 0
		if (u16[0xffffb010] < 0x0940)
		{
			D0.u16 = 0x0580
		}
		if (D0.u16 != level.vertical_wrap)
		{
			level.vertical_wrap = D0.u16
		}
	}

	if (u16[0xffffeed8] != 0)
	{
		u16[0xffffeed8] = 0
		fn04ed62()
		return
	}

	call 0x05214e + s16[0xffffeec0]
}



// CNZ2: in time attack mode, show the lights off button pressed down if the level is darkened
// Function taken from maingame\cutscene_knuckles.lemon
//# address-hook(0x065c04) end(0x065c3a)
function void fn065c04()
{
	if (time_attack && u8[0xfffffaa3] && global.zone_act > 0x0100)	// this code also handles the AIZ 2 end button even as Marathon ups the zone_act to 0x0100
	{
		objA0.update_address = 0x065c50
		objA0.animation.sprite = 1
		u8[0xfffffaa9] = 0xff
		objA0.respawn_entry = 0

		fn065c50()
	}
	else
		base.fn065c04()
}



// ICZ2: direct base game time attack check from HCZ2 cutscene to use new time attack flag
// Function taken from level\02_hcz\hcz2_knuckles_cutscene.lemon
//# address-hook(0x062112) end(0x06211e)
function void fn062112()
{
	if (isMainCharacter(CHARACTER_KNUCKLES))
	{
		UnloadObject()
		return
	}

	#if STANDALONE
		// In time attack, skip this cutscene and trigger the bridge now
		if (time_attack)
		{
			level.trigger08 = 0xff
			UnloadObject()
			return
		}

		if (!original_mode)
		{
			// Slightly change the cutscene area via ROM manipulation
			u16[0x062154] = 0x38b0
			u16[0x062156] = 0x38f0

			// There is this one chunk visible with broken palette, replace it
			u8[0xffff8849] = 0xb2
		}
	#endif

	A1 = 0x062150
	if (InitBoss(0x062124))
		return

	fn062124()
}










// LBZ1: Remove Eggman and cutscene Knuckles from before the boss area in time attack modes
// Functions taken from level\lbz1_pre_boss_cutscene.lemon
//# address-hook(0x08cb56) end(0x08cb62)
function void fn08cb56()	// Eggman in the building before it collapses
{
	if (isMainCharacter(CHARACTER_KNUCKLES) || time_attack)
	{
		UnloadObject()
		return
	}

	A1 = 0x08cb96
	if (InitBoss(0x08cb66))
		return

//	if (time_attack >= 3)			// Marathon modes?
//		objA0.base_state = 0x0a		// Skip collapsing building and camera-locking code

	fn08cb66()
}

//# address-hook(0x08cb9e) end(0x08cbec)
function void fn08cb9e()	// Eggman in the boss room
{
	if (time_attack)
	{
		UnloadObject()
		return
	}
	setupObjectAttributesFull(0x08d230)

	u8[A0 + 0x29] = 0xff
	u8[0xfffffaab] = 0xff
	fn0685e2()
	move_area.left = 0x3820
	move_area.right = 0x3ae8 + getScreenExtend()

	requestLoadingPatterns(0x60)

	Kosinski.addToDMAQueue(0x37567a, 0x8ac0)

	spawnChildObjects(0x06817c)

	A2 = 0x08d254
	SpawnIdenticalChildObjects()
}

//# address-hook(0x062640) end(0x062662)
function void fn062640()	// Cutscene Knuckles throwing a bomb
{
	if (isMainCharacter(CHARACTER_KNUCKLES) || time_attack)
	{
		UnloadObject()
		return
	}

	// Targets:
	//  - 0x062678	-> objA0.base_state = 0x00  -> Initialization
	//  - 0x0626b2	-> objA0.base_state = 0x02  -> Waiting for character in the cup elevator
	//  - 0x062014	-> objA0.base_state = 0x04  -> Short wait time, just standing there
	//  - 0x0626ee	-> objA0.base_state = 0x06  -> Throwing
	//  - 0x062014	-> objA0.base_state = 0x08  -> Ending throw animation
	//  - 0x062354	-> objA0.base_state = 0x0a  -> Waiting and then laughing while bomb is in the air
	//  - 0x062354	-> objA0.base_state = 0x0c  -> Bomb explosions, still laughing
	//  - 0x062778	-> objA0.base_state = 0x0e  -> Running away
	call tableLookupAddress(0x062668, objA0.base_state)

	Object.loadSpritePatternsForVDP(0x06666a)
	fn085208()
}








// LBZ1 boss: remove the tube from the Knuckles boss area and set camera boundaries, and also replace the Sonic/Tails boss "container" with a matching chunk.
// UpdateLevelTiles.LBZ1() is handled in main.lemon since it also has a fix for a Sonic/Tails camera issue at the final star post.
// Function taken from level\06_lbz\level_lbz.lemon







// LBZ1 boss: do not load in time attack modes
// Function taken from bosses\boss_lbz1.lemon
//# address-hook(0x08cf80) end(0x08cfac)
function void fn08cf80()	// Knuckles boss
{
	if (time_attack == 1 || time_attack == 2)
		return

	A1 = 0x08cf70
	if (InitBoss(0x08cf8a))
		return

	level.vertical_wrap = u16[(A1+=2)-2]
	move_area.bottom.current = u16[A1]
	move_area.bottom.target = u16[(A1+=2)-2]
	move_area.left = u16[(A1+=2)-2]
	move_area.right = u16[(A1+=2)-2]
	fn08d0ea()

	spawnChildObjects(0x08d26c)

	objA0.update_address = 0x08cfb2
	fn08cfb2()
}

// Function taken from level\06_lbz\lbz1_pre_boss_cutscene.lemon
//# address-hook(0x08cdb8) end(0x08cdf0)
function void fn08cdb8()	// Sonic/Tails boss
{
	if (isMainCharacter(CHARACTER_KNUCKLES) || u8[0xfffffaab] != 0 || time_attack == 1 || time_attack == 2)
	{
		objA0.update_address = 0x01b5d4		// That is "CheckForUnloadObject()"
		return
	}

	objA0.update_address = 0x08cdf2
	move_area.right = 0x3ea0
	move_area.left = 0x3c00

	A2 = 0x08d25c
	SpawnIdenticalChildObjects()

	fn08d116()
	fn08d0ea()
}










// LBZ2: create appropriate goal area in time attack modes and prevent chunks at level bottom from interfering with going above the level's top (in all modes)
// Function taken from level\06_lbz\level_lbz.lemon
//# address-hook(0x05436c) end(0x054378)
function void UpdateLevelTiles.LBZ2()
{
	if (time_attack == 1 || time_attack == 2)
	{
		u32[0xffff8832] = 0x1c686868
		u8[0xffff8836] = 0xcb
		u32[0xffff88cc] = 0xdf000000
		u8[0xffff88d0] = 0xcf
		u32[0xffff8966] = 0xdf000000
		u8[0xffff896a] = 0xcf
	}

	camera.foreground.y.u16 += camera.screenshake.offset
	call 0x05437c + s16[0xffffeec0]
}






// LBZ2 first boss: do not load in time attack modes
// Function taken from bosses\boss_lbz2_1.lemon
//# address-hook(0x0738d6) end(0x0738da)
function void fn0738d6()
{
	if (time_attack == 1 || time_attack == 2)
	{
		UnloadObject()
		return
	}
	A1 = 0x0738c6
	if (InitBoss(0x0738e0))
		return

	fn0738e0()
}






// LBZ2 Eggmobile flight: do not play the Knuckles scene in time attack modes (namely Marathons)
// Functions taken from level\06_lbz\lbz2_mid_boss_cutscene.lemon
//# address-hook(0x0628aa) end(0x0628cc)
function void fn0628aa()
{
	if (isMainCharacter(CHARACTER_KNUCKLES) || time_attack)
	{
		UnloadObject()
		return
	}

	// Targets:
	//  - 0x00628e0	-> objA0.base_state = 0x00  -> Initialization
	//  - 0x006290e	-> objA0.base_state = 0x02  -> Waiting
	//  - 0x0062928	-> objA0.base_state = 0x04  -> Boxing
	//  - 0x0062942	-> objA0.base_state = 0x06  -> Knuckles chuckles
	//  - 0x0062964	-> objA0.base_state = 0x08  -> Losing his balance when Death Egg starts
	//  - 0x00629a8	-> objA0.base_state = 0x0a  -> Falling into the water
	//  - 0x00629c0	-> objA0.base_state = 0x0c  -> ...aaand he's gone
	call tableLookupAddress(0x0628d2, objA0.base_state)

	Object.loadSpritePatterns(0x06666a)
	fn085208()
}

//# address-hook(0x08d344) end(0x08d364)
function void fn08d344()
{
	objA0.update_address = 0x08d36a
	u16[A0 + 0x3a] = objA0.position.y.u16
	objA0.velocity.x = 0x0100
	objA0.countdown_value = 0x01df
	objA0.countdown_callback = 0x08d38a
#if STANDALONE
	// For Knuckles, skip the Knuckles cutscene and just launch the Death Egg
	if ((isMainCharacter(CHARACTER_KNUCKLES) || time_attack) && !original_mode)
	{
		objA0.countdown_value = 0x015f
		objA0.countdown_callback = 0x08d450
	}
#endif

	fn0685e2()
}





// MHZ1: direct time attack check from base game to use DAGE time attack flag and have cutscene button deleted
// Function taken from level\07_mhz\mhz1_knuckles_cutscene.lemon
//# address-hook(0x062ca4) end(0x062ccc)
function void fn062ca4()
{
	bool useCutscene = (!isMainCharacter(CHARACTER_KNUCKLES) && checkpoint.number == 0 && global.lock_on_state == 0)

#if STANDALONE
	if (time_attack)
	{
		useCutscene = false
	}
#endif

	if (useCutscene)
	{
		A1 = 0xffffb000

		// Targets:
		//  - 0x062cde	-> u8[0xfffffab8] = 0x00
		//  - 0x062cf8	-> u8[0xfffffab8] = 0x02
		//  - 0x062d2c	-> u8[0xfffffab8] = 0x04
		//  - 0x062d42	-> u8[0xfffffab8] = 0x06
		//  - 0x062d5a	-> u8[0xfffffab8] = 0x08
		//  - 0x062d6e	-> u8[0xfffffab8] = 0x0a
		//  - 0x062d70	-> u8[0xfffffab8] = 0x0c
		call tableLookupAddress(0x062cd0, u8[0xfffffab8])
	}
	else
	{
		UnloadObject()
	}
}

//# address-hook(0x062e28) end(0x062e56)
function void fn062e28()
{
	setupObjectAttributesFull(0x06644a)

	// "spawnSimpleChildObjects(0x0665b6)" replaced by:
	spawnSimpleChildObjects(0x06300c, 1)

	if (time_attack)
	{
		UnloadObject()
		return
	}

	if (checkpoint.number == 0 && !isMainCharacter(CHARACTER_KNUCKLES))
		objA0.update_address = 0x062e5c
	else
		objA0.update_address = 0x062f0a

	DrawObject()
}





// MHZ2: don't adjust the camera maximum near the boss (as this inhibits Knuckles' gliding) in time attack modes
// Function taken from level\07_mhz\level_mhz.lemon
//# address-hook(0x054dbe) end(0x054e82)
function void fn054dbe()
{
	if (u16[0xffffeec4] != 0)
	{
		u16[0xffffeec4] = 0
		u16[0xffffeec8] = 0x0320
		u16[0xffffeeca] = 0x0a
		u16[0xffffeec0] += 8
		fn054e9c()
		return
	}

	u16 bossStartCamX = 0x3c90 - getScreenExtend() * 2
	if (camera.position.x.u16 >= bossStartCamX && time_attack != 1 && time_attack != 2)
	{
	#if STANDALONE
		{
			// This solves a possible glitch, but can lead to a sudden camera jump when trying to fly over everything with Tails
			move_area.left = max(bossStartCamX, move_area.left)
			level.vertical_wrap = 0x0280
			if (camera.position.x.u16 >= bossStartCamX + 0x200)
			{
				camera.position.y.u16 = 0x0280
			}

			// Refresh parts of the screen to avoid visual glitches
			fillPlaneA_Default(camera.position.x.u16, camera.position.y.u16, getScreenWidth(), getScreenHeight())
		}
	#else
		if (camera.position.x.u16 == bossStartCamX)
		{
			move_area.left = bossStartCamX
			if (camera.position.y.u16 >= 0x0280)
			{
				level.vertical_wrap = 0x0280
			}
		}
	#endif
	}
	else
	{
		if (camera.position.x.u16 < 0x0380)
		{
			level.vertical_wrap = 0x0620
		}
		else
		{
			level.vertical_wrap = (camera.position.x.u16 >= 0x3600) ? 0x01a8 : 0
		}

		if (camera.position.x.u16 < 0x3600 && u16[0xffffeee8] == 0)
		{
			move_area.left = (u16[0xffffb014] >= 0x05c0) ? max(s16(0x98 - getScreenExtend() * 2), 0) : 0x0380
		}

		if (u16[0xffffb010] < 0x3a97)
		{
			D0.u16 = 0x09a0
		}
		else if (u16[0xffffb010] < 0x3ac0 && u16[0xffffb014] >= 0x0300)
		{
			D0.u16 = 0x09a0
		}
		else
		{
			D0.u16 = 0x0280
		}
		if (D0.u16 != move_area.bottom.current)
		{
			move_area.bottom.current = D0.u16
			move_area.bottom.target = D0.u16
		}
	}

	fn055008()
	LoadTileContentDefault()
}






// MHZ2 boss: direct time attack check from base game to use DAGE time attack flag and add chunk/object corrections
// Function taken from bosses\boss_mhz2.lemon
//# address-hook(0x075f50) end(0x075fce)
function void fn075f50()
{
#if STANDALONE
	if (time_attack == 1 || time_attack == 2)
	{
		UnloadObject()
		u8[0xffff825f] = 0x49
		u8[0xffff82ef] = 0x49
		u16[0xffff837e] = 0x0049
		u8[0xffff840d] = 0x45
		u16[0xffff840e] = 0x234a
		if (allocDynamicObjectStd())
		{
			objA1.update_address = 0x03e018	// make a mushroom
			objA1.position.x.u16 = 0x3cb0
			objA1.position.y.u16 = 0x0320
			objA1.subtype2c = 0xc1
		}
		return
	}

	// Wait until a certain camera position was reached, where you can't go back
	// to the checkpoint any more and potentially enter the Gumball Machine stage
	//  -> The stage needs the spring graphics that will get overwritten in this function
	if (camera.position.x.u16 < 0x3b20)
		return
#endif

	A1 = 0x0769f4
	if (InitBoss(0x075f5a))
		return

	objA0.update_address = 0x075fd4
	move_area.left = camera.position.x.u16
	level.boss_encounter = 1
	InitBossArea()

	objA0.position.x.u16 += 0xc0

	setupObjectAttributesFull(0x076928)

	objA0.base_state = 0
	u8[0xfffffaa9] = 0

	Kosinski.addToDMAQueue(0x16a104, 0x7d80)

	requestLoadingPatterns(0x7b)
	loadPaletteLine1(0x0769d4)

	spawnChildObjects(0x07699c)
	spawnChildObjects(0x076982)
	spawnSimpleChildObjects(0x07697c)
	spawnSimpleChildObjects(0x076976)
}












// FBZ1 boss: do not load in time attack mode
// Funciton taken from bosses\boss_fbz1.lemon
//# address-hook(0x06ee68) end(0x06ee6c)
function void fn06ee68()
{
	if (time_attack == 1 || time_attack == 2)
	{
		move_area.left = 0x2d00
		level.vertical_wrap = 0x0540
		move_area.bottom.target = 0x0540
		return
	}

	A1 = 0x06ee98
	if (InitBoss(0x06ee72))
		return

	fn06ee72()
}





// FBZ2 laser boss: do not load in time attack mode
// Function taken from bosses\boss_fbz2_mid.lemon
//# address-hook(0x06fd0c) end(0x06fd10)
function void fn06fd0c()
{
	if (time_attack == 1 || time_attack == 2)
	{
		UnloadObject()

		move_area.left = 0x2900
		move_area.bottom.target = 0x05e0

		u32[0xffff82e4] = 0xa1a1a16b	// these lines correct the goal pole area's chunks
		u32[0xffff8362] = 0x7f7f7f3a
		u32[0xffff83e0] = 0x33333333

		Kosinski.addToDMAQueue(0x165826, 0x7460)	// Load graphics for collapse sequence.
		Kosinski.addToDMAQueue(0x165ab8, 0x7aa0)	// These lines taken from level\08_fbz\level_fbz.lemon, used if spawning at the final star post

		return
	}

	A1 = 0x06fcfc
	if (InitBoss(0x06fd16))
		return

	fn06fd16()
}



// FBZ2 collapse sequence: do not move the floor in time attack modes, and adjust the position at which the sequence speeds up in all modes
// Function taken from level\08_fbz\fbz_dualplane.lemon
//# address-hook(0x0532f0) end(0x05331c)
function void fn0532f0()
{
	level.dualplanecollision = 0xff

	s32 moveX = (time_attack == 1 || time_attack == 2) ? 0 : 0x7800
	s32 moveY = (time_attack == 1 || time_attack == 2) ? 0 : 0xa000
	if(!original_mode)
	{
		// Move faster if player reached the end already
		//  -> We're misusing the "level.trigger0f" variable for the current extra speed-up value
		if (u16[0xffffb010] >= 0x32ba && u16[0xffffb014] <= 0x0380 && (level.framecounter & 0x03) == 0 && level.trigger0f < 0x80)
		{
			++level.trigger0f
		}
		u32[0xffffee98] += moveX * level.trigger0f / 0x80
		u32[0xffffee9c] += moveY * level.trigger0f / 0x80
	}
	u32[0xffffee98] += moveX
	u32[0xffffee9c] += moveY

	if (u16[0xffffee9c] < 0x05d0)
	{
		fn05333a()
	}
	else
	{
		u16[0xffffee9c] = 0x05d0
		u16[0xffffee98] = 0x045c
		level.dualplanecollision = 0
		objA0.update_address = 0x053322
		fn053322()
	}
}






// SOZ: disable the sound effects from switches if the level is over
// This change affects all modes, but the only modes that should see an effect are time attack modes
// Function taken from objects\09_soz\soz_pushswitch.lemon
//# address-hook(0x041a6c) end(0x041aa6)
function void fn041a6c()
{
	D0.u16 = objA0.subtype2c & 0x70
	if (D0.u16 == 0)
	{
		--u16[A0 + 0x34]
		if (s16[A0 + 0x34] >= 0)
			return

		u16[A0 + 0x34] = 9
	}

	if (u16[A0 + 0x36] == 0)
		return

	--u16[A0 + 0x36]
	if (u16[A0 + 0x36] == 0 && hud.dirty.timer)
	{
		playSound(0x91)
	}
	else
	{
		--objA0.value3a
		if (s8[A0 + 0x3a] < 0)
		{
			objA0.value3a = 3
			if (hud.dirty.timer)
				playSound(0x90)
		}
	}

	D4 = 1
}




// SOZ2: Enforce ghosts in time attack modes.
// Function taken from level\09_soz\09_soz2_ghostspawn.lemon
function bool isGhostSpawnEnabled()
{
	if (time_attack)
		return true
#if STANDALONE
	return (!Game.getSetting(SETTING_DISABLE_GHOST_SPAWN))
#else
	return true
#endif
}



// SOZ2: Enforce ghosts when first loading into SOZ2.
// Function taken from level\09_soz\level_soz.lemon
//# address-hook(0x05618c) end(0x0561b6)
function void InitLevelTiles.SOZ2()
{
	level.height.bitmask = 0x07ff
	level.height.tilemask = 0x07f0
	level.chunksize.bitmask = 0x3c
	u16[0xffffeec0] = 0x08
	if (u16[0xffffb010] >= 0x4e80)
	{
		fn05622c()
	}

	Level.GetCameraPosition()
	Level.InitialTilesFill()

	if (soz2_initial_ghosts)
	{
		fn055efc()
		soz2_initial_ghosts = 0
	}
}






// LRZ2: create a solid bridge above the load point to the boss area in Sonic/Tails time attack
// Function taken from level\10_lrz\level_lrz.lemon
//# address-hook(0x056fb2) end(0x056fba)
function void UpdateLevelTiles.LRZ2()
{
	if ((time_attack == 1 || time_attack == 2) && !isMainCharacter(CHARACTER_KNUCKLES))
		u16[0xffff82f6] = 0xa6a6	// create a solid bridge of chunks

	camera.foreground.y.u16 += camera.screenshake.offset
	LoadTileContentDefault()
}

// LRZ2: turn the collapsing platforms above the load point to the boss area into solid ground in Sonic/Tails time attack
// Function taken from object\level\barrier.lemon
//# address-hook(0x020630) end(0x020720)
function void fn020630()
{
	if ((time_attack == 1 || time_attack == 2) && global.zone_act == 0x0901 && !isMainCharacter(CHARACTER_KNUCKLES) && objA0.position.x.u16 >= 0x3720 && objA0.position.y.u16 == 0x0250)	// four platforms in question when not Knux
	{
		UnloadObject()
		return
	}

	objA0.update_address = 0x02095e
	objA0.render_flags |= render_flag.WORLD
	objA0.sprite_priority = 0x0280

	if (global.zone == 0x01)
	{
		objA0.mapping_offset = 0x21ea1a
		objA0.sprite_attributes = 0xc001

		D0.u8 = objA0.subtype2c
		if (objA0.subtype2c & 0x80)
		{
			u8[A0 + 0x40] = objA0.subtype2c & 0x0f
			D0.u8 &= 0x70
			objA0.update_address = 0x020af6
		}
		objA0.flags38 = ((D0.u8 & 0x0f) << 4) + 8

		D1.u8 = (objA0.subtype2c & 0x70) >> 2
		A1 = 0x020722 + D1.s16
		objA0.box_size.x = u8[A1]
		objA0.box_size.y = u8[A1+1]
		objA0.animation.sprite = u8[A1+2]
		objA0.subtype2c = u8[A1+3]

		A1 = 0x020732 + D1.s16 * 2
		u32[A0 + 0x30] = u32[(A1+=4)-4]
		objA0.countdown_callback = u32[(A1+=4)-4]
	}
	else if (global.zone == 0x06)
	{
		D0.u16 = u16(objA0.subtype2c & 0x3f) * 4 + 8
		D0.u16 = min(D0.u16, 0xff)

		objA0.flags38 = D0.u8
		if ((objA0.subtype2c & 0x40) == 0)
		{
			objA0.mapping_offset = 0x21e896
			objA0.sprite_attributes = 0x4001
			objA0.box_size.x = 0x40
			objA0.box_size.y = 0x10
			u32[A0 + 0x30] = 0x020cf4
			objA0.countdown_callback = 0x020d04
		}
		else
		{
			objA0.mapping_offset = 0x21e992
			objA0.sprite_attributes = 0x4001
			objA0.box_size.x = 0x20
			objA0.box_size.y = 0x30
			u32[A0 + 0x30] = 0x020d14
		}
	}

	fn020752()
}

// LRZ2: Remove orbiting spike balls from the end of Knuckles' path in time attack modes
// Function taken from objects\10_lrz\lrz_orbitingspikeball.lemon
//# address-hook(0x043c2c) end(0x043c82)
function void fn043c2c()
{
	if ((time_attack == 1 || time_attack == 2) && global.zone_act == 0x0901 && objA0.position.x.u16 >= 0x3c50)	// location of spike balls in question
	{
		UnloadObject()
		return
	}

	objA0.mapping_offset = 0x043d24
	objA0.sprite_attributes = 0x240d
	objA0.render_flags = render_flag.WORLD
	objA0.sprite_priority = 0x0280
	u16[A0 + 0x44] = objA0.position.x.u16
	u16[A0 + 0x46] = objA0.position.y.u16

	if (objA0.subtype2c & 0x01)
	{
		objA0.subtype2c &= ~0x01
		objA0.box_size.x = 0x20
		objA0.box_size.y = 0x20
		objA0.animation.sprite = 1

		objA0.update_address = 0x043cd6
		fn043cd6()
	}
	else
	{
		objA0.box_size.x = 0x10
		objA0.box_size.y = 0x10

		objA0.update_address = 0x043c88
		fn043c88()
	}
}






// HPZ boss: Unload the boss in time attack modes
// Function taken from bosses\boss_hpz_knuckles.lemon
//# address-hook(0x063d1a) end(0x063dd2)
function void fn063d1a()
{
	if (isMainCharacter(CHARACTER_KNUCKLES) || time_attack == 1 || time_attack == 2)
	{
		UnloadObject()
		if (time_attack)
		{
			move_area.left = camera.position.x.u16
		//	level.vertical_wrap = 0x0380
			move_area.bottom.target = 0x0380
		}
		return
	}

	A1 = 0x063cec
	if (InitBoss(0x063d2e))
		return

	StartBossFight()
#if STANDALONE
	level.boss_encounter = 3	// Usually only 0 or 1, but we're using a value of 3 here for "chooseFittingMusic"
#endif

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x085ca4
		u32[A1 + 0x34] = 0x063dd4
		u16[A1 + 0x2e] = 0x78
		u8[A1 + 0x27] = u8[A0 + 0x27]

		u8[A1 + 0x26] = 0x1f
	#if STANDALONE
		u8[A1 + 0x26] = BossHPZKnuckles.chooseMusicTrack()
	#endif
	}

	objA0.update_address = 0x063de0
	objA0.mapping_offset = 0x14a8d6
	objA0.sprite_attributes = 0x24da
	objA0.sprite_priority = 0x0100
	objA0.box_size.x = 0x18
	objA0.box_size.y = 0x18
	objA0.hitbox_extends.x = 0x09
	objA0.hitbox_extends.y = 0x13
	objA0.render_flags = render_flag.WORLD | render_flag.FLIP_X
	objA0.animation.sprite = 0xd8
	boss.remaining_hits = 8
	u32[A0 + 0x30] = 0x066771
	u16[A0 + 0x44] = 0

	copyMemory(0xfffffca0, 0xfffffc20, 0x20)

	CutsceneKnuckles.loadPalette()

#if STANDALONE
	// Change palette to fit
	//u16[0xfffffc24] = 0x064e
	//u16[0xfffffc26] = 0x020c
	//u16[0xfffffc28] = 0x0206
	//u16[0xfffffc2a] = 0x0080
	//u16[0xfffffc2c] = 0x000e
	//u16[0xfffffc2e] = 0x0008
#endif

	u16[0xfffffc2c] = 0x88

	level.bossarea.left -= getScreenExtend()
	level.bossarea.right += getScreenExtend()
}








// SSZ1 opening: direct time attack check from base game to use DAGE time attack flag
// Function taken from level\12_ssz\ssz_start.lemon
//# address-hook(0x065730) end(0x065758)
function void fn065730()
{
	A1 = 0x0663ba
	if (fn084fa4())
		return

#if STANDALONE
	if (time_attack || isMainCharacter(CHARACTER_KNUCKLES))
	{
		// Activate the bridge and unload cutscene Knuckles
		u8[0xffffeeda] = 0xff
		u16[0xfffffa9a] = 0		// if this flag from the opening cutscenes isn't cleared, the last boss of the act won't load all graphics
		UnloadObject()
		return
	}
#endif

	u8[0xfffffab8] = 0
	objA0.sprite_priority = 0x80
	copyMemory(0xfffffca0, 0xfffffc20, 0x20)

	CutsceneKnuckles.loadPalette()
}



// SSZ1 opening: direct time attack check from base game to use DAGE time attack flag
// Function taken from objects\12_ssz\ssz_extendiblebridge.lemon
//# address-hook(0x044fa2) end(0x045014)
function void fn044fa2()
{
	D1.u16 = objA0.countdown_value
	if (u16[0xffffeeda] != 0)
	{
	#if STANDALONE
		// Different behavior in Time Attack or when playing as Knuckles
		//  -> We want the bridge to be extended already
		if (time_attack || isMainCharacter(CHARACTER_KNUCKLES))
			objA0.countdown_value = 2
	#endif

		if (objA0.countdown_value == 0x68)
		{
			playSound(0x8f)
		}

		objA0.countdown_value -= 2
		if (objA0.countdown_value == 0)
		{
			u8[0xffffeed7] = 0
			move_area.left = 0
			move_area.right = 0x19a0
			level.vertical_wrap = 0xff00
			move_area.bottom.current = 0x1000
			move_area.bottom.target  = 0x1000

			checkpoint.x = 0x0140
			checkpoint.y = 0x0c6c
			checkpoint.number = 0x01
			Checkpoint.SaveCurrentState()

			checkpoint.time = 0
			objA0.update_address = 0x04501a
		}
	}

	D4.u16 = objA0.position.x.u16
	objA0.position.x.u16 = objA0.countdown_value + u16[A0 + 0x12]
	fn045026()
	DrawObject()
}






// SSZ1 GHZ/MTZ boss: direct time attack check from base game to use DAGE time attack flag
// Functions taken from objects\level\teleporter.lemon
//# address-hook(0x045528) end(0x0455c8)
function void fn045528()
{
	if ((time_attack == 1 || time_attack == 2) && objA0.position.x.u16 == 0x1a40)	// new check to remove teleporters at end of SSZ in time attacks
	{
		UnloadObject()
		return
	}

	objA0.update_address = 0x0455cc
	objA0.render_flags = render_flag.WORLD
	objA0.box_size.y = 0x10
	objA0.box_size.x = 0x18
	objA0.sprite_priority = 0x0180
	objA0.sprite_attributes = 0x035c
	objA0.mapping_offset = 0x046b3c
	u16[A0 + 0x16] = objA0.position.y.u16

	if (objA0.subtype2c & 0x80)
	{
		A1 = (objA0.subtype2c & 0x40) ? 0xffffeed4 : 0xffffeed2
		if ((u8[A1] & 0x80) == 0)
		{
		#if STANDALONE
			if (time_attack != 1 && time_attack != 2)
		#endif
			{
				// Start inside the floor
				objA0.velocity.y = 0x20
			}
		}
	}

	if (global.zone_act == 0x1701)
	{
		// Hidden Palace when entered through Giant Ring
		objA0.sprite_attributes = 0x0488
		objA0.animation.sprite = 0x0a
	}
	else if (global.zone == 0x16)
	{
		// Hidden Palace in normal gameplay
		if (allocDynamicObjectAfterA0())
		{
			objA1.update_address = 0x045b94
			u16[A1 + 0x2e] = A0.u16
		}

		objA0.sprite_attributes = 0x052e
		if (global.characters == CHARS_KNUCKLES_ALONE)
		{
			objA0.subtype2c = 0x4a
		}
		objA0.animation.sprite = 0x0a
	}
	else	// Sky Sanctuary?
	{
		if (objA0.position.x.u16 >= 0x1a00 && objA0.position.y.u16 < 0x0680)
		{
			fn045a66()
			return
		}
	}

	fn0455cc()
}

function void fn0455cc_sub()
{
	if (objA0.subtype2c == 0 && u8[0xffffeed6] != 0)
		return

	if (objA0.velocity.y == 0)
	{
		D1 = 0x23
		A2 = 0x0466e8
		D4.u16 = objA0.position.x.u16
		fn01e2fe()
	}

	if (objA0.subtype2c == 0)
		return

	if (objA0.subtype2c & 0x80)
	{
		A1 = (objA0.subtype2c & 0x40) ? 0xffffeed4 : 0xffffeed2
	#if STANDALONE
		if (time_attack == 1 || time_attack == 2)
		{
			u8[A1] = 0xff
		}
		else
	#endif
		if ((u8[A1] & 0x80) == 0)
			return

		if (objA0.velocity.y != 0)
		{
			if ((level.framecounter & 0x03) == 0)
			{
				--objA0.velocity.y
			}
			return
		}
	}

	if (objA0.flags2a & 0x08)
	{
		A2 = 0xffffb000
		D0.u16 = u16[A2 + 0x10] - objA0.position.x.u16 + 0x0c
		if (D0.u16 < 0x18)
		{
			if (u8[A2 + 0x2e] == 0 && u8[A2 + 0x05] < 0x04 && debug_mode.state == 0)
			{
				if (allocDynamicObjectAfterA0())
				{
					u16[A0 + 0x3c] = A1.u16
					objA1.update_address = 0x0458b4
					u16[A1 + 0x48] = A0.u16
					objA1.position.x.u16 = objA0.position.x.u16
					objA1.position.y.u16 = objA0.position.y.u16
					u16[A2 + 0x18] = 0
					u16[A2 + 0x1c] = 0
					u16[A2 + 0x1a] = 0xffff
					u8[A2 + 0x3d] = 0
					u8[A2 + 0x2e] = 0x01
					u8[A2 + 0x20] = 0x05
					objA0.update_address = 0x0456f4
					u16[A0 + 0x38] = 0xff00

					playSound(0x53)
				}
			}
		}
	}
}






// SSZ1 GHZ boss: direct time attack check from base game to use DAGE time attack flag
// Function taken from bosses\boss_ssz_mid1.lemon
//# address-hook(0x07a20e) end(0x07a28e)
function void fn07a20e()
{
#if STANDALONE
	if (time_attack == 1 || time_attack == 2)
	{
		u8[0xffffeed2] = 0xff
		UnloadObject()
		return
	}
#endif

	objA0.update_address = 0x08488a		// Address of "Object.CountdownAndTrigger"
	level.boss_encounter = 1
	objA0.countdown_value = 0x1f
	objA0.countdown_callback = 0x07a294
	playMusic(MUSIC_CTRL_FADEOUT)

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x085b30
		u8[A1 + 0x2c] = 0x19
	}

	objA0.position.x.u16 = camera.position.x.u16 + 0x0110 + getScreenExtend()
	objA0.position.y.u16 = camera.position.y.u16 - 0x40
	u16[0xfffffa88] = 0

	requestLoadingPatterns(0x7b)

	Kosinski.addToDMAQueue(0x17edb4, 0x8d00)

	copyMemory(0xfffffca0, 0xfffffc20, 0x20)

	loadPaletteLine1(0x07d850)
}




// SSZ1 MTZ boss: direct time attack check from base game to use DAGE time attack flag
// Function taken from bosses\boss_ssz_mid2.lemon
//# address-hook(0x07a6a6) end(0x07a70c)
function void fn07a6a6()
{
#if STANDALONE
	// Skip boss in Time Attack
	if (time_attack == 1 || time_attack == 2)
	{
		u8[0xffffeed4] = 0xff
		UnloadObject()
		return
	}

	// Init achievement tracking
	Game.setAchievementValue(ACHIEVEMENT_SSZ_DECOYS, 0)
#endif

	objA0.update_address = 0x08488a		// Address of "Object.CountdownAndTrigger"
	level.boss_encounter = 1
	objA0.countdown_value = 0x1f
	objA0.countdown_callback = 0x07a712
	playMusic(MUSIC_CTRL_FADEOUT)

	if (allocDynamicObjectStd())
	{
		objA1.update_address = 0x085b30
		u8[A1 + 0x2c] = 0x19
	}
	u16[0xfffffa88] = 0

	requestLoadingPatterns(0x7b)

	Kosinski.addToDMAQueue(0x17efa6, 0x83e0)

	copyMemory(0xfffffca0, 0xfffffc20, 0x20)

	loadPaletteLine1(0x07b268)
}






// DEZ1 boss: add time attack check to unload boss
// Function taken from bosses\boss_dez1.lemon
//# address-hook(0x07ddb4) end(0x07de24)
function void fn07ddb4()
{
//	#if STANDALONE
//		if (time_attack)
//		{
//			UnloadObject()
//			loadPaletteLine1(0x07effc)
//			move_area.left = 0x3500 // - getScreenWidth() / 2
//			level.vertical_wrap = 0x028c
//			move_area.bottom.current = level.vertical_wrap
//			move_area.bottom.target = move_area.bottom.current
//			return
//		}
//	#endif

	A1 = 0x07dda4
	if (InitBoss(0x07ddbe))
		return

	objA0.value26 =  0x2e
	StartBossFight()

#if STANDALONE
	if (getScreenWidth() >= 400)
	{
		level.bossarea.left = 0x3740 - getScreenWidth() / 2
		level.bossarea.right = level.bossarea.left + getScreenExtend() * 2

		if (isMainCharacter(CHARACTER_KNUCKLES))
		{
			level.bossarea.right += 0x0a
			u8[0xffff82e0] = 0x8f
			u8[0xffff835a] = 0x8f
			u8[0xffff83d4] = 0x8f
		}
	}
#endif

	objA0.update_address = 0x07de28
	objA0.countdown_callback = 0x07de2c

	setupObjectAttributesFull(0x07ef46)

	objA0.base_state = 0
	boss.remaining_hits = 0
	u8[A0 + 0x42] = 0
	u16[A0 + 0x3a] = 0x4000
	u16[A0 + 0x3c] = 0x8000

	spawnChildObjects(0x07ef8e)
	spawnSimpleChildObjects(0x07ef96)

	requestLoadingPatterns(0x7b)
	Kosinski.addToDMAQueue(0x1805a0, 0x8000)

	loadPaletteLine1(0x07effc)
}


//# address-hook(0x07e79c) end(0x07e7ae)
function void fn07e79c()
{
	fn07ed6c()

	A1 = 0xffff0000 + u16[A0 + 0x46]
	if (u32[A1] != 0x07de6e || time_attack == 1 || time_attack == 2)
		return

	objA0.base_state = 0x04
	fn07e7b4()
}

//# address-hook(0x07e80e) end(0x07e81c)
function void fn07e80e()
{
	if (time_attack == 1 || time_attack == 2)
	{
		UnloadObject()
		return
	}

	setupObjectAttributesBasic(0x07ef58)

	objA0.update_address = 0x07e820
	fn07ed54()
	fn07e820()
}

//# address-hook(0x07de6e) end(0x07de8e)
function void fn07de6e()
{
	// Targets:
	//  - 0x07dea2	-> objA0.base_state = 0x00
	//  - 0x07dec6	-> objA0.base_state = 0x02
	//  - 0x07dea2	-> objA0.base_state = 0x04
	//  - 0x07df14	-> objA0.base_state = 0x06
	//  - 0x07dea2	-> objA0.base_state = 0x08
	//  - 0x07df40	-> objA0.base_state = 0x0a
	//  - 0x07dea2	-> objA0.base_state = 0x0c
	//  - 0x07df84	-> objA0.base_state = 0x0e
	call tableLookupAddress(0x07de92, objA0.base_state)

	if ((global.framecounter.low & 0x1f) == 0 && time_attack != 1 && time_attack != 2)
	{
		playSound(0xc3)
	}
	fn07ee36()
}





// DEZ2 boss: disable the boss in time attack modes and point the elevator exit to the right
// Function taken from bosses\boss_dez2.lemon
//# address-hook(0x07f06c) end(0x07f0ba)
function void fn07f06c()
{
	if (time_attack == 1 || time_attack == 2)
	{
		UnloadObject()
		u8[0xffff8393] = 0x89	// have the elevator entrance that eventually gets destroyed face the boss area exit
		move_area.right = 0x4900
		return
	}

	A1 = 0x07f0be
	if (InitBoss(0x07f076))
		return

	objA0.update_address = 0x07f0ce
	objA0.countdown_callback = 0x07f0d2

	A1 = 0x07f0c6
	objA0.value26 = 0x19
	StartBossFight()
	u8[0xfffffab8] = 0

	requestLoadingPatterns(0x76)
	Kosinski.addToDMAQueue(0x181002, 0x7140)
	loadPaletteLine1(0x07fd08)
	spawnChildObjects(0x07fc8c)
}



// DEZ2 boss: remove the elevator that lets players onto the boss arena ceiling in time attack mode
// Function taken from objects\13_dez\dez_gravitytransporter.lemon
//# address-hook(0x048c16) end(0x048c2a)
function void fn048c16()
{
	if ((time_attack == 1 || time_attack == 2) && objA0.position.x.u16 == 0x35d0 && objA0.position.y.u16 == 0x032c && global.zone_act.apparent == 0x0b01)
	{
		UnloadObject()
		return
	}

	A1 = 0xffffb000
	A4 = A0 + 0x30
	fn048c30()

	A1 = 0xffffb04a
	A4 = A0 + 0x3a
	fn048c30()

	CheckForUnloadObject()
}






// DEZ2 boss: create an ending for time attack modes that accurately represents the start of the final boss
// UpdateLevelScrolling.DEZ2() is handled in main.lemon since it also handles all manner of other level changes.
// Function taken from level\13_dez\level_dez.lemon







// Do not start the level results win pose in marathon modes
// Function taken from objects\basics\signpost.lemon
//# address-hook(0x0869c6) end(0x0869f4)
//# address-hook(0x0869c6) end(0x0869f4)
function void StartCharacterWinPose()
{
#if STANDALONE
	if (u8[A1 + 0x2a] & char.flag.ROLLING)
	{
		// Correct position, so character is not partially in the ground
		u32 backupA0 = A0
		A0 = A1
		Character.LandingOnGroundStandUp()
		A0 = backupA0
	}

	// Fix for player being able to walk around and do stuff, if carried by Tails when touching ground
	tails.carrying = 0
#endif

	objA1.velocity.x = 0
	objA1.velocity.y = 0
	u16[A1 + 0x1c] = 0
	objA1.state = (time_attack < 3) ? char.state.WIN_POSE : char.state.STANDING
	if (objA1.state == char.state.STANDING)
		objA1.render_flags &= 0xfe	// make the character face to the right if standing, preparing for the next act
	objA1.flags2a &= ~char.flag.PUSHING
	u8[A1 + 0x2e] = 0x81
	u8[A1 + 0x3d] = 0

	objA0.flags2a &= ~0x20
	objA0.flags2a &= ~0x40
}






// Have level results add up instantly and not make any point-adding noises in marathon modes.
// This function also maintains shields on certain transitions between Acts 1 and 2.
// Function taken from maingame\hud\levelresults.lemon
//# address-hook(0x02dc36) end(0x02dd38)
function void LevelResults.UpdateBonusCounting()
{
	if (time_attack <= 2)
	{
		if (objA0.countdown_value != 0)
		{
			--objA0.countdown_value
			if (objA0.countdown_value != 289)
				return

			// Reset char.drown_countdown for both characters
			u8[0xffffb000 + 0x2c] = 30
			u8[0xffffb04a + 0x2c] = 30

			playMusic(MUSIC_LEVELCLEAR)
			return
		}

		u16 delta = 10
	#if STANDALONE
		if (Game.getSetting(SETTING_LEVELRESULT_SCORE) && !original_mode)
		{
			// Count faster over time
			if (results.total_bonus >= 3000)
				delta = 30
			else if (results.total_bonus >= 1000)
				delta = 20

			// Allow for manually (more or less) skipping the counter
			if ((control.pad1.state & (CONTROL_ABC | CONTROL_START)) || Input.buttonDown(BUTTON_Y))
			{
				delta = 200
			}
		}
	#endif

		D0 = 0
		if (results.time_bonus != 0)
		{
			u16 diff = min(delta, results.time_bonus)
			D0.u16 += diff
			results.time_bonus -= diff
		}
		if (results.ring_bonus != 0)
		{
			u16 diff = min(delta, results.ring_bonus)
			D0.u16 += diff
			results.ring_bonus -= diff
		}

		results.total_bonus += D0.u16
		if (D0.u16 != 0)
		{
			// Still counting
			addScore(D0)
			if ((level.framecounter & 0x03) == 0)
			{
				playSound(SFX_CLICK)
			}
		}
		else
		{
			// Done
			playSound(0xb0)

			// Special handling for Sky Sanctuary Zone (S/T) and probably also Lava Reef Boss
			if (global.zone_act == 0x0a00 || u16[A0 + 0x2c] != 0)
			{
				sram.block_interrupts.u8 = 0xff
				SaveGameOnLevelFinished()
			}

			objA0.countdown_value = 90
			objA0.base_state += 2
			LevelResults.AdvanceToNextAct()
		}
	}
	else
	{
		// Reset char.drown_countdown for both characters
		u8[0xffffb02c] = 30
		u8[0xffffb076] = 30
		objA0.countdown_value = 0

		// Remove peelout charging and resulting speed, as the animations can revert to standing at the instant the act changes
		u8[0xffffb03d] = 0		// Spindash flag is only active during standing/running if a peelout is charging
		u16[0xffffb03e] = 0		// Clear charge

		addScore(results.time_bonus + results.ring_bonus)
		results.time_bonus = 0
		results.ring_bonus = 0

		// Special handling for Sky Sanctuary Zone (S/T) and probably also Lava Reef Boss
		if (global.zone_act == 0x0a00 || u16[A0 + 0x2c] != 0)
		{
			u8[0xffffef56] = 0xff
			SaveGameOnLevelFinished()
		}

		objA0.countdown_value = 0
		objA0.base_state += 2

		if (global.zone_act.apparent == 0x0100 || global.zone_act.apparent == 0x0800 || global.zone_act.apparent == 0x0900 || global.zone_act.apparent == 0x0b00)
		{
			// global.shields_backup_1 = u8[0xffffb02b]
			global.shields_backup_2 = u8[0xffffb02b]	// a check was added to InitializeMainGame() for this marathon mode feature
			if (global.zone_act.apparent == 0x0800)
				soz2_initial_ghosts = 1		// set darkness and aggressive ghosts at SOZ2 start
			D0.u16 = global.zone_act.apparent + 1
			TriggerNextZone()
		}
		else if (global.act.apparent == 0 && global.zone_act != 0x1600 && global.zone_act != 0x0a00)
			LevelResults.AdvanceToNextAct()
		else
		{
			if (global.zone_act.apparent == 0x0301)			// CNZ2
				D0.u16 = 0x0500
			else if (global.zone_act.apparent == 0x0701)	// MHZ2
				D0.u16 = 0x0400
			else if (global.zone_act.apparent == 0x0401)	// FBZ2
				D0.u16 = 0x0800
			else if (global.zone_act == 0x1600)				// LRZ2 boss
				D0.u16 = 0x1601
			else if (global.zone_act.apparent == 0x0a00)	// SSZ1
				D0.u16 = 0x0b00
			else
				D0.u16 = global.zone_act.apparent + 0xff	// take current zone_act, which ends in 0x01, and add ff to get to the next zone's first act
			TriggerNextZone()
		}
	}
}








// Endings: display the version number in marathon modes and display credits in all modes except Original Mode.
// Functions taken from level_outro.lemon
//# address-hook(0x05aaf2) end(0x05aaf6)
function void UpdateLevelTiles.Outro()		// main outro (falling from sky, ocean)
{
	if (time_attack >= 3)
	{
		PrintVersionNumber()
	}
	if (level.framecounter > 0x2f12 && !original_mode)
		Renderer.drawCustomSprite("credits", 0, 0, 0, SPRITE_FLAG_PRIO, 0xe001, 0, min(255, (level.framecounter - 0x2f12) * 8))

	// s16[0xffffeec0] == 0x00	-> First part until Angel Island gets visible
	// s16[0xffffeec0] == 0x04	-> Second part until the Tornado flies away from Angel Island again
	// s16[0xffffeec0] == 0x08	-> Third part before fade-out to credits
	call 0x05aafa + s16[0xffffeec0]
}

//# address-hook(0x05afc4) end(0x05afee)
function void fn05afc4()	// Angel Island Zone scene
{
	if (time_attack >= 3)
	{
		PrintVersionNumber()
	}
	UpdateBackgroundScrolling.AIZ1()
	fn04f2f6()
	u32[0xffffa800] = 0
	u16[0xffffa806] = D2.u16
	u16[0xffffeec8] = (D0.u16 + 0xe0) & level.height.tilemask
	u16[0xffffeeca] = 0x0f
	level.scrolling_routine += 0x04
	fn05aff6()
}

// Functions taken from maingame\outro\outro_shared.lemon
//# address-hook(0x05928c) end(0x0592bc)
function void fn05928c()
{
	if (time_attack >= 3 && global.zone_act == 0x0d01)	// if not limited to Sonic/Tails outro, then version number will show during gameplay in Knuckles' SSZ.
	{
		PrintVersionNumber()
	}
	// Palette cycling for the ocean
	if (u8[0xfffff650] == 0)
	{
		--u16[0xfffff634]
		if (s16[0xfffff634] < 0)
		{
			u16[0xfffff634] = 0x07
			D0.u16 = u16[0xfffff632] + 0x06
			if (D0.u16 >= 0x30)
				D0 = 0
			u16[0xfffff632] = D0.u16
			u32[0xfffffc7a] = u32[0x0592be + D0.s16]
			u16[0xfffffc7e] = u16[0x0592c2 + D0.s16]
		}
	}
}




// Function taken from maingame\outro\outro_knuckles.lemon
//# address-hook(0x05e6c0) end(0x05e6f6)
function void fn05e6c0()
{
	if (!level.trigger0f)
	{
		level.trigger0f = 1		// use a trigger ID as a flag to say we're in the outro
		level.framecounter = 0	// reset the level framecounter, which will be used to time when DAGE credits appear
	}

	// Targets:
	//  - 0x05e70e	-> objA0.base_state = 0x00  -> Initialization
	//  - 0x05e80a	-> objA0.base_state = 0x02  -> Wait time until the Tornado gets visible
	//  - 0x05e832	-> objA0.base_state = 0x04  -> Tornado gets into the screen from below
	//  - 0x05e86a	-> objA0.base_state = 0x06  -> Hovering in place, Knuckles signalling his okay
	//  - 0x05e890	-> objA0.base_state = 0x08  -> Flying out of the screen to the right
	//  - 0x05e916	-> objA0.base_state = 0x0a  -> Flying right to left, medium sized
	//  - 0x05e98a	-> objA0.base_state = 0x0c  -> Flying behind the island, small sized
	//  - 0x05e9c2	-> objA0.base_state = 0x0e  -> Angel Island gets repowered and starts rising
	//  - 0x05e9e2	-> objA0.base_state = 0x10  -> Flying away to the right
	call tableLookupAddress(0x05e6fc, objA0.base_state)

	if (outro.ending_type > 0)
	{
		A1 = 0x07dd5a
		A2 = 0xfffffc5c
		fn085a1a()
	}

	A1 = 0xffffb000
	objA1.position.x.u16 = objA0.position.x.u16
	objA1.position.y.u16 = objA0.position.y.u16

	DrawObject()
}

// Function taken from level\12_ssz\level_ssz_knuckles.lemon
//# address-hook(0x058aa0) end(0x058aac)
function void UpdateLevelTiles.SSZ_Knuckles()
{
	if (level.trigger0f && time_attack >= 3)
	{
		PrintVersionNumber()
	}
	if (level.trigger0f && level.framecounter > 0x2f1f && !original_mode)
		Renderer.drawCustomSprite("credits", 0, 0, 0, SPRITE_FLAG_PRIO, 0xe001, 0, min(255, (level.framecounter - 0x2f1f) * 8))

	camera.foreground.y.u16 += camera.screenshake.offset
	call 0x058ab0 + s16[0xffffeec0]
}






// Do not allow shields to downgrade to classic shields in time attack modes
// Functions taken from objects\basics\shields.lemon
//# address-hook(0x019602) end(0x0196c0)
function void FireShield.Update()
{
	A2 = 0xffff0000 + u16[A0 + 0x42]
	if ((u8[A2 + 0x2b] & char.bonus.INVINCIBLE) || (u8[A2 + 0x20] == char.state.DISAPPEARED))
		return

	// Lost shield?
	if ((u8[A2 + 0x2b] & char.bonus.ANY_SHIELD) == 0)
	{
		u8[A2 + 0x2b] &= ~0x71
		objA0.update_address = 0x0194ce
		return
	}

	if (u8[A2 + 0x2a] & char.flag.UNDERWATER)
	{
		u8[A2 + 0x2b] &= ~0x71
		if (allocDynamicObjectStd())
		{
			objA1.update_address = 0x01e68e
			objA1.position.x.u16 = objA0.position.x.u16
			objA1.position.y.u16 = objA0.position.y.u16
		}
		objA0.update_address = 0x0194ce

	#if STANDALONE
		if (Game.getSetting(SETTING_SHIELD_TYPES) == 3 && !time_attack && !original_mode)
		{
			// Replace with classic shield when using upgradable shields
			u8[A2 + 0x2b] |= char.bonus.ANY_SHIELD
		}
	#endif
		return
	}

	objA0.position.x.u16 = u16[A2 + 0x10]
	objA0.position.y.u16 = u16[A2 + 0x14]
	if (objA0.state == 0)
	{
		objA0.flags2a = u8[A2 + 0x2a] & char.flag.FACING_LEFT
		if (global.inv_gravity)
			objA0.flags2a |= 0x02

		objA0.sprite_attributes = (objA0.sprite_attributes & 0x7fff) | (u16[A2 + 0x0a] & 0x8000)
	}

	Object.animationUpdate(0x019a02)
	objA0.sprite_priority = (objA0.animation.sprite >= 0x0f) ? 0x200 : 0x80

	Shield.SharedSpriteUpdate()
	DrawObject()
}

//# address-hook(0x019732) end(0x01980a)
function void LightningShield.Update()
{
	A2 = 0xffff0000 + u16[A0 + 0x42]
	if ((u8[A2 + 0x2b] & char.bonus.INVINCIBLE) || (u8[A2 + 0x20] == char.state.DISAPPEARED))
		return

	// Lost shield?
	if ((u8[A2 + 0x2b] & char.bonus.ANY_SHIELD) == 0)
	{
		u8[A2 + 0x2b] &= ~0x71
		objA0.update_address = 0x0194ce
		return
	}

	if (u8[A2 + 0x2a] & char.flag.UNDERWATER)
	{
		u8[A2 + 0x2b] &= ~0x71
		if (global.fade_timer != 0)
		{
			objA0.update_address = 0x0194ce
		}
		else
		{
			objA0.update_address = 0x01989e

			copyMemory(0xfffff000, 0xfffff080, 0x80)
			fillMemory_u32(0xfffff080, 0x80, 0x0eee0eee)	// Fill palette with white color

			u16[0xfffff0c0] = 0
			objA0.animation.timer = 3
		}

	#if STANDALONE
		// Kill all enemies in water
		Game.setAchievementValue(ACHIEVEMENT_ELECTROCUTE, level.framecounter)
		Character.clearEnemiesOnScreen(water.height.current)

		if (Game.getSetting(SETTING_SHIELD_TYPES) == 3 && !time_attack && !original_mode)
		{
			// Replace with classic shield when using upgradable shields
			u8[A2 + 0x2b] |= char.bonus.ANY_SHIELD
		}
	#endif
		return
	}

	objA0.position.x.u16 = u16[A2 + 0x10]
	objA0.position.y.u16 = u16[A2 + 0x14]
	objA0.flags2a = u8[A2 + 0x2a] & char.flag.FACING_LEFT
	if (global.inv_gravity)
		objA0.flags2a |= 0x02

	objA0.sprite_attributes = (objA0.sprite_attributes & 0x7fff) | (u16[A2 + 0x0a] & 0x8000)

	if (objA0.state != 0)
	{
		LightningShield.CreateSparks()
		objA0.state = 0
	}

	Object.animationUpdate(0x019a2a)
	objA0.sprite_priority = (objA0.animation.sprite >= 0x0e) ? 0x200 : 0x80

	Shield.SharedSpriteUpdate()
	DrawObject()
}




//# address-hook(0x01d57e) end(0x01d5d6)
function void MonitorIntact.Init()
{
	objA0.base_state += 2
	objA0.hitbox_extends.x = 0x0f
	objA0.hitbox_extends.y = 0x0f
	objA0.mapping_offset = 0x01dba2
	objA0.sprite_attributes = 0x04c4
	objA0.render_flags |= render_flag.WORLD
	objA0.sprite_priority = 0x180
	objA0.box_size.x = 0x0e
	objA0.box_size.y = 0x10

#if STANDALONE
	if (Game.getSetting(SETTING_MONITOR_STYLE) == 1 && !original_mode)
	{
		objA0.box_size.x = 0x11
		objA0.box_size.y = 0x0e
	}

	objA0.subtype2c = Monitor.getRandomizedType(objA0.subtype2c, false)

	if (objA0.subtype2c == 0x0f && time_attack != 2)	// If an item is set for Time Stone Trial mode and we're not in that mode,
		objA0.subtype2c = 0x03							// revert it to a standard item (currently only Time Freeze to Super Ring).
	else if (objA0.subtype2c == 0x01 && time_attack == 2)	// If in Time Stone Trial mode, convert 1UPs
		objA0.subtype2c = 0x0f								// into Time Freeze.
	else if (objA0.subtype2c == 0x01 && time_attack == 1)	// If in standard Time Attack mode, convert 1UPs
		objA0.subtype2c = 0x03								// into Super Rings.
#endif

	if (objA0.respawn_entry)
	{
		A2 = 0xffff0000 + objA0.respawn_entry
		if (u8[A2] & 0x01)
		{
			objA0.animation.sprite = 0x0b
		#if STANDALONE
			objA0.update_address = 0x01d61a		// Needed for render hook, simply calls "DrawOrUnloadObject"
		#else
			objA0.update_address = 0x01b588		// Address of "DrawOrUnloadObject"
		#endif
			return
		}
	}

	u8[A0 + 0x28] = 0x46
	objA0.state = objA0.subtype2c
#if STANDALONE
	if (objA0.state == 0x0b)	// Classic Shield's state is not completely supported
		objA0.state = 0x05
#endif

	MonitorIntact.UpdateDefault()
}



function bool Monitor.enforceClassicShield()
{
	if (time_attack || original_mode)
		return false

	u8 setting = Game.getSetting(SETTING_SHIELD_TYPES)
	if (setting == 0)
	{
		return true
	}
	else if (setting == 3)
	{
		return (u8[0xffffb02b] & char.bonus.ANY_SHIELD) == 0
	}
	return false
}



function u8 Monitor.getRandomizedType(u8 type, bool hiddenMonitor)
{
	if (type & 0x10)	// This flag marks shield monitors that should be a classic shield when having all shield types active
	{
		if (Game.getSetting(SETTING_SHIELD_TYPES) == 2 && !time_attack && !original_mode)
		{
			type = 0x0b
		}
		else
		{
			type &= ~0x10
		}
	}

	if (type <= 0x08 || type == 0x0b)
	{
		if (Game.getSetting(SETTING_RANDOM_MONITORS) == 2 && !time_attack && !original_mode)
		{
			// Monitor randomization
			type = Monitor.getRandomMonitorType(hiddenMonitor)

			if (type >= 0x05 && type <= 0x07)	// Shield
			{
				if (Game.getSetting(SETTING_SHIELD_TYPES) == 2)
				{
					u8 random = (global.level_random_base ^ ((objA0.position.x.u16 + objA0.position.y.u16) >> 4)) & 0x03
					if (random == 0x03)
						type = 0x0b
				}
			}
		}
		else if (Game.getSetting(SETTING_RANDOM_MONITORS) == 1 && !time_attack && !original_mode)
		{
			// Shield randomization
			if ((type >= 0x05 && type <= 0x07) || type == 0x0b)
			{
				if (Game.getSetting(SETTING_SHIELD_TYPES) == 2)
				{
					u8 random = (global.level_random_base ^ ((objA0.position.x.u16 + objA0.position.y.u16) >> 4)) & 0x03
					type = (random < 3) ? (0x05 + random) : 0x0b
				}
				else
				{
					u8 random = (global.level_random_base ^ objA0.position.x.u16 ^ objA0.position.y.u16) % 3
					type = 0x05 + random
				}
			}
		}
	}

	if (Game.getSetting(SETTING_RANDOM_MONITORS) != 0 && !time_attack && !original_mode)
	{
		// No lightning shield or fire shield underwater
		if ((type == 0x05 || type == 0x06) && level.water_present && objA0.position.y.u16 > water.height.current)
		{
			// Make it either a bubble shield or rings
			type = (type == 0x05) ? 0x07 : 0x03
		}
	}

	if (Game.getSetting(SETTING_INFINITE_LIVES) && !original_mode && time_attack != 2)	// || time_attack
	{												// We deliberately don't include this check from vanilla AIR here, as we have a custom correction in MonitorIntact.Init().
		// Replace extra life monitors
		if (type == 0x01)
		{
			type = 0x03
		}
	}

	return type
}






//# address-hook(0x01d7ba) end(0x01d7c4)
function void ItemEffect.BaseUpdate()
{
	// Targets:
	//  - 0x01d7ce 	-> objA0.base_state = 0x00	-> Initialization
	//  - 0x01d81a 	-> objA0.base_state = 0x02	-> Rising animation
	//  - 0x01db2e 	-> objA0.base_state = 0x04	-> Wait time when stopped (+ fade-out in S3AIR)
	call tableLookupAddress(0x01d7c8, objA0.base_state)
}


//# address-hook(0x01d820) end(0x01d878)
function void ItemEffect.UpdateDefaultInternal()
{
#if STANDALONE
	if (u8[A0 + 0x49] != objA0.state)
	{
		// Go back from Classic Shield to original if player acquired a shield meanwhile
		//  -> E.g. when opening two shield monitor quickly one after another
		if (!Monitor.enforceClassicShield())
		{
			objA0.state = u8[A0 + 0x49]
		}
	}
#endif

	if ((objA0.render_flags & render_flag.FLIP_Y) == 0)
	{
		if (objA0.velocity.y < 0)
		{
			UpdateMovementStraightSimple()
			objA0.velocity.y += 0x18
			return
		}
	}
	else
	{
		if (objA0.velocity.y >= 0)
		{
			UpdateMovementStraightSimple()
			objA0.velocity.y -= 0x18
			return
		}
	}

	objA0.base_state += 2
	u16[A0 + 0x24] = 0x1d

	A1 = 0xffff0000 + u16[A0 + 0x42]
	A2 = (A1 == 0xffffb000) ? 0xfffffecc : 0xfffffece
#if STANDALONE
	if (objA0.state == 0x0b)	// Classic Shield
	{
		ItemEffect.applyShield(0, 0x0194ce, 0x3a)
	}
	else if (objA0.state == 0x0f && time_attack == 2)	// Time Freeze
	{
		ItemEffect.ApplyTimeFreeze()
	}
	else
#endif
	{
		// Targets:
		//  - 0x01d898	-> objA0.base_state = 0x01
		//  - 0x01d890	-> objA0.base_state = 0x02
		//  - 0x01d8ac	-> objA0.base_state = 0x03
		//  - 0x01d90a	-> objA0.base_state = 0x04
		//  - 0x01d954	-> objA0.base_state = 0x05
		//  - 0x01d992	-> objA0.base_state = 0x06
		//  - 0x01d9d0	-> objA0.base_state = 0x07
		//  - 0x01da0e	-> objA0.base_state = 0x08
		//  - 0x01da60	-> objA0.base_state = 0x09
		call tableLookupAddress(0x01d87c, objA0.state * 2)
	}
}

function void ItemEffect.ApplyTimeFreeze()
{
	++u16[A2]
	freeze_time += 300	// freeze time for 5 seconds (300 frames)
	alternatingRingSoundState = !alternatingRingSoundState
	if (!alternatingRingSoundState)
		playSound(0xde)
	else
		playSound(0xdd)
}


function u64 Monitor.getIconSpriteKey(u8 type)
{
	if (type == 0)
		return "monitor_icon_static"
	else if (type == 0x01)
		return (getMainCharacter() == CHARACTER_SONIC) ? "monitor_icon_sonic" : (getMainCharacter() == CHARACTER_TAILS) ? "monitor_icon_tails" : "monitor_icon_knuckles"
	else if (type == 0x02)
		return "monitor_icon_robotnik"
	else if (type == 0x03)
		return "monitor_icon_ring"
	else if (type == 0x04)
		return "monitor_icon_speedshoes"
	else if (type == 0x05)
		return "monitor_icon_fireshield"
	else if (type == 0x06)
		return "monitor_icon_lightningshield"
	else if (type == 0x07)
		return "monitor_icon_bubbleshield"
	else if (type == 0x08)
		return "monitor_icon_invincibility"
	else if (type == 0x09)
		return "monitor_icon_super"
	else if (type == 0x0b)
		return "monitor_icon_classicshield"
	else if (type == 0x0f)
		return "monitor_icon_timefreeze"
	return 0
}






// More enforcement of only Elemental Shields in Original, Challenge, and Marathon Modes
// Function taken from scripts\maingame\maingame.lemon
//# address-hook(0x0069b8) end(0x006a74)
function void RestoreShield()
{
	if (global.zone_act == 0x0d01)	// No shields in outro
		return

	if (global.zone >= 0x0e && global.zone < 0x16)
	{
		// Shield allowed in Gumball Machine and Glowing Spheres bonus stages
		if (global.zone != 0x13 && global.zone != 0x14)
			return
	}

	// Restore shield
	u8 shieldMask = char.bonus.ELEMENTAL_SHIELDS
#if STANDALONE
	if (Game.getSetting(SETTING_SHIELD_TYPES) != 1 && !time_attack && !original_mode)
		shieldMask = char.bonus.ALL_SHIELDS	// Support classic shield
#endif
	A1 = 0xffffb000
	u8 shieldFlags = global.shields_backup_1 & shieldMask
	global.shields_backup_1 = 0
	if (shieldFlags == 0)
	{
		shieldFlags = global.shields_backup_2 & shieldMask
		global.shields_backup_2 = 0
	}

	if (shieldFlags & char.bonus.SHIELD_FIRE)
	{
		u8[A1 + 0x2b] &= ~char.bonus.ALL_SHIELDS
		u8[A1 + 0x2b] |= (char.bonus.ANY_SHIELD | char.bonus.SHIELD_FIRE)
		u32[0xffffcce8] = 0x0195a6
		u16[0xffffcce8 + 0x42] = A1.u16
	}
	else if (shieldFlags & char.bonus.SHIELD_LIGHTNING)
	{
		u8[A1 + 0x2b] &= ~char.bonus.ALL_SHIELDS
		u8[A1 + 0x2b] |= (char.bonus.ANY_SHIELD | char.bonus.SHIELD_LIGHTNING)
		u32[0xffffcce8] = 0x0196c2
		u16[0xffffcce8 + 0x42] = A1.u16
	}
	else if (shieldFlags & char.bonus.SHIELD_BUBBLE)
	{
		u8[A1 + 0x2b] &= ~char.bonus.ALL_SHIELDS
		u8[A1 + 0x2b] |= (char.bonus.ANY_SHIELD | char.bonus.SHIELD_BUBBLE)
		u32[0xffffcce8] = 0x0198be
		u16[0xffffcce8 + 0x42] = A1.u16
	}
#if STANDALONE
	else if ((Game.getSetting(SETTING_SHIELD_TYPES) != 1 && !time_attack && !original_mode) && (shieldFlags & char.bonus.ANY_SHIELD))
	{
		u8[A1 + 0x2b] &= ~char.bonus.ALL_SHIELDS
		u8[A1 + 0x2b] |= char.bonus.ANY_SHIELD
		u32[0xffffcce8] = 0x0194ce
		u16[0xffffcce8 + 0x42] = A1.u16
	}
#endif
}





// Apply the goal pole and end of level to Challenge modes
// and handle shortcut inputs and end-of-level functions.
// Function taken from standalone\timeattack.lemon
function void Standalone.checkTimeAttackFinish()
{
	// For time attack, check if end was reached
	if ((time_attack != 1 && time_attack != 2) || global.game_mode != 0x0c)	// don't run any of this code if we're not actively playing a level in a Challenge mode
		return

	Challenge.checkRestartShortcut()
	Challenge.checkExitShortcut()

	// Reached the end?
	if (!Challenge.checkAndRenderFinish())
		return										// Only run the rest of this function if the player has actually finished

	Challenge.initializeLevelEnd()
	Challenge.setEndCameraPosition()
	Challenge.setEndPlayerPosition()
	Challenge.saveMedalsAndRecords()
	Challenge.showEndInterface()
}




function void Challenge.checkRestartShortcut()
{
	if (Input.buttonPressed(BUTTON_Y) && (global.zone < 0x0c || global.zone == 0x16) && !time_attack_end && !global.game.paused)
	{
		restart_timer = 1
	}
	else if (Input.buttonDown(BUTTON_Y) && restart_timer >= 1 && (global.zone < 0x0c || global.zone == 0x16) && !time_attack_end && !global.game.paused)
	{
		++restart_timer
	}
	else
	{
		restart_timer = 0
	}

	if (restart_threshold > 1)
		Renderer.drawCustomSprite("whitescreen", 0, 0, 0, SPRITE_FLAG_PRIO, 0xffff, 0, restart_timer * 8)

	if (restart_timer == restart_threshold)
	{
		restart_timer = 0
		checkpoint.number = 0
		global.zone_act = global.zone_act.apparent	// this prevents the endings of AIZ1 and ICZ1 from exhibiting undesirable behavior

		camera.background.x = 0		// from function void restartLevel(), which Euka uses as the
		camera.background.y = 0		// fix for the AIZ1 background issue
		u8[0x818080] = 0			// Clear the flag for the extended vertical scroll buffer.

		if (System.getGlobalVariableValueByName("DAGE_characterName") == "Chaos")	// Chaos the Imposter is active
			System.setGlobalVariableValueByName("ChaosForm", 0)

		time_attack_end = 0			// This isn't needed in theory, but better safe than sorry!
		level.restart = 1
	}
}


function void Challenge.checkExitShortcut()
{
	if (Input.buttonPressed(BUTTON_BACK) && (global.zone < 0x0c || global.zone == 0x16) && !time_attack_end && !global.game.paused)
	{
		exit_timer = 1
	}
	else if (Input.buttonDown(BUTTON_BACK) && exit_timer >= 1 && (global.zone < 0x0c || global.zone == 0x16) && !time_attack_end && !global.game.paused)
	{
		++exit_timer
	}
	else
	{
		exit_timer = 0
	}

	if (exit_threshold > 1 && exit_timer > restart_timer)
		Renderer.drawCustomSprite("whitescreen", 0, 0, 0, SPRITE_FLAG_PRIO, 0xffff, 0, exit_timer * 8)

	if (exit_timer == exit_threshold)
	{
		exit_timer = 0
		checkpoint.number = 0

		camera.background.x = 0		// from function void restartLevel(), which Euka uses as the
		camera.background.y = 0		// fix for the AIZ1 background issue
		u8[0x818080] = 0			// Clear the flag for the extended vertical scroll buffer.

		if (System.getGlobalVariableValueByName("DAGE_characterName") == "Chaos")	// Chaos the Imposter is active
			System.setGlobalVariableValueByName("ChaosForm", 0)

	//	global.zone_act = global.zone_act.apparent	// this prevents the endings of AIZ1 and ICZ1 from exhibiting undesirable behavior
	//	zeroMemory(0xffffeec0, 0x10)	// clear out special screen scrolling and plane effects
		global.game_mode = 0xd4		// Formerly 0x1c for standard level select, now 0xd4 for custom menu + 0x80 (the trigger to load new mode next frame)
		hud.dirty.timer = 0			// hud.dirty.timer = 1 is a condition to play time attack clear music and save best times.
									// This prevents menu use at high x positions (such as in ICZ1) to be past another act's pole before the start position is loaded.
		time_attack_end = 0			// This isn't needed in theory, but better safe than sorry!
		return
	}
}


// This function has been copied into the Chaos the Impostor mod to change its LRZ2 goal pole location.
// If more levels are ever designed, they must use a brand new function to place their goal poles.
// That way, character mods don't need to be updated immediately.
function u16 Challenge.checkAndRenderFinish()
{
	s16 px = s16[0xffffb010]
	s16 py = s16[0xffffb014]
	pole.x = -1
	pole.y = -1

	// AIZ
	if (global.zone_act.apparent == 0x0000)
	{
		if (global.zone_act == 0x0001)
		{
			pole.x = (py >= 0x0400) ? 0x1150 : 0x1188	// First is end for Knuckles, second is for S/T
			pole.y = (py >= 0x0400) ? 0x0510 : 0x0370
		}
	}
	else if (global.zone_act.apparent == 0x0001)
	{
		pole.x = (py >= 0x0400) ? 0x4000 : 0x42c0	// 0x4200		// First is end for Knuckles, second is for S/T
		pole.y = (py >= 0x0400) ? 0x0690 : 0x020e	// 0x0211
	}

	// HCZ
	if (global.zone_act.apparent == 0x0100 && u16[0xffffb010] > 0x3660 && u16[0xffffb014] > 0x0480)
	{
		pole.x = 0x3720	// 0x35b0
		pole.y = 0x0700	// 0x0400
	}
	else if (global.zone_act.apparent == 0x0101)
	{
		pole.x = (py >= 0x0400) ? 0x3fe0 : 0x45d0		// First is end for S/T, second is for Knuckles
		pole.y = (py >= 0x0400) ? 0x0800 : 0x0380
	}

	// MGZ
	if (global.zone_act.apparent == 0x0200)
	{
		pole.x = 0x2e80		// 0x2d40 in original game, but a giant ring is above this coordinate in DAGE
		pole.y = 0x0ed0
	}
	else if (global.zone_act.apparent == 0x0201)
	{
		if (py < 0x0100 && camera.position.x.u16 > 0x3440)	// camera check is used in case an Eggman encounter needs to lock the camera
		{
			pole.x = 0x3c10		// For Sonic/Tails' path (in vanilla, Knuckles' path)
			pole.y = 0x00cc		// Moved downward to accommodate D.A. Garden's different entrance height to the boss room
		}
		else if (py >= 0x0500 && py < 0x07f0 && camera.position.x.u16 > 0x3440)	// camera check is used in case an Eggman encounter needs to lock the camera
		{
			pole.x = 0x3d00	// 0x3c80		// For Knuckles path (in vanilla, Sonic/Tails' path)
			pole.y = 0x074c
		}
		else
		{
			pole.x = -1		// If we're not at the appropriate y coordinates for a goal pole, use the default settings.
			pole.y = -1		// The layout zigzags and can conflict with a camera maximum x position reliant on the pole.
			if (camera.position.x.u16 > 0x3440)
				move_area.right = 0x6000	// revert to default camera max x position if we've passed all Eggman encounters
		}
	}

	// CNZ
	if (global.zone_act.apparent == 0x0300)
	{
		pole.x = 0x32c0
		pole.y = 0x0240
		// pole.x = 0x30a0
		// pole.y = (py < 0x0880) ? 0x0240 : 0x0940		// First is end for S/T, second is for Knuckles
	}
	else if (global.zone_act.apparent == 0x0301)
	{
		pole.x = 0x4750
		pole.y = 0x0300
	}

	// ICZ
	if (global.zone_act.apparent == 0x0500)
	{
		if (global.zone_act == 0x0501)
		{
			pole.x = 0x0700
			pole.y = (py < 0x0500) ? 0x0380 : 0x0980		// First is end for S/T, second is for Knuckles
		}
	}
	else if (global.zone_act.apparent == 0x0501)
	{
		pole.x = 0x4400
		pole.y = 0x06c0
	}

	// LBZ
	if (global.zone_act.apparent == 0x0600)
	{
		if (u8[0xffff869d] == 0xb9 && u16[0xffffb014] > 0x0840)	// if a layout chunk from the Knuckles act ending is in use and we didn't just see the building collapse
		{
			pole.x = 0x3d38 // top of building: 0x3ae0
			pole.y = 0x0b00 // top of building: 0x0480
		}
		else
		{
			pole.x = 0x3ec0	// 0x38e0
			pole.y = 0x0200	// 0x0600
		}
	}
	else if (global.zone_act.apparent == 0x0601)
	{
		if (py < 0x0500 || py > 0x0700)
		{
			pole.x = 0x43a0		// For Knuckles
			pole.y = 0x03e0
		}
		else
		{
			pole.x = 0x3a40	// 0x39e0		// For Sonic/Tails
			pole.y = 0x0600	// 0x0639
		}
	}

	// MHZ
	if (global.zone_act.apparent == 0x0700)
	{
		pole.x = 0x42e0
		pole.y = 0x07c0
	}
	else if (global.zone_act.apparent == 0x0701)
	{
		pole.x = 0x3d38	// 0x41e0	// 0x3b90
		pole.y = 0x0340	// 0x0300
	}

	// FBZ
	if (global.zone_act.apparent == 0x0400)
	{
		pole.x = 0x2f00	// 0x2d70
		pole.y = 0x0600
	}
	else if (global.zone_act.apparent == 0x0401)
	{
	//	if (py < 0x0700)
	//	{
			pole.x = 0x32c8	// 0x3300	// 0x29f0
			pole.y = 0x0340	// 0x0680
	//	}
	}

	// SOZ
	if (global.zone_act.apparent == 0x0800)
	{
		pole.x = 0x4340	// 0x4380
		pole.y = 0x0a00
	}
	else if (global.zone_act.apparent == 0x0801)
	{
		pole.x = 0x50c0	// 0x5160
		pole.y = 0x0740
	}

	// LRZ
	if (global.zone_act.apparent == 0x0900)
	{
		pole.x = 0x2b90
		pole.y = 0x07c2	// 0x07c1
	}
	else if (global.zone_act.apparent == 0x0901)
	{
		if (isMainCharacter(CHARACTER_KNUCKLES))
		{
			pole.x = 0x3d00
			pole.y = (u16[0xffffb014] < 0x0120) ? 0x0110 : 0x0200	// upper exit, then lower exit
		}
		else if (u16[0xffffb010] > 0x3540 && u16[0xffffb010] < 0x3800 && u16[0xffffb014] < 0x0250)	// Sonic or Tails, with bounding box to prevent flying under the pole
		{
			pole.x = 0x37a8	// 0x3880
			pole.y = 0x0240
		}
	}

	// HPZ
	if (global.zone_act.apparent == 0x1601)
	{
		pole.x = (camera.position.x.u16 < 0x0a40 && camera.position.y.u16 < 0x0480) ? 0x0ac0 : 0x1180	// Knux path, then Sonic or Tails path
		pole.y = 0x0440
	}

	// SSZ
	if (global.zone_act.apparent == 0x0a00)
	{
		if (py >= 0x0800 && py < 0x0a00)
		{
			pole.x = 0x1a40
			pole.y = 0x0980
		}
		else
		{
			pole.x = 0x1a40
			pole.y = 0x0680
		}
	}

	// DEZ
	if (global.zone_act.apparent == 0x0b00)
	{
		pole.x = 0x3740	// 0x3540
		pole.y = 0x0340	// 0x0300
	}
	else if (global.zone_act.apparent == 0x0b01)
	{
		pole.x = 0x3bc0	// 0x3800	// 0x3570
		pole.y = 0x0340	// 0x04c0
	}

	if (pole.x != -1 && pole.y != -1)
	{
		// Render the goal pole
		u64 key = stringformat("timeattack_pole_0%d", ((level.framecounter / 6) & 0x03) + 1)
		u8 flags = (global.zone_act.apparent == 0x0a00 || global.zone_act.apparent == 0x0b00 || global.zone_act.apparent == 0x0001 ) ? SPRITE_FLAG_PRIO : 0x00
		Renderer.drawCustomSprite(key, pole.x - camera.position.x.u16, pole.y - camera.position.y.u16 - 30, 0x00, flags, 0x9f00)


		move_area.right = pole.x - (getScreenWidth() / 2) + (2 * getScreenExtend()) 	// Set the camera x maximum in a way that centers the goal pole.
																						// move_area.right always seems to be 0x50 (decimal 80) greater than the camera lock,
																						// likely due to compensating for widescreen.
		if (px >= pole.x)
			return true
	}

	return false
}





function void Challenge.initializeLevelEnd()
{
	if (hud.dirty.timer)
	{
		time_attack_end = 1
		playMusic(MUSIC_LEVELCLEAR)
		hud.dirty.timer = 0
		freeze_time_bonus = 0	// initialize the freeze_time_bonus this frame
		timer.alldata_copy = timer.alldata 	// save the timer data before applying any bonus

		if (freeze_time)
			Challenge.applyTimeStopBonus()
	}
}



function void Challenge.applyTimeStopBonus()
{
	//	++timer.alldata		// when the HUD updates, it shows one frame ahead of the actual time, which looks improper if time is frozen as the stage ends

	// This block cuts any freeze_time that would push the final time under one second by 90%
	s64 totalTimerFrames = (timer.minutes * 3600) + (timer.seconds * 60) + timer.frames		// get the timer as a number of frames
	s64 maxNormalFreezeTime = (totalTimerFrames - 60) * 10		// max freeze_time value that does NOT drop the final time below one second
	s64 overMaxFreezeTime = freeze_time - maxNormalFreezeTime	// number of freeze_time ticks over the cap
	if (timer.minutes == 0 && timer.seconds < 1)					// If we finished the level with under one second on the clock,
		freeze_time /= 10											// then all freeze time should get the 90% reduction.
	else if (overMaxFreezeTime > 0)									// Otherwise, if there is actually freeze time beyond the cap,
		freeze_time = freeze_time - (9 * overMaxFreezeTime / 10)	// remove 90% of that extra freeze time.
	freeze_time_bonus = (freeze_time / 10)			// Award a bonus of 10% of frozen time.
	if (freeze_time_bonus >= totalTimerFrames)		// If the bonus time reduction is greater than the actual time on the clock,
		timer.alldata = 0							// then record a final time of 0'00"00. (Bonus weight under 0'01"00 should make this impossible in practice.)
	else
	{
		totalTimerFrames -= freeze_time_bonus		// Take the bonus amount out of the total completion time.
		s64 timer.minutes.temp = totalTimerFrames / 3600	// Set minutes, seconds, and frames on the timer with what remains.
		timer.minutes = timer.minutes.temp			// We use temp values because the u8 values cap at every step of the calculation.
		s64 timer.seconds.temp = (totalTimerFrames - (timer.minutes * 3600)) / 60	// We then typecast to the appropriate byte.
		timer.seconds = timer.seconds.temp
		s64 timer.frames.temp = totalTimerFrames - (timer.minutes * 3600) - (timer.seconds * 60)
		timer.frames = timer.frames.temp
	}

	// System.writeDisplayLine(stringformat("Freeze frames remaining: %d", freeze_time))

	freeze_time = 0		// remove remaining freeze time
}




function void Challenge.setEndCameraPosition()
{
	s16 py = s16[0xffffb014]
	move_area.left = pole.x - (getScreenWidth() / 2)		// This currently causes some rendering issues if a spin dash delays the camera right at the pole.
														// We redraw plane A later to correct this, but that's not possible at the end of FBZ2 due to the quake rendering.

	// These vertical positions will need to be adapted to each act, or can be done through boss arena scripts.
	if (global.zone_act.apparent == 0x0101)							// HCZ2 needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x18
	else if (global.zone_act.apparent == 0x0201 && py < 0x0100)		// MGZ2 upper exit needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x34
	else if (global.zone_act.apparent == 0x0301)					// CNZ2 needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x20
	else if (global.zone_act.apparent == 0x0401)					// FBZ2 needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x2e
	else if (global.zone_act.apparent == 0x0501)					// ICZ2 needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x18
	else if (global.zone_act.apparent == 0x0601 && py > 0x0500 )	// LBZ2 lower exit needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x28
	else if (global.zone_act.apparent == 0x0900)					// LRZ1 needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x2e
	else if (global.zone_act.apparent == 0x0901)					// LRZ2 needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x2e
	else if (global.zone_act.apparent == 0x1601 && pole.x == 0x0ac0)	// HPZ needs a screen lock for Knux since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x20
	else if (global.zone_act.apparent == 0x0a00)					// SSZ1 needs a screen lock since it doesn't end in the boss area
		move_area.bottom.target = pole.y - getScreenHeight() + 0x20

	if (global.zone_act.apparent != 0x0401)	// refreshing plane A in FBZ2's ending causes issues because of the dual-plane display.
		fillPlaneA_Default(camera.position.x.u16, camera.position.y.u16, getScreenWidth(), getScreenHeight())	// refresh the screen to avoid visual glitches caused by spindash camera delay or LBZ1 building loading
}



function void Challenge.setEndPlayerPosition()
{
	control.player1.state = 0	// disable all held controls
	player1.control_override = 1


	if (isMainCharacter(CHARACTER_TAILS) && u8[0xffffb02f])	// check for Tails flight and end it. The above control lock will end Knuckles gliding.
	{
		u8[0xffffb02f] = 0
		u8[0xffffb020] = char.state.ROLLING
	}


	s16[0xffffb010] = pole.x	// set x position to pole position
	s16[0xffffb018] = 0			// remove x velocity in the air
	s16[0xffffb01c] = 0			// remove x velocity on the ground
	A1 = 0xffffb000				// place character RAM address into A1 for win pose function
	A0 = A1						// place character RAM address into A0 for character state checks

	char.drown_countdown = 30	// reset the drowning counter of the character in A0, which can be active at the end of HCZ2
	if (!(u8[0xffffb02a] & 0x02) &&  u8[0xffffb020] != char.state.WIN_POSE)	// if not in the air and not already posing,
	{
		if (char.state == char.state.ROLLING || char.state == char.state.SPINDASH)
			char.position.y.u16 -= (char.character == CHARACTER_TAILS) ? 1 : 5	// remove character roll height change
		StartCharacterWinPose()													// start win pose
	}
}




function void Challenge.saveMedalsAndRecords()
{
	// Check if the achieved time achieved a medal, and render it and put its value in shared memory if so
	u8 medalType = 0
	if (System.getGlobalVariableValueByName("DAGE_characterName") || Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles") || u8[0xffffe654] > 0x00)	// modded characters get no medals
		medalType = 0
	else if (timer.alldata <= u32[0x840240 + (0x10 * (setting.levelselect.characters - 1)) + 0x04])	// gold medal?
		medalType = 3
	else if (timer.alldata <= u32[0x840240 + (0x10 * (setting.levelselect.characters - 1)) + 0x08])	// silver medal?
		medalType = 2
	else if (timer.alldata <= u32[0x840240 + (0x10 * (setting.levelselect.characters - 1)) + 0x0c])	// bronze medal?
		medalType = 1

	if (medalType > u8[best_time_address])		// If this medal is better than the previous one,
		u8[best_time_address] = medalType		// put the value in shared memory.

	if (medalType)	// if we earned any medal at all this run
	{
		u16 animFrame = ((static_rings.animframe * 8 + 7 - static_rings.animtimer) / 4) % 8
		u64 medalKey = stringformat("medal_0%d_0%d", medalType, animFrame)
		Renderer.drawCustomSprite(medalKey, getScreenExtend() - 40 + 200, 69, 0x00, 0x40, 0xe800)	// y position of 68 in pre-theme DAGE versions
	}

	// Allow other mods to make custom data when completing the level.
	saveCustomThings()

	// Check if the achieved time is the best one
	if (timer.alldata < (u32[best_time_address] & 0x00ffffff))	// the and here equals best_time without affecting best_time for NEW RECORD text.
	{
		saveBestActTime()
	}
}




function void Challenge.showEndInterface()
{
	// Show NEW RECORD text
	if (timer.alldata < best_time)
	{
		if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			Flicky.NewRecordText()
		else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			Saturn.NewRecordText()
		else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			South.NewRecordText()
		else
			Renderer.drawCustomSprite("new_record", getScreenWidth() / 2, 0x2e, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)
	}

	// Show TIME STOP BONUS! text
	if (timer.alldata_copy != timer.alldata)	// if a time stop bonus was successfully applied, render a message informing the player.
	{
		if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			Flicky.TimeStopBonusText()
		else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			Saturn.TimeStopBonusText()
		else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
			South.TimeStopBonusText()
		else
			Renderer.drawCustomSprite("time_stop_bonus", getScreenWidth() - 62 - 16, 0x0e, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)	// 62 = sprite center, 16 = space to screen edge
	}

	PrintVersionNumber()
	Challenge.manageEndMenu()
}




function void Challenge.manageEndMenu()
{
	if (Input.buttonPressed(BUTTON_UP))
	{
		TA_menu_selection -= 1
		if (TA_menu_selection < 0)
			TA_menu_selection = 2
		else if (TA_menu_selection == 5)		// off top end of EXIT GAME menu
			TA_menu_selection = 8
		playSound(0x5b)
	}
	else if (Input.buttonPressed(BUTTON_DOWN))
	{
		TA_menu_selection += 1
		if (TA_menu_selection == 3)
			TA_menu_selection = 0
		if (TA_menu_selection > 8)		// off bottom end of EXIT GAME menu
			TA_menu_selection = 6
		playSound(0x5b)
	}

	Renderer.drawCustomSprite("3_option_dim", getScreenWidth()/2, getScreenHeight()/2, 0x00, SPRITE_FLAG_PRIO, 0xe000, 0, 204)		// menu border rectangle (80% opacity)
	if (theme.hud == theme.flicky && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		Flicky.TAEndMenu()
	else if (theme.hud == theme.saturn && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		Saturn.TAEndMenu()
	else if (theme.hud == theme.south && !System.getGlobalVariableValueByName("DAGE_characterName") && !Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
		South.TAEndMenu()
	else if (TA_menu_selection < 3)
	{
		Renderer.drawCustomSprite(stringformat("ta_retry_%d", TA_menu_selection), getScreenWidth()/2, getScreenHeight()/2 - 16, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)
		Renderer.drawCustomSprite(stringformat("ta_select_act_%d", TA_menu_selection), getScreenWidth()/2, getScreenHeight()/2, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)	// center of screen vertically
		Renderer.drawCustomSprite(stringformat("ta_exit_game_%d", TA_menu_selection), getScreenWidth()/2, getScreenHeight()/2 + 16, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)
	}
	else
	{
		Renderer.drawCustomSprite(stringformat("cancel_%d", TA_menu_selection), getScreenWidth()/2, getScreenHeight()/2 - 16, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)
		Renderer.drawCustomSprite(stringformat("main_menu_%d", TA_menu_selection), getScreenWidth()/2, getScreenHeight()/2, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)	// center of screen vertically
		Renderer.drawCustomSprite(stringformat("air_menu_%d", TA_menu_selection), getScreenWidth()/2, getScreenHeight()/2 + 16, 0, SPRITE_FLAG_PRIO, 0xe001, 0, 255)
	}

	if (control.pad1.pressed & 0xe0 && TA_menu_selection == 0)	// 0xe0 is CONTROL_START | CONTROL_A | CONTROL_C
	{
	//	time_attack_end = 0			// Moving this to Standalone.onLevelStart() to avoid medal times showing for one frame after restarting a time attack.
									// However, we now must consider what happens if we don't go to a *level* next (e.g., Green Sphere).
		restart_timer = 0
		checkpoint.number = 0
		global.zone_act = global.zone_act.apparent	// this prevents the endings of AIZ1 and ICZ1 from exhibiting undesirable behavior

		camera.background.x = 0		// from function void restartLevel(), which Euka uses as the
		camera.background.y = 0		// fix for the AIZ1 background issue

		level.restart = 1
	}
	else if (control.pad1.pressed & 0xe0 && TA_menu_selection == 1)
	{
	//	time_attack_end = 0			// Moving this to Standalone.onLevelStart() to avoid medal times showing for one frame after exiting a time attack.
									// However, we now must consider what happens if we don't go to a *level* next (e.g., Green Sphere).
	//	zeroMemory(0xffffeec0, 0x10)	// clear out special screen scrolling and plane effects

		camera.background.x = 0		// from function void restartLevel(), which Euka uses as the
		camera.background.y = 0		// fix for the AIZ1 background issue

		global.game_mode = 0xd4		// Formerly 0x1c for standard level select, now 0xd4 for custom menu + 0x80 (the trigger to load new mode next frame)
		hud.dirty.timer = 0			// hud.dirty.timer = 1 is a condition to play time attack clear music and save best times.
									// This prevents menu use at high x positions (such as in ICZ1) to be past another act's pole before the start position is loaded.
		return
	}
	else if (control.pad1.pressed & 0xe0 && TA_menu_selection == 2)
	{
		TA_menu_selection = 6

	//	checkpoint.number = 0
	//	global.zone_act = global.zone_act.apparent	// this prevents the endings of AIZ1 and ICZ1 from exhibiting undesirable behavior
	//	hud.dirty.timer = 0			// hud.dirty.timer = 1 is a condition to play time attack clear music and save best times.
									// This prevents menu use at high x positions (such as in ICZ1) to be past another act's pole before the start position is loaded.
	//	global.game_mode = 0x58		// return to DAGE main menu
		return
	}

	else if (control.pad1.pressed & 0xe0 && TA_menu_selection == 6 || (control.pad1.pressed & CONTROL_B))	// 0xe0 is CONTROL_START | CONTROL_A | CONTROL_C
	{
		TA_menu_selection = 2
	}

	else if (control.pad1.pressed & 0xe0 && TA_menu_selection == 7)	// 0xe0 is CONTROL_START | CONTROL_A | CONTROL_C
	{
		restart_timer = 0
		exit_timer = 0
		checkpoint.number = 0
		global.zone_act = global.zone_act.apparent	// this prevents the endings of AIZ1 and ICZ1 from exhibiting undesirable behavior

		camera.background.x = 0		// from function void restartLevel(), which Euka uses as the
		camera.background.y = 0		// fix for the AIZ1 background issue

		global.game_mode = 0x58
	}
	else if (control.pad1.pressed & 0xe0 && TA_menu_selection == 8)
	{
		restart_timer = 0
		exit_timer = 0
		checkpoint.number = 0
		global.zone_act = global.zone_act.apparent	// this prevents the endings of AIZ1 and ICZ1 from exhibiting undesirable behavior

		camera.background.x = 0		// from function void restartLevel(), which Euka uses as the
		camera.background.y = 0		// fix for the AIZ1 background issue

		exitGame = 1
		// Game.returnToMainMenu()
	}
}







// Function created by FadeInside for Extra Slot Characters Unlimited
function void saveCustomThings()
{
	// Custom things
}





function void saveBestActTime()
{
	if (Mods.isModActive("3D2D Glitches: Sonic 3 With Bluckles"))
	{
		saveBestActTime3D2DGlitches()
		return
	}
	if (System.getGlobalVariableValueByName("DAGE_characterName"))
	{
		saveBestActTimeModded()
		return
	}

	u64 datakey
	u32 save_data_address = 0x840000

	// Place the new best time into shared memory
	u8[best_time_address + 1] = timer.minutes
	u16[best_time_address + 2] = u16[0xfffffe24]	// this is the address of timer.seconds and extends into timer.frames

	// Find the appropriate key where best times are permanently saved
	if (time_attack == 1)
	{
		datakey = "DAGE_SonicTA"
		if (setting.levelselect.characters == 0x02)
		{
			datakey = "DAGE_TailsTA"
			save_data_address += 0x60
		}
		else if (setting.levelselect.characters >= 0x03)
		{
			datakey = "DAGE_KnuxTA"
			save_data_address += 0xc0
		}
	}
	else
	{
		datakey = "DAGE_SonicTST"
		save_data_address += 0x120
		if (setting.levelselect.characters == 0x02)
		{
			datakey = "DAGE_TailsTST"
			save_data_address += 0x60
		}
		else if (setting.levelselect.characters >= 0x03)
		{
			datakey = "DAGE_KnuxTST"
			save_data_address += 0xc0
		}
	}

	// Save best time
	System.savePersistentData(save_data_address, datakey, 0x60)
}

function void saveBestActTime3D2DGlitches()
{
	u64 datakey
	u32 save_data_address = 0x840000

	// Place the new best time into shared memory
	u8[best_time_address + 1] = timer.minutes
	u16[best_time_address + 2] = u16[0xfffffe24]	// this is the address of timer.seconds and extends into timer.frames

	// Find the appropriate key where best times are permanently saved
	if (time_attack == 1)
	{
		datakey = "DAGE_AshuraTA"
		if (setting.levelselect.characters == 0x02)
		{
			datakey = "DAGE_WechniaTA"
			save_data_address += 0x60
		}
		else if (setting.levelselect.characters >= 0x03)
		{
			datakey = "DAGE_BluxTA"
			save_data_address += 0xc0
		}
	}
	else
	{
		datakey = "DAGE_AshuraTST"
		save_data_address += 0x120
		if (setting.levelselect.characters == 0x02)
		{
			datakey = "DAGE_WechniaTST"
			save_data_address += 0x60
		}
		else if (setting.levelselect.characters >= 0x03)
		{
			datakey = "DAGE_BluxTST"
			save_data_address += 0xc0
		}
	}

	// Save best time
	System.savePersistentData(save_data_address, datakey, 0x60)
}

function void saveBestActTimeModded()
{
	u64 datakey
	string moddedCharacterBaseKey = System.getGlobalVariableValueByName("DAGE_characterName")
	u64 moddedCharacterTAKey = stringformat("DAGEmod_%sTA",moddedCharacterBaseKey)
	u64 moddedCharacterTSTKey = stringformat("DAGEmod_%sTST",moddedCharacterBaseKey)
	u32 save_data_address = (time_attack == 2) ? 0x840120 : 0x840000

	// Place the new best time into shared memory
	u8[best_time_address + 1] = timer.minutes
	u16[best_time_address + 2] = u16[0xfffffe24]	// this is the address of timer.seconds and extends into timer.frames

	// Find the appropriate key where best times are permanently saved
	if (time_attack == 1)
		datakey = moddedCharacterTAKey
	else
		datakey = moddedCharacterTSTKey

	// Save best time
	System.savePersistentData(save_data_address, datakey, 0x60)
}






// Don't revert from invincibility to normal level music if a time attack is finished
// Function taken from maingame\character\character.lemon
function void Character.updateBonusEffects()
{
#if STANDALONE
	// Super Cancel
	if (Game.getSetting(SETTING_SUPER_CANCEL) && Input.buttonPressed(BUTTON_Y))
	{
		bool isSuperActive = (char.character == CHARACTER_TAILS) ? super.active.tails : super.active
		u8 transformingState = (char.character == CHARACTER_TAILS) ? char.state.TAILS_TRANSFORM : char.state.TRANSFORMING
		if (isSuperActive && char.state != transformingState)
		{
			// Not in Doomsday and not in Sonic's AIZ intro
			if (global.zone_act != 0x0c00 && (char.control_flags & 0x40) == 0)
			{
				Character.cancelSuperTransformation()
				chooseFittingMusic()
				char.jumping = 0		// Do not allow another transformation until hit the ground
			}
		}
	}
#endif

	bool doRender = true
	if (char.invuln.countdown > 0)
	{
		doRender = ((char.invuln.countdown & 0x04) != 0)
		--char.invuln.countdown
	}
	if (doRender)
	{
		DrawObject()
	}

	if ((char.bonus_effect & char.bonus.INVINCIBLE) && char.invinc.countdown > 0)
	{
		if ((level.framecounter & 0x07) == 0)
		{
			--char.invinc.countdown
			if (char.invinc.countdown == 0)
			{
				// Back to normal
				if (!level.boss_encounter && char.drown_countdown >= 12 && u8[0xffffb020] != char.state.WIN_POSE)
				{
					playMusic(level.default_music)
				}
				char.bonus_effect &= ~char.bonus.INVINCIBLE

			#if STANDALONE
				// Half a second of extra invincibility
				char.invuln.countdown = max(char.invuln.countdown, 60)
			#endif
			}
		}
	}

	if ((char.bonus_effect & char.bonus.SPEED_UP) && char.speedup.countdown > 0)
	{
		if ((level.framecounter & 0x07) == 0)
		{
			--char.speedup.countdown
			if (char.speedup.countdown == 0)
			{
				char.bonus_effect &= ~char.bonus.SPEED_UP

				if (char.character != CHARACTER_KNUCKLES && competition_mode.active)
				{
					A1 = 0x1e3c00 + (char.character * 8)
					u16[A4] = u16[A1]
					u16[A4+2] = u16[A1+2]
					u16[A4+4] = u16[A1+4]
				}
				else
				{
					setSpeedCapProperties(A4)
					changeMusicTempo(0)
				}
			}
		}
	}
}





// If a time attack mode is active, don't allow the data select menu and instead use the level select menu.
// Function taken from standalone\entryfunctions.lemon
function void loadupDataSelect()
{
	if (time_attack == 1 || time_attack == 2)
 	{
 		global.game_mode = 0xd4
	//	EntryFunctions.levelSelect()
	//	EntryFunctions.dataSelect()
	//	loadupCustomMenu()
 	}
	else
	{
		// Load save states
		InitSaveSlots()

		// Go to Data Select
		global.game_mode = 0x4c
		DataSelect.setup()
		Menu.FadeInAfterInit()
		//Menu.fadeInImmediatelyAfterInit()
		DataSelect.update()
	}
}